
MODULE oad_intrinsics
use OAD_active
use w2f__types
IMPLICIT NONE
SAVE
!
!     **** Statements ****
!
END MODULE

MODULE parameters
use OAD_active
use w2f__types
IMPLICIT NONE
SAVE
!
!     **** Global Variables & Derived Type Definitions ****
!
REAL(w2f__8) PERM(1 : 3, 1 : 10, 1 : 10, 1 : 2)
REAL(w2f__8) POR(1 : 200)
!
!     **** Local Variables and Functions ****
!
CHARACTER(15) DATA_DIRECTORY
PARAMETER ( DATA_DIRECTORY = '../data/data_1/')
REAL(w2f__8) HX_
PARAMETER ( HX_ = 6.09600000000000008527D00)
REAL(w2f__8) HY_
PARAMETER ( HY_ = 3.04800000000000004263D00)
REAL(w2f__8) HZ_
PARAMETER ( HZ_ = 6.09600000000000030731D-01)
REAL(w2f__8) IR
PARAMETER ( IR = 1.4171123504638671875D-01)
INTEGER(w2f__i4) MAXNX
PARAMETER ( MAXNX = 60)
INTEGER(w2f__i4) MAXNY
PARAMETER ( MAXNY = 220)
INTEGER(w2f__i4) MAXNZ
PARAMETER ( MAXNZ = 85)
INTEGER(w2f__i4) ND
PARAMETER ( ND = 2000)
INTEGER(w2f__i4) NX_
PARAMETER ( NX_ = 10)
INTEGER(w2f__i4) NY_
PARAMETER ( NY_ = 10)
INTEGER(w2f__i4) NZ_
PARAMETER ( NZ_ = 2)
INTEGER(w2f__i4) N_
PARAMETER ( N_ = 200)
CHARACTER(22) PERMEABILITY_FILE
PARAMETER ( PERMEABILITY_FILE = '../data/data_1/KUr.txt')
CHARACTER(22) POROSITY_FILE
PARAMETER ( POROSITY_FILE = '../data/data_1/pUr.txt')
INTEGER(w2f__i4) PT
PARAMETER ( PT = 100)
CHARACTER(8) RESULTS_DIRECTORY
PARAMETER ( RESULTS_DIRECTORY = 'results/')
CHARACTER(48) RESULTS_EVAL_DERIV_TAP_1_FWD
PARAMETER ( RESULTS_EVAL_DERIV_TAP_1_FWD = 'results/results_eval_deriv_tapenade_&
     &1_forward.nc')

CHARACTER(48) RESULTS_EVAL_DERIV_TAP_1_REV
PARAMETER ( RESULTS_EVAL_DERIV_TAP_1_REV = 'results/results_eval_deriv_tapenade_&
     &1_reverse.nc')

CHARACTER(37) RESULTS_EVAL_ORIGINAL_CODE
PARAMETER ( RESULTS_EVAL_ORIGINAL_CODE = 'results/results_eval_original_code.nc'&
     &)

INTEGER(w2f__i4) SCENARIO_ID
PARAMETER ( SCENARIO_ID = 1)
INTEGER(w2f__i4) SOLVER_INNER
PARAMETER ( SOLVER_INNER = 64)
INTEGER(w2f__i4) SOLVER_OUTER
PARAMETER ( SOLVER_OUTER = 100000)
REAL(w2f__8) SOR_
PARAMETER ( SOR_ = 2.00000000000000011102D-01)
INTEGER(w2f__i4) ST
PARAMETER ( ST = 5)
REAL(w2f__8) SWC_
PARAMETER ( SWC_ = 2.00000000000000011102D-01)
LOGICAL(w2f__i4) VERBOSE
PARAMETER ( VERBOSE = .FALSE.)
REAL(w2f__8) VO_
PARAMETER ( VO_ = 3.00000000000000006245D-03)
REAL(w2f__8) VW_
PARAMETER ( VW_ = 2.99999999999999973719D-04)
REAL(w2f__8) V_
PARAMETER ( V_ = 1.13267386368000018138D+01)
!
!     **** Statements ****
!
END MODULE

MODULE mathutil
use OAD_active
use w2f__types
use oad_intrinsics
IMPLICIT NONE
SAVE
!
!     **** Statements ****
!
CONTAINS
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SCALAR_MAX(SCALARIN1, SCALARIN2, SCALAROUT)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_0
  INTEGER(w2f__i8) OpenAD_Symbol_1
  INTEGER(w2f__i8) OpenAD_Symbol_2
  INTEGER(w2f__i8) OpenAD_Symbol_3
  INTEGER(w2f__i8) OpenAD_Symbol_4
  INTEGER(w2f__i8) OpenAD_Symbol_5
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) SCALARIN1
  REAL(w2f__8) SCALARIN2
  REAL(w2f__8) SCALAROUT


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_real_scalar(SCALARIN1,theArgFStack,theArgFStackoffset,theArgFSta&
     &ckSize)

  call cp_store_real_scalar(SCALARIN2,theArgFStack,theArgFStackoffset,theArgFSta&
     &ckSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  SCALARIN2 = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  SCALARIN1 = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  IF(SCALARIN1 .GE. SCALARIN2) THEN
    SCALAROUT = SCALARIN1
  ELSE
    SCALAROUT = SCALARIN2
  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  IF(SCALARIN1 .GE. SCALARIN2) THEN
    SCALAROUT = SCALARIN1
    OpenAD_Symbol_1 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_1
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    SCALAROUT = SCALARIN2
    OpenAD_Symbol_2 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_2
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_0 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_0 .ne. 0) THEN
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SCALAR_MAX
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE DNRM2(V, LEN_V, N)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_10
  INTEGER(w2f__i8) OpenAD_Symbol_11
  INTEGER(w2f__i8) OpenAD_Symbol_12
  INTEGER(w2f__i8) OpenAD_Symbol_13
  INTEGER(w2f__i8) OpenAD_Symbol_14
  INTEGER(w2f__i8) OpenAD_Symbol_15
  INTEGER(w2f__i8) OpenAD_Symbol_16
  INTEGER(w2f__i8) OpenAD_Symbol_17
  INTEGER(w2f__i8) OpenAD_Symbol_18
  INTEGER(w2f__i8) OpenAD_Symbol_19
  INTEGER(w2f__i8) OpenAD_Symbol_20
  INTEGER(w2f__i8) OpenAD_Symbol_21
  INTEGER(w2f__i8) OpenAD_Symbol_22
  INTEGER(w2f__i8) OpenAD_Symbol_23
  INTEGER(w2f__i8) OpenAD_Symbol_6
  INTEGER(w2f__i8) OpenAD_Symbol_7
  INTEGER(w2f__i8) OpenAD_Symbol_8
  INTEGER(w2f__i8) OpenAD_Symbol_9
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) LEN_V
  REAL(w2f__8) N
  REAL(w2f__8) V(1 : LEN_V)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  REAL(w2f__8) OAD_CTMP0
  REAL(w2f__8) SCALEIN
  REAL(w2f__8) SCALEOUT


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(LEN_V,theArgIStack,theArgIStackoffset,theArgIStackSiz&
     &e)

  call cp_store_real_scalar(N,theArgFStack,theArgFStackoffset,theArgFStackSize)
  call cp_store_p_real_vector(V,size(V),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(V,1),lbound(V,1),-1
  V(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  N = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  LEN_V = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  N = 0.0D00
  SCALEIN = 0.0D00
  SCALEOUT = 0.0D00
  DO I = 1, LEN_V, 1
    OAD_CTMP0 = ABS(V(I))
    CALL SCALAR_MAX(SCALEIN,OAD_CTMP0,SCALEOUT)
    SCALEIN = SCALEOUT
  END DO
  IF(SCALEOUT .eq. 0.0D00) THEN
    N = 0.0D00
  ELSE
    DO I = 1, LEN_V, 1
      N = (N +((V(I) / SCALEOUT) ** 2))
    END DO
    N = (SCALEOUT * SQRT(N))
  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  N = 0.0D00
  SCALEIN = 0.0D00
  SCALEOUT = 0.0D00
  OpenAD_Symbol_11 = 0_w2f__i8
  DO I = 1, LEN_V, 1
    OAD_CTMP0 = ABS(V(I))
    CALL SCALAR_MAX(SCALEIN,OAD_CTMP0,SCALEOUT)
    SCALEIN = SCALEOUT
    OpenAD_Symbol_11 = (INT(OpenAD_Symbol_11) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_11
  integer_tape_pointer = integer_tape_pointer+1
  IF(SCALEOUT .eq. 0.0D00) THEN
    N = 0.0D00
    OpenAD_Symbol_13 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_13
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    OpenAD_Symbol_12 = 0_w2f__i8
    DO I = 1, LEN_V, 1
      N = (N +((V(I) / SCALEOUT) ** 2))
      OpenAD_Symbol_12 = (INT(OpenAD_Symbol_12) + INT(1_w2f__i8))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_12
    integer_tape_pointer = integer_tape_pointer+1
    N = (SCALEOUT * SQRT(N))
    OpenAD_Symbol_14 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_14
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_6 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_6 .ne. 0) THEN
  ELSE
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_7 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_8 = 1
    DO WHILE(INT(OpenAD_Symbol_8) .LE. INT(OpenAD_Symbol_7))
      OpenAD_Symbol_8 = INT(OpenAD_Symbol_8) + 1
    END DO
  ENDIF
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_9 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_10 = 1
  DO WHILE(INT(OpenAD_Symbol_10) .LE. INT(OpenAD_Symbol_9))
    CALL SCALAR_MAX(SCALEIN,OAD_CTMP0,SCALEOUT)
    OpenAD_Symbol_10 = INT(OpenAD_Symbol_10) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine DNRM2
END

MODULE matrix
use OAD_active
use w2f__types
use oad_intrinsics
use parameters
IMPLICIT NONE
SAVE
!
!     **** Top Level Pragmas ****
!
interface ADD_X
  module procedure ADDX_DIAGONAL
  module procedure ADDX_ELEM
end interface
interface MYMAX
  module procedure MYMAX_1_1_DOUBLE
  module procedure MYMAX_1_0_DOUBLE
  module procedure MYMAX_0_0_DOUBLE
end interface
interface MYMIN
  module procedure MYMIN_1_1_DOUBLE
  module procedure MYMIN_1_0_DOUBLE
  module procedure MYMIN_0_0_DOUBLE
end interface
interface MYRESHAPE
  module procedure MYRESHAPE_4_1
  module procedure MYRESHAPE_1_4
  module procedure MYRESHAPE_3_1
  module procedure MYRESHAPE_1_3
  module procedure MYRESHAPE_2_1
  module procedure MYRESHAPE_1_2
end interface
interface SPMAT_MULTIPLY
  module procedure SCALAR_MULTIPLY_SPMAT
  module procedure SPMAT_MULTIPLY_VECTOR
  module procedure SPMAT_MULTIPLY_DIAGONAL
end interface

!
!     **** Statements ****
!
CONTAINS
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE ADDX_ELEM(INNZ, IROW_INDEX, IROW_COMPRESSED, ICOL_INDEX, IVALUES, X&
     &, ROW, COL)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_24
  INTEGER(w2f__i8) OpenAD_Symbol_25
  INTEGER(w2f__i8) OpenAD_Symbol_26
  INTEGER(w2f__i8) OpenAD_Symbol_27
  INTEGER(w2f__i8) OpenAD_Symbol_28
  INTEGER(w2f__i8) OpenAD_Symbol_30
  INTEGER(w2f__i8) OpenAD_Symbol_31
  INTEGER(w2f__i8) OpenAD_Symbol_32
  INTEGER(w2f__i8) OpenAD_Symbol_33
  INTEGER(w2f__i8) OpenAD_Symbol_34
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) INNZ
  INTEGER(w2f__i4) IROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) IROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) ICOL_INDEX(1 : 1400)
  REAL(w2f__8) IVALUES(1 : 1400)
  REAL(w2f__8) X
  INTEGER(w2f__i4) ROW
  INTEGER(w2f__i4) COL
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i8) OpenAD_Symbol_29
  INTEGER(w2f__i8) OpenAD_Symbol_35


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
 2      CONTINUE
  GO TO 3
 3      CONTINUE
  GO TO 4
 4      CONTINUE
  I = 1
  GO TO 13
 5      CONTINUE
  I = I + 1
 13     CONTINUE
  IF(I .LE. INNZ) THEN
    GO TO 6
  ELSE
    GO TO 11
  ENDIF
 6      CONTINUE
  IF((IROW_INDEX(I) .eq. ROW) .AND.(ICOL_INDEX(I) .eq. COL)) THEN
    GO TO 10
  ELSE
    GO TO 7
  ENDIF
 7      CONTINUE
  GO TO 8
 8      CONTINUE
  GO TO 9
 9      CONTINUE
  GO TO 5
 10     CONTINUE
  IVALUES(INT(I)) = (IVALUES(I) + X)
  GO TO 11
 11     CONTINUE
  GO TO 12
 12     CONTINUE
  GO TO 1
 1      CONTINUE

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
 15     CONTINUE
  GO TO 16
 16     CONTINUE
  OpenAD_Symbol_24 = 0_w2f__i8
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_24
  integer_tape_pointer = integer_tape_pointer+1
  GO TO 17
 17     CONTINUE
  GO TO 18
 18     CONTINUE
  OpenAD_Symbol_25 = 1_w2f__i8
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_25
  integer_tape_pointer = integer_tape_pointer+1
  GO TO 19
 19     CONTINUE
  I = 1
  GO TO 31
 20     CONTINUE
  I = I + 1
 31     CONTINUE
  IF(I .LE. INNZ) THEN
    GO TO 21
  ELSE
    GO TO 28
  ENDIF
 21     CONTINUE
  IF((IROW_INDEX(I) .eq. ROW) .AND.(ICOL_INDEX(I) .eq. COL)) THEN
    GO TO 26
  ELSE
    GO TO 22
  ENDIF
 22     CONTINUE
  GO TO 23
 23     CONTINUE
  OpenAD_Symbol_28 = 4_w2f__i8
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_28
  integer_tape_pointer = integer_tape_pointer+1
  GO TO 24
 24     CONTINUE
  GO TO 25
 25     CONTINUE
  GO TO 20
 26     CONTINUE
  IVALUES(INT(I)) = (IVALUES(I) + X)
  GO TO 27
 27     CONTINUE
  OpenAD_Symbol_26 = 2_w2f__i8
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_26
  integer_tape_pointer = integer_tape_pointer+1
  GO TO 28
 28     CONTINUE
  GO TO 29
 29     CONTINUE
  OpenAD_Symbol_27 = 3_w2f__i8
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_27
  integer_tape_pointer = integer_tape_pointer+1
  GO TO 30
 30     CONTINUE
  GO TO 14
 14     CONTINUE

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_29 = integer_tape(integer_tape_pointer)
  DO WHILE(INT(OpenAD_Symbol_29) .ne. INT(0_w2f__i8))
    IF ( OpenAD_Symbol_29 .EQ. 1) GO TO 52
    IF ( OpenAD_Symbol_29 .EQ. 2) GO TO 53
    IF ( OpenAD_Symbol_29 .EQ. 3) GO TO 54
    IF ( OpenAD_Symbol_29 .EQ. 4) GO TO 55
 52       CONTINUE
    GO TO 49
 53       CONTINUE
    GO TO 49
 54       CONTINUE
    GO TO 49
 55       CONTINUE
    GO TO 49
 49       CONTINUE
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_29 = integer_tape(integer_tape_pointer)
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine ADDX_ELEM
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE ADDX_DIAGONAL(INNZ, IROW_INDEX, IROW_COMPRESSED, ICOL_INDEX, IVALUE&
     &S, X, DIAG)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_36
  INTEGER(w2f__i8) OpenAD_Symbol_37
  INTEGER(w2f__i8) OpenAD_Symbol_38
  INTEGER(w2f__i8) OpenAD_Symbol_39
  INTEGER(w2f__i8) OpenAD_Symbol_40
  INTEGER(w2f__i8) OpenAD_Symbol_41
  INTEGER(w2f__i8) OpenAD_Symbol_42
  INTEGER(w2f__i8) OpenAD_Symbol_43
  INTEGER(w2f__i8) OpenAD_Symbol_44
  INTEGER(w2f__i8) OpenAD_Symbol_45
  INTEGER(w2f__i8) OpenAD_Symbol_46
  INTEGER(w2f__i8) OpenAD_Symbol_47
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) INNZ
  INTEGER(w2f__i4) IROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) IROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) ICOL_INDEX(1 : 1400)
  REAL(w2f__8) IVALUES(1 : 1400)
  REAL(w2f__8) X
  INTEGER(w2f__i4) DIAG
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(INNZ,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  call cp_store_real_scalar(X,theArgFStack,theArgFStackoffset,theArgFStackSize)
  call cp_store_int_scalar(DIAG,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  call cp_store_int_vector(IROW_INDEX,size(IROW_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_int_vector(ICOL_INDEX,size(ICOL_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_p_real_vector(IVALUES,size(IVALUES),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(IVALUES,1),lbound(IVALUES,1),-1
  IVALUES(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(ICOL_INDEX,1),lbound(ICOL_INDEX,1),-1
  ICOL_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(IROW_INDEX,1),lbound(IROW_INDEX,1),-1
  IROW_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  DIAG = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  X = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  INNZ = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  DO I = 1, INNZ, 1
    IF(DIAG .eq.(ICOL_INDEX(I) - IROW_INDEX(I))) THEN
      IVALUES(INT(I)) = (IVALUES(I) + X)
    ENDIF
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  OpenAD_Symbol_39 = 0_w2f__i8
  DO I = 1, INNZ, 1
    IF(DIAG .eq.(ICOL_INDEX(I) - IROW_INDEX(I))) THEN
      IVALUES(INT(I)) = (IVALUES(I) + X)
      OpenAD_Symbol_40 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_40
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      OpenAD_Symbol_41 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_41
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_39 = (INT(OpenAD_Symbol_39) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_39
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_36 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_37 = 1
  DO WHILE(INT(OpenAD_Symbol_37) .LE. INT(OpenAD_Symbol_36))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_38 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_38 .ne. 0) THEN
    ENDIF
    OpenAD_Symbol_37 = INT(OpenAD_Symbol_37) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine ADDX_DIAGONAL
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE GETDIAG(ROW, COL, DIAG)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) ROW
  INTEGER(w2f__i4) COL
  INTEGER(w2f__i4) DIAG


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  DIAG = (COL - ROW)

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  DIAG = (COL - ROW)

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine GETDIAG
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE FIRSTELM(DIAG, ROW, COL)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_48
  INTEGER(w2f__i8) OpenAD_Symbol_49
  INTEGER(w2f__i8) OpenAD_Symbol_50
  INTEGER(w2f__i8) OpenAD_Symbol_51
  INTEGER(w2f__i8) OpenAD_Symbol_52
  INTEGER(w2f__i8) OpenAD_Symbol_53
  INTEGER(w2f__i8) OpenAD_Symbol_54
  INTEGER(w2f__i8) OpenAD_Symbol_55
  INTEGER(w2f__i8) OpenAD_Symbol_56
  INTEGER(w2f__i8) OpenAD_Symbol_57
  INTEGER(w2f__i8) OpenAD_Symbol_58
  INTEGER(w2f__i8) OpenAD_Symbol_59
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) DIAG
  INTEGER(w2f__i4) ROW
  INTEGER(w2f__i4) COL


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(DIAG,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  DIAG = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  IF(DIAG .LT. 0) THEN
    ROW = (1 - DIAG)
    COL = 1
  ELSE
    IF(DIAG .eq. 0) THEN
      ROW = 1
      COL = 1
    ELSE
      ROW = 1
      COL = (DIAG + 1)
    ENDIF
  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  IF(DIAG .LT. 0) THEN
    ROW = (1 - DIAG)
    COL = 1
    OpenAD_Symbol_52 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_52
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    IF(DIAG .eq. 0) THEN
      ROW = 1
      COL = 1
      OpenAD_Symbol_50 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_50
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      ROW = 1
      COL = (DIAG + 1)
      OpenAD_Symbol_51 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_51
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_53 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_53
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_48 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_48 .ne. 0) THEN
  ELSE
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_49 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_49 .ne. 0) THEN
    ENDIF
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine FIRSTELM
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE NOELEMS(DIAG, OROWS, OCOLS, N)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_60
  INTEGER(w2f__i8) OpenAD_Symbol_61
  INTEGER(w2f__i8) OpenAD_Symbol_62
  INTEGER(w2f__i8) OpenAD_Symbol_63
  INTEGER(w2f__i8) OpenAD_Symbol_64
  INTEGER(w2f__i8) OpenAD_Symbol_65
  INTEGER(w2f__i8) OpenAD_Symbol_66
  INTEGER(w2f__i8) OpenAD_Symbol_67
  INTEGER(w2f__i8) OpenAD_Symbol_68
  INTEGER(w2f__i8) OpenAD_Symbol_69
  INTEGER(w2f__i8) OpenAD_Symbol_70
  INTEGER(w2f__i8) OpenAD_Symbol_71
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) DIAG
  INTEGER(w2f__i4) OROWS
  INTEGER(w2f__i4) OCOLS
  INTEGER(w2f__i4) N
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) COL
  INTEGER(w2f__i4) ROW


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  CALL FIRSTELM(DIAG,ROW,COL)
  IF(DIAG .LT. 0) THEN
    N = (OROWS - ROW + 1)
  ELSE
    IF(DIAG .eq. 0) THEN
      N = MIN(OROWS, OCOLS)
    ELSE
      N = (OCOLS - COL + 1)
    ENDIF
  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  CALL FIRSTELM(DIAG,ROW,COL)
  IF(DIAG .LT. 0) THEN
    N = (OROWS - ROW + 1)
    OpenAD_Symbol_64 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_64
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    IF(DIAG .eq. 0) THEN
      N = MIN(OROWS, OCOLS)
      OpenAD_Symbol_62 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_62
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      N = (OCOLS - COL + 1)
      OpenAD_Symbol_63 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_63
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_65 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_65
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_60 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_60 .ne. 0) THEN
  ELSE
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_61 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_61 .ne. 0) THEN
    ENDIF
  ENDIF
  CALL FIRSTELM(DIAG,ROW,COL)

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine NOELEMS
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYRESHAPE_2_1(AMATRIX, BMATRIX)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_72
  INTEGER(w2f__i8) OpenAD_Symbol_73
  INTEGER(w2f__i8) OpenAD_Symbol_74
  INTEGER(w2f__i8) OpenAD_Symbol_75
  INTEGER(w2f__i8) OpenAD_Symbol_76
  INTEGER(w2f__i8) OpenAD_Symbol_77
  INTEGER(w2f__i8) OpenAD_Symbol_78
  INTEGER(w2f__i8) OpenAD_Symbol_79
  INTEGER(w2f__i8) OpenAD_Symbol_80
  INTEGER(w2f__i8) OpenAD_Symbol_81
  INTEGER(w2f__i8) OpenAD_Symbol_82
  INTEGER(w2f__i8) OpenAD_Symbol_83
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) AMATRIX(1 :, 1 :)
  REAL(w2f__8) BMATRIX(1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) K


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  do cp_loop_variable_2 = lbound(AMATRIX,2),ubound(AMATRIX,2)
  call cp_store_p_real_vector(AMATRIX(:,cp_loop_variable_2),size(AMATRIX(:,cp_lo&
     &op_variable_2)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_2 = ubound(AMATRIX,2),lbound(AMATRIX,2),-1
  do cp_loop_variable_1 = ubound(AMATRIX,1),lbound(AMATRIX,1),-1
  AMATRIX(cp_loop_variable_1,cp_loop_variable_2) = theArgFStack(theArgFStackoffs&
     &et)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  K = 0
  DO J = 1, SIZE(AMATRIX, 2), 1
    DO I = 1, SIZE(AMATRIX, 1), 1
      K = (K + 1)
      BMATRIX(INT(K)) = AMATRIX(I, J)
    END DO
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  K = 0
  OpenAD_Symbol_76 = 0_w2f__i8
  DO J = 1, SIZE(AMATRIX, 2), 1
    OpenAD_Symbol_77 = 0_w2f__i8
    DO I = 1, SIZE(AMATRIX, 1), 1
      K = (K + 1)
      BMATRIX(INT(K)) = AMATRIX(I, J)
      OpenAD_Symbol_77 = (INT(OpenAD_Symbol_77) + INT(1_w2f__i8))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_77
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_76 = (INT(OpenAD_Symbol_76) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_76
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_72 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_73 = 1
  DO WHILE(INT(OpenAD_Symbol_73) .LE. INT(OpenAD_Symbol_72))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_74 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_75 = 1
    DO WHILE(INT(OpenAD_Symbol_75) .LE. INT(OpenAD_Symbol_74))
      OpenAD_Symbol_75 = INT(OpenAD_Symbol_75) + 1
    END DO
    OpenAD_Symbol_73 = INT(OpenAD_Symbol_73) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYRESHAPE_2_1
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYRESHAPE_1_2(AMATRIX, BMATRIX)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_84
  INTEGER(w2f__i8) OpenAD_Symbol_85
  INTEGER(w2f__i8) OpenAD_Symbol_86
  INTEGER(w2f__i8) OpenAD_Symbol_87
  INTEGER(w2f__i8) OpenAD_Symbol_88
  INTEGER(w2f__i8) OpenAD_Symbol_89
  INTEGER(w2f__i8) OpenAD_Symbol_90
  INTEGER(w2f__i8) OpenAD_Symbol_91
  INTEGER(w2f__i8) OpenAD_Symbol_92
  INTEGER(w2f__i8) OpenAD_Symbol_93
  INTEGER(w2f__i8) OpenAD_Symbol_94
  INTEGER(w2f__i8) OpenAD_Symbol_95
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) AMATRIX(1 :)
  REAL(w2f__8) BMATRIX(1 :, 1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) K


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  K = 0
  DO J = 1, SIZE(BMATRIX, 2), 1
    DO I = 1, SIZE(BMATRIX, 1), 1
      K = (K + 1)
      BMATRIX(INT(I), INT(J)) = AMATRIX(K)
    END DO
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  K = 0
  OpenAD_Symbol_88 = 0_w2f__i8
  DO J = 1, SIZE(BMATRIX, 2), 1
    OpenAD_Symbol_89 = 0_w2f__i8
    DO I = 1, SIZE(BMATRIX, 1), 1
      K = (K + 1)
      BMATRIX(INT(I), INT(J)) = AMATRIX(K)
      OpenAD_Symbol_89 = (INT(OpenAD_Symbol_89) + INT(1_w2f__i8))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_89
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_88 = (INT(OpenAD_Symbol_88) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_88
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_84 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_85 = 1
  DO WHILE(INT(OpenAD_Symbol_85) .LE. INT(OpenAD_Symbol_84))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_86 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_87 = 1
    DO WHILE(INT(OpenAD_Symbol_87) .LE. INT(OpenAD_Symbol_86))
      OpenAD_Symbol_87 = INT(OpenAD_Symbol_87) + 1
    END DO
    OpenAD_Symbol_85 = INT(OpenAD_Symbol_85) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYRESHAPE_1_2
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYRESHAPE_3_1(AMATRIX, BMATRIX)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_100
  INTEGER(w2f__i8) OpenAD_Symbol_101
  INTEGER(w2f__i8) OpenAD_Symbol_102
  INTEGER(w2f__i8) OpenAD_Symbol_103
  INTEGER(w2f__i8) OpenAD_Symbol_104
  INTEGER(w2f__i8) OpenAD_Symbol_105
  INTEGER(w2f__i8) OpenAD_Symbol_106
  INTEGER(w2f__i8) OpenAD_Symbol_107
  INTEGER(w2f__i8) OpenAD_Symbol_108
  INTEGER(w2f__i8) OpenAD_Symbol_109
  INTEGER(w2f__i8) OpenAD_Symbol_110
  INTEGER(w2f__i8) OpenAD_Symbol_111
  INTEGER(w2f__i8) OpenAD_Symbol_112
  INTEGER(w2f__i8) OpenAD_Symbol_113
  INTEGER(w2f__i8) OpenAD_Symbol_96
  INTEGER(w2f__i8) OpenAD_Symbol_97
  INTEGER(w2f__i8) OpenAD_Symbol_98
  INTEGER(w2f__i8) OpenAD_Symbol_99
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) AMATRIX(1 :, 1 :, 1 :)
  REAL(w2f__8) BMATRIX(1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) K
  INTEGER(w2f__i4) L


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  do cp_loop_variable_3 = lbound(AMATRIX,3),ubound(AMATRIX,3)
  do cp_loop_variable_2 = lbound(AMATRIX,2),ubound(AMATRIX,2)
  call cp_store_p_real_vector(AMATRIX(:,cp_loop_variable_2,cp_loop_variable_3),s&
     &ize(AMATRIX(:,cp_loop_variable_2,cp_loop_variable_3)),theArgFStack,theArgF&
     &Stackoffset,theArgFStackSize)

  end do
  end do
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_3 = ubound(AMATRIX,3),lbound(AMATRIX,3),-1
  do cp_loop_variable_2 = ubound(AMATRIX,2),lbound(AMATRIX,2),-1
  do cp_loop_variable_1 = ubound(AMATRIX,1),lbound(AMATRIX,1),-1
  AMATRIX(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3) = theArgFSta&
     &ck(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  L = 0
  DO K = 1, SIZE(AMATRIX, 3), 1
    DO J = 1, SIZE(AMATRIX, 2), 1
      DO I = 1, SIZE(AMATRIX, 1), 1
        L = (L + 1)
        BMATRIX(INT(L)) = AMATRIX(I, J, K)
      END DO
    END DO
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  L = 0
  OpenAD_Symbol_102 = 0_w2f__i8
  DO K = 1, SIZE(AMATRIX, 3), 1
    OpenAD_Symbol_103 = 0_w2f__i8
    DO J = 1, SIZE(AMATRIX, 2), 1
      OpenAD_Symbol_104 = 0_w2f__i8
      DO I = 1, SIZE(AMATRIX, 1), 1
        L = (L + 1)
        BMATRIX(INT(L)) = AMATRIX(I, J, K)
        OpenAD_Symbol_104 = (INT(OpenAD_Symbol_104) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_104
      integer_tape_pointer = integer_tape_pointer+1
      OpenAD_Symbol_103 = (INT(OpenAD_Symbol_103) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_103
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_102 = (INT(OpenAD_Symbol_102) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_102
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_96 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_97 = 1
  DO WHILE(INT(OpenAD_Symbol_97) .LE. INT(OpenAD_Symbol_96))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_98 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_99 = 1
    DO WHILE(INT(OpenAD_Symbol_99) .LE. INT(OpenAD_Symbol_98))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_100 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_101 = 1
      DO WHILE(INT(OpenAD_Symbol_101) .LE. INT(OpenAD_Symbol_100) )
        OpenAD_Symbol_101 = INT(OpenAD_Symbol_101) + 1
      END DO
      OpenAD_Symbol_99 = INT(OpenAD_Symbol_99) + 1
    END DO
    OpenAD_Symbol_97 = INT(OpenAD_Symbol_97) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYRESHAPE_3_1
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYRESHAPE_1_3(AMATRIX, BMATRIX)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_114
  INTEGER(w2f__i8) OpenAD_Symbol_115
  INTEGER(w2f__i8) OpenAD_Symbol_116
  INTEGER(w2f__i8) OpenAD_Symbol_117
  INTEGER(w2f__i8) OpenAD_Symbol_118
  INTEGER(w2f__i8) OpenAD_Symbol_119
  INTEGER(w2f__i8) OpenAD_Symbol_120
  INTEGER(w2f__i8) OpenAD_Symbol_121
  INTEGER(w2f__i8) OpenAD_Symbol_122
  INTEGER(w2f__i8) OpenAD_Symbol_123
  INTEGER(w2f__i8) OpenAD_Symbol_124
  INTEGER(w2f__i8) OpenAD_Symbol_125
  INTEGER(w2f__i8) OpenAD_Symbol_126
  INTEGER(w2f__i8) OpenAD_Symbol_127
  INTEGER(w2f__i8) OpenAD_Symbol_128
  INTEGER(w2f__i8) OpenAD_Symbol_129
  INTEGER(w2f__i8) OpenAD_Symbol_130
  INTEGER(w2f__i8) OpenAD_Symbol_131
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) AMATRIX(1 :)
  REAL(w2f__8) BMATRIX(1 :, 1 :, 1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) K
  INTEGER(w2f__i4) L


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  do cp_loop_variable_3 = lbound(BMATRIX,3),ubound(BMATRIX,3)
  do cp_loop_variable_2 = lbound(BMATRIX,2),ubound(BMATRIX,2)
  call cp_store_p_real_vector(BMATRIX(:,cp_loop_variable_2,cp_loop_variable_3),s&
     &ize(BMATRIX(:,cp_loop_variable_2,cp_loop_variable_3)),theArgFStack,theArgF&
     &Stackoffset,theArgFStackSize)

  end do
  end do
  call cp_store_p_real_vector(AMATRIX,size(AMATRIX),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(AMATRIX,1),lbound(AMATRIX,1),-1
  AMATRIX(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_3 = ubound(BMATRIX,3),lbound(BMATRIX,3),-1
  do cp_loop_variable_2 = ubound(BMATRIX,2),lbound(BMATRIX,2),-1
  do cp_loop_variable_1 = ubound(BMATRIX,1),lbound(BMATRIX,1),-1
  BMATRIX(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3) = theArgFSta&
     &ck(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  L = 0
  DO K = 1, SIZE(BMATRIX, 3), 1
    DO J = 1, SIZE(BMATRIX, 2), 1
      DO I = 1, SIZE(BMATRIX, 1), 1
        L = (L + 1)
        BMATRIX(INT(I), INT(J), INT(K)) = AMATRIX(L)
      END DO
    END DO
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  L = 0
  OpenAD_Symbol_120 = 0_w2f__i8
  DO K = 1, SIZE(BMATRIX, 3), 1
    OpenAD_Symbol_121 = 0_w2f__i8
    DO J = 1, SIZE(BMATRIX, 2), 1
      OpenAD_Symbol_122 = 0_w2f__i8
      DO I = 1, SIZE(BMATRIX, 1), 1
        L = (L + 1)
        BMATRIX(INT(I), INT(J), INT(K)) = AMATRIX(L)
        OpenAD_Symbol_122 = (INT(OpenAD_Symbol_122) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_122
      integer_tape_pointer = integer_tape_pointer+1
      OpenAD_Symbol_121 = (INT(OpenAD_Symbol_121) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_121
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_120 = (INT(OpenAD_Symbol_120) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_120
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_114 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_115 = 1
  DO WHILE(INT(OpenAD_Symbol_115) .LE. INT(OpenAD_Symbol_114))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_116 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_117 = 1
    DO WHILE(INT(OpenAD_Symbol_117) .LE. INT(OpenAD_Symbol_116))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_118 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_119 = 1
      DO WHILE(INT(OpenAD_Symbol_119) .LE. INT(OpenAD_Symbol_118) )
        OpenAD_Symbol_119 = INT(OpenAD_Symbol_119) + 1
      END DO
      OpenAD_Symbol_117 = INT(OpenAD_Symbol_117) + 1
    END DO
    OpenAD_Symbol_115 = INT(OpenAD_Symbol_115) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYRESHAPE_1_3
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYRESHAPE_4_1(AMATRIX, BMATRIX)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_132
  INTEGER(w2f__i8) OpenAD_Symbol_133
  INTEGER(w2f__i8) OpenAD_Symbol_134
  INTEGER(w2f__i8) OpenAD_Symbol_135
  INTEGER(w2f__i8) OpenAD_Symbol_136
  INTEGER(w2f__i8) OpenAD_Symbol_137
  INTEGER(w2f__i8) OpenAD_Symbol_138
  INTEGER(w2f__i8) OpenAD_Symbol_139
  INTEGER(w2f__i8) OpenAD_Symbol_140
  INTEGER(w2f__i8) OpenAD_Symbol_141
  INTEGER(w2f__i8) OpenAD_Symbol_142
  INTEGER(w2f__i8) OpenAD_Symbol_143
  INTEGER(w2f__i8) OpenAD_Symbol_144
  INTEGER(w2f__i8) OpenAD_Symbol_145
  INTEGER(w2f__i8) OpenAD_Symbol_146
  INTEGER(w2f__i8) OpenAD_Symbol_147
  INTEGER(w2f__i8) OpenAD_Symbol_148
  INTEGER(w2f__i8) OpenAD_Symbol_149
  INTEGER(w2f__i8) OpenAD_Symbol_150
  INTEGER(w2f__i8) OpenAD_Symbol_151
  INTEGER(w2f__i8) OpenAD_Symbol_152
  INTEGER(w2f__i8) OpenAD_Symbol_153
  INTEGER(w2f__i8) OpenAD_Symbol_154
  INTEGER(w2f__i8) OpenAD_Symbol_155
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) AMATRIX(1 :, 1 :, 1 :, 1 :)
  REAL(w2f__8) BMATRIX(1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) K
  INTEGER(w2f__i4) L
  INTEGER(w2f__i4) M


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  M = 0
  DO L = 1, SIZE(AMATRIX, 4), 1
    DO K = 1, SIZE(AMATRIX, 3), 1
      DO J = 1, SIZE(AMATRIX, 2), 1
        DO I = 1, SIZE(AMATRIX, 1), 1
          M = (M + 1)
          BMATRIX(INT(M)) = AMATRIX(I, J, K, L)
        END DO
      END DO
    END DO
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  M = 0
  OpenAD_Symbol_140 = 0_w2f__i8
  DO L = 1, SIZE(AMATRIX, 4), 1
    OpenAD_Symbol_141 = 0_w2f__i8
    DO K = 1, SIZE(AMATRIX, 3), 1
      OpenAD_Symbol_142 = 0_w2f__i8
      DO J = 1, SIZE(AMATRIX, 2), 1
        OpenAD_Symbol_143 = 0_w2f__i8
        DO I = 1, SIZE(AMATRIX, 1), 1
          M = (M + 1)
          BMATRIX(INT(M)) = AMATRIX(I, J, K, L)
          OpenAD_Symbol_143 = (INT(OpenAD_Symbol_143) + INT( 1_w2f__i8))
        END DO
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_143
        integer_tape_pointer = integer_tape_pointer+1
        OpenAD_Symbol_142 = (INT(OpenAD_Symbol_142) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_142
      integer_tape_pointer = integer_tape_pointer+1
      OpenAD_Symbol_141 = (INT(OpenAD_Symbol_141) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_141
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_140 = (INT(OpenAD_Symbol_140) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_140
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_132 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_133 = 1
  DO WHILE(INT(OpenAD_Symbol_133) .LE. INT(OpenAD_Symbol_132))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_134 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_135 = 1
    DO WHILE(INT(OpenAD_Symbol_135) .LE. INT(OpenAD_Symbol_134))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_136 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_137 = 1
      DO WHILE(INT(OpenAD_Symbol_137) .LE. INT(OpenAD_Symbol_136) )
        integer_tape_pointer = integer_tape_pointer-1
        OpenAD_Symbol_138 = integer_tape(integer_tape_pointer)
        OpenAD_Symbol_139 = 1
        DO WHILE(INT(OpenAD_Symbol_139) .LE. INT( OpenAD_Symbol_138))
          OpenAD_Symbol_139 = INT(OpenAD_Symbol_139) + 1
        END DO
        OpenAD_Symbol_137 = INT(OpenAD_Symbol_137) + 1
      END DO
      OpenAD_Symbol_135 = INT(OpenAD_Symbol_135) + 1
    END DO
    OpenAD_Symbol_133 = INT(OpenAD_Symbol_133) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYRESHAPE_4_1
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYRESHAPE_1_4(AMATRIX, BMATRIX)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_156
  INTEGER(w2f__i8) OpenAD_Symbol_157
  INTEGER(w2f__i8) OpenAD_Symbol_158
  INTEGER(w2f__i8) OpenAD_Symbol_159
  INTEGER(w2f__i8) OpenAD_Symbol_160
  INTEGER(w2f__i8) OpenAD_Symbol_161
  INTEGER(w2f__i8) OpenAD_Symbol_162
  INTEGER(w2f__i8) OpenAD_Symbol_163
  INTEGER(w2f__i8) OpenAD_Symbol_164
  INTEGER(w2f__i8) OpenAD_Symbol_165
  INTEGER(w2f__i8) OpenAD_Symbol_166
  INTEGER(w2f__i8) OpenAD_Symbol_167
  INTEGER(w2f__i8) OpenAD_Symbol_168
  INTEGER(w2f__i8) OpenAD_Symbol_169
  INTEGER(w2f__i8) OpenAD_Symbol_170
  INTEGER(w2f__i8) OpenAD_Symbol_171
  INTEGER(w2f__i8) OpenAD_Symbol_172
  INTEGER(w2f__i8) OpenAD_Symbol_173
  INTEGER(w2f__i8) OpenAD_Symbol_174
  INTEGER(w2f__i8) OpenAD_Symbol_175
  INTEGER(w2f__i8) OpenAD_Symbol_176
  INTEGER(w2f__i8) OpenAD_Symbol_177
  INTEGER(w2f__i8) OpenAD_Symbol_178
  INTEGER(w2f__i8) OpenAD_Symbol_179
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) AMATRIX(1 :)
  REAL(w2f__8) BMATRIX(1 :, 1 :, 1 :, 1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) K
  INTEGER(w2f__i4) L
  INTEGER(w2f__i4) M


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  do cp_loop_variable_4 = lbound(BMATRIX,4),ubound(BMATRIX,4)
  do cp_loop_variable_3 = lbound(BMATRIX,3),ubound(BMATRIX,3)
  do cp_loop_variable_2 = lbound(BMATRIX,2),ubound(BMATRIX,2)
  call cp_store_p_real_vector(BMATRIX(:,cp_loop_variable_2,cp_loop_variable_3,cp&
     &_loop_variable_4),size(BMATRIX(:,cp_loop_variable_2,cp_loop_variable_3,cp_&
     &loop_variable_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
  call cp_store_p_real_vector(AMATRIX,size(AMATRIX),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(AMATRIX,1),lbound(AMATRIX,1),-1
  AMATRIX(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_4 = ubound(BMATRIX,4),lbound(BMATRIX,4),-1
  do cp_loop_variable_3 = ubound(BMATRIX,3),lbound(BMATRIX,3),-1
  do cp_loop_variable_2 = ubound(BMATRIX,2),lbound(BMATRIX,2),-1
  do cp_loop_variable_1 = ubound(BMATRIX,1),lbound(BMATRIX,1),-1
  BMATRIX(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_varia&
     &ble_4) = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  M = 0
  DO L = 1, SIZE(BMATRIX, 4), 1
    DO K = 1, SIZE(BMATRIX, 3), 1
      DO J = 1, SIZE(BMATRIX, 2), 1
        DO I = 1, SIZE(BMATRIX, 1), 1
          M = (M + 1)
          BMATRIX(INT(I), INT(J), INT(K), INT(L)) = AMATRIX(M)
        END DO
      END DO
    END DO
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  M = 0
  OpenAD_Symbol_164 = 0_w2f__i8
  DO L = 1, SIZE(BMATRIX, 4), 1
    OpenAD_Symbol_165 = 0_w2f__i8
    DO K = 1, SIZE(BMATRIX, 3), 1
      OpenAD_Symbol_166 = 0_w2f__i8
      DO J = 1, SIZE(BMATRIX, 2), 1
        OpenAD_Symbol_167 = 0_w2f__i8
        DO I = 1, SIZE(BMATRIX, 1), 1
          M = (M + 1)
          BMATRIX(INT(I), INT(J), INT(K), INT(L)) = AMATRIX(M)
          OpenAD_Symbol_167 = (INT(OpenAD_Symbol_167) + INT( 1_w2f__i8))
        END DO
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_167
        integer_tape_pointer = integer_tape_pointer+1
        OpenAD_Symbol_166 = (INT(OpenAD_Symbol_166) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_166
      integer_tape_pointer = integer_tape_pointer+1
      OpenAD_Symbol_165 = (INT(OpenAD_Symbol_165) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_165
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_164 = (INT(OpenAD_Symbol_164) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_164
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_156 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_157 = 1
  DO WHILE(INT(OpenAD_Symbol_157) .LE. INT(OpenAD_Symbol_156))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_158 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_159 = 1
    DO WHILE(INT(OpenAD_Symbol_159) .LE. INT(OpenAD_Symbol_158))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_160 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_161 = 1
      DO WHILE(INT(OpenAD_Symbol_161) .LE. INT(OpenAD_Symbol_160) )
        integer_tape_pointer = integer_tape_pointer-1
        OpenAD_Symbol_162 = integer_tape(integer_tape_pointer)
        OpenAD_Symbol_163 = 1
        DO WHILE(INT(OpenAD_Symbol_163) .LE. INT( OpenAD_Symbol_162))
          OpenAD_Symbol_163 = INT(OpenAD_Symbol_163) + 1
        END DO
        OpenAD_Symbol_161 = INT(OpenAD_Symbol_161) + 1
      END DO
      OpenAD_Symbol_159 = INT(OpenAD_Symbol_159) + 1
    END DO
    OpenAD_Symbol_157 = INT(OpenAD_Symbol_157) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYRESHAPE_1_4
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SPMAT_MULTIPLY_DIAGONAL(ANNZ, AROW_INDEX, AROW_COMPRESSED, ACOL_IND&
     &EX, AVALUES, DMATRIX, RNNZ, RROW_INDEX , RROW_COMPRESSED, RCOL_INDEX, RVAL&
     &UES, ORDER)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_180
  INTEGER(w2f__i8) OpenAD_Symbol_181
  INTEGER(w2f__i8) OpenAD_Symbol_182
  INTEGER(w2f__i8) OpenAD_Symbol_183
  INTEGER(w2f__i8) OpenAD_Symbol_184
  INTEGER(w2f__i8) OpenAD_Symbol_185
  INTEGER(w2f__i8) OpenAD_Symbol_186
  INTEGER(w2f__i8) OpenAD_Symbol_187
  INTEGER(w2f__i8) OpenAD_Symbol_188
  INTEGER(w2f__i8) OpenAD_Symbol_189
  INTEGER(w2f__i8) OpenAD_Symbol_190
  INTEGER(w2f__i8) OpenAD_Symbol_191
  INTEGER(w2f__i8) OpenAD_Symbol_192
  INTEGER(w2f__i8) OpenAD_Symbol_193
  INTEGER(w2f__i8) OpenAD_Symbol_194
  INTEGER(w2f__i8) OpenAD_Symbol_195
  INTEGER(w2f__i8) OpenAD_Symbol_196
  INTEGER(w2f__i8) OpenAD_Symbol_197
  INTEGER(w2f__i8) OpenAD_Symbol_198
  INTEGER(w2f__i8) OpenAD_Symbol_199
  INTEGER(w2f__i8) OpenAD_Symbol_200
  INTEGER(w2f__i8) OpenAD_Symbol_201
  INTEGER(w2f__i8) OpenAD_Symbol_202
  INTEGER(w2f__i8) OpenAD_Symbol_203
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) ANNZ
  INTEGER(w2f__i4) AROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) AROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) ACOL_INDEX(1 : 1400)
  REAL(w2f__8) AVALUES(1 : 1400)
  REAL(w2f__8) DMATRIX(1 : 200)
  INTEGER(w2f__i4) RNNZ
  INTEGER(w2f__i4) RROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) RROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) RCOL_INDEX(1 : 1400)
  REAL(w2f__8) RVALUES(1 : 1400)
  CHARACTER(3) ORDER
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(ANNZ,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  call cp_store_int_scalar(RNNZ,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  call cp_store_int_vector(AROW_INDEX,size(AROW_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_int_vector(AROW_COMPRESSED,size(AROW_COMPRESSED),theArgIStack,th&
     &eArgIStackoffset,theArgIStackSize)

  call cp_store_int_vector(ACOL_INDEX,size(ACOL_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_p_real_vector(AVALUES,size(AVALUES),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

  call cp_store_p_real_vector(DMATRIX,size(DMATRIX),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

  call cp_store_int_vector(RROW_INDEX,size(RROW_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_int_vector(RROW_COMPRESSED,size(RROW_COMPRESSED),theArgIStack,th&
     &eArgIStackoffset,theArgIStackSize)

  call cp_store_int_vector(RCOL_INDEX,size(RCOL_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_p_real_vector(RVALUES,size(RVALUES),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(RVALUES,1),lbound(RVALUES,1),-1
  RVALUES(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(RCOL_INDEX,1),lbound(RCOL_INDEX,1),-1
  RCOL_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(RROW_COMPRESSED,1),lbound(RROW_COMPRESSED,1),-1
  RROW_COMPRESSED(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(RROW_INDEX,1),lbound(RROW_INDEX,1),-1
  RROW_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(DMATRIX,1),lbound(DMATRIX,1),-1
  DMATRIX(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AVALUES,1),lbound(AVALUES,1),-1
  AVALUES(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(ACOL_INDEX,1),lbound(ACOL_INDEX,1),-1
  ACOL_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_COMPRESSED,1),lbound(AROW_COMPRESSED,1),-1
  AROW_COMPRESSED(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_INDEX,1),lbound(AROW_INDEX,1),-1
  AROW_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  RNNZ = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  ANNZ = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  RNNZ = ANNZ
  RROW_COMPRESSED(1 : 201_w2f__i8) = AROW_COMPRESSED(1 : 201_w2f__i8)
  IF(ORDER .EQ. 'PRE') THEN
    DO I = 1, ANNZ, 1
      RROW_INDEX(I) = AROW_INDEX(I)
      RCOL_INDEX(I) = ACOL_INDEX(I)
      RVALUES(INT(I)) = (AVALUES(I) * DMATRIX(ACOL_INDEX(I)))
    END DO
  ELSE
    IF(ORDER .EQ. 'POS') THEN
      DO I = 1, ANNZ, 1
        RROW_INDEX(I) = AROW_INDEX(I)
        RCOL_INDEX(I) = ACOL_INDEX(I)
        RVALUES(INT(I)) = (AVALUES(I) * DMATRIX(AROW_INDEX(I)))
      END DO
    ENDIF
  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  RNNZ = ANNZ
  RROW_COMPRESSED(1 : 201_w2f__i8) = AROW_COMPRESSED(1 : 201_w2f__i8)
  IF(ORDER .EQ. 'PRE') THEN
    OpenAD_Symbol_186 = 0_w2f__i8
    DO I = 1, ANNZ, 1
      RROW_INDEX(I) = AROW_INDEX(I)
      RCOL_INDEX(I) = ACOL_INDEX(I)
      RVALUES(INT(I)) = (AVALUES(I) * DMATRIX(ACOL_INDEX(I)))
      OpenAD_Symbol_186 = (INT(OpenAD_Symbol_186) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_186
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_190 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_190
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    IF(ORDER .EQ. 'POS') THEN
      OpenAD_Symbol_187 = 0_w2f__i8
      DO I = 1, ANNZ, 1
        RROW_INDEX(I) = AROW_INDEX(I)
        RCOL_INDEX(I) = ACOL_INDEX(I)
        RVALUES(INT(I)) = (AVALUES(I) * DMATRIX(AROW_INDEX(I)))
        OpenAD_Symbol_187 = (INT(OpenAD_Symbol_187) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_187
      integer_tape_pointer = integer_tape_pointer+1
      OpenAD_Symbol_189 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_189
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      OpenAD_Symbol_188 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_188
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_191 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_191
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_180 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_180 .ne. 0) THEN
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_184 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_185 = 1
    DO WHILE(INT(OpenAD_Symbol_185) .LE. INT(OpenAD_Symbol_184))
      OpenAD_Symbol_185 = INT(OpenAD_Symbol_185) + 1
    END DO
  ELSE
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_181 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_181 .ne. 0) THEN
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_182 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_183 = 1
      DO WHILE(INT(OpenAD_Symbol_183) .LE. INT(OpenAD_Symbol_182) )
        OpenAD_Symbol_183 = INT(OpenAD_Symbol_183) + 1
      END DO
    ENDIF
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SPMAT_MULTIPLY_DIAGONAL
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SPMAT_MULTIPLY_VECTOR(ANNZ, AROW_INDEX, AROW_COMPRESSED, ACOL_INDEX&
     &, AVALUES, BVECTOR, CVECTOR, ORDER)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_204
  INTEGER(w2f__i8) OpenAD_Symbol_205
  INTEGER(w2f__i8) OpenAD_Symbol_206
  INTEGER(w2f__i8) OpenAD_Symbol_207
  INTEGER(w2f__i8) OpenAD_Symbol_208
  INTEGER(w2f__i8) OpenAD_Symbol_209
  INTEGER(w2f__i8) OpenAD_Symbol_210
  INTEGER(w2f__i8) OpenAD_Symbol_211
  INTEGER(w2f__i8) OpenAD_Symbol_212
  INTEGER(w2f__i8) OpenAD_Symbol_213
  INTEGER(w2f__i8) OpenAD_Symbol_214
  INTEGER(w2f__i8) OpenAD_Symbol_215
  INTEGER(w2f__i8) OpenAD_Symbol_216
  INTEGER(w2f__i8) OpenAD_Symbol_217
  INTEGER(w2f__i8) OpenAD_Symbol_218
  INTEGER(w2f__i8) OpenAD_Symbol_219
  INTEGER(w2f__i8) OpenAD_Symbol_220
  INTEGER(w2f__i8) OpenAD_Symbol_221
  INTEGER(w2f__i8) OpenAD_Symbol_222
  INTEGER(w2f__i8) OpenAD_Symbol_223
  INTEGER(w2f__i8) OpenAD_Symbol_224
  INTEGER(w2f__i8) OpenAD_Symbol_225
  INTEGER(w2f__i8) OpenAD_Symbol_226
  INTEGER(w2f__i8) OpenAD_Symbol_227
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) ANNZ
  INTEGER(w2f__i4) AROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) AROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) ACOL_INDEX(1 : 1400)
  REAL(w2f__8) AVALUES(1 : 1400)
  REAL(w2f__8) BVECTOR(1 : 200)
  REAL(w2f__8) CVECTOR(1 : 200)
  CHARACTER(3) ORDER
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(ANNZ,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  call cp_store_int_vector(AROW_INDEX,size(AROW_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_int_vector(ACOL_INDEX,size(ACOL_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_p_real_vector(AVALUES,size(AVALUES),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

  call cp_store_p_real_vector(BVECTOR,size(BVECTOR),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

  call cp_store_p_real_vector(CVECTOR,size(CVECTOR),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(CVECTOR,1),lbound(CVECTOR,1),-1
  CVECTOR(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(BVECTOR,1),lbound(BVECTOR,1),-1
  BVECTOR(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AVALUES,1),lbound(AVALUES,1),-1
  AVALUES(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(ACOL_INDEX,1),lbound(ACOL_INDEX,1),-1
  ACOL_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_INDEX,1),lbound(AROW_INDEX,1),-1
  AROW_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  ANNZ = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  CVECTOR(1 : 200) = 0.0D00
  IF(ORDER .EQ. 'PRE') THEN
    DO I = 1, ANNZ, 1
      CVECTOR(AROW_INDEX(INT(I))) = (CVECTOR(AROW_INDEX(I)) + AVALUES(I) * BVECT&
     &OR(ACOL_INDEX(I)))

    END DO
  ELSE
    IF(ORDER .EQ. 'POS') THEN
      DO I = 1, ANNZ, 1
        CVECTOR(ACOL_INDEX(INT(I))) = (CVECTOR(ACOL_INDEX(I)) + AVALUES(I) * BVE&
     &CTOR(AROW_INDEX(I)))

      END DO
    ENDIF
  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  CVECTOR(1 : 200) = 0.0D00
  IF(ORDER .EQ. 'PRE') THEN
    OpenAD_Symbol_210 = 0_w2f__i8
    DO I = 1, ANNZ, 1
      CVECTOR(AROW_INDEX(INT(I))) = (CVECTOR(AROW_INDEX(I)) + AVALUES(I) * BVECT&
     &OR(ACOL_INDEX(I)))

      OpenAD_Symbol_210 = (INT(OpenAD_Symbol_210) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_210
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_214 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_214
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    IF(ORDER .EQ. 'POS') THEN
      OpenAD_Symbol_211 = 0_w2f__i8
      DO I = 1, ANNZ, 1
        CVECTOR(ACOL_INDEX(INT(I))) = (CVECTOR(ACOL_INDEX(I)) + AVALUES(I) * BVE&
     &CTOR(AROW_INDEX(I)))

        OpenAD_Symbol_211 = (INT(OpenAD_Symbol_211) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_211
      integer_tape_pointer = integer_tape_pointer+1
      OpenAD_Symbol_213 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_213
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      OpenAD_Symbol_212 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_212
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_215 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_215
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_204 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_204 .ne. 0) THEN
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_208 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_209 = 1
    DO WHILE(INT(OpenAD_Symbol_209) .LE. INT(OpenAD_Symbol_208))
      OpenAD_Symbol_209 = INT(OpenAD_Symbol_209) + 1
    END DO
  ELSE
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_205 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_205 .ne. 0) THEN
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_206 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_207 = 1
      DO WHILE(INT(OpenAD_Symbol_207) .LE. INT(OpenAD_Symbol_206) )
        OpenAD_Symbol_207 = INT(OpenAD_Symbol_207) + 1
      END DO
    ENDIF
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SPMAT_MULTIPLY_VECTOR
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SCALAR_MULTIPLY_SPMAT(ANNZ, AROW_INDEX, AROW_COMPRESSED, ACOL_INDEX&
     &, AVALUES, SCALAR, RNNZ, RROW_INDEX, RROW_COMPRESSED, RCOL_INDEX, RVALUES)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_228
  INTEGER(w2f__i8) OpenAD_Symbol_229
  INTEGER(w2f__i8) OpenAD_Symbol_230
  INTEGER(w2f__i8) OpenAD_Symbol_231
  INTEGER(w2f__i8) OpenAD_Symbol_232
  INTEGER(w2f__i8) OpenAD_Symbol_233
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) ANNZ
  INTEGER(w2f__i4) AROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) AROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) ACOL_INDEX(1 : 1400)
  REAL(w2f__8) AVALUES(1 : 1400)
  REAL(w2f__8) SCALAR
  INTEGER(w2f__i4) RNNZ
  INTEGER(w2f__i4) RROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) RROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) RCOL_INDEX(1 : 1400)
  REAL(w2f__8) RVALUES(1 : 1400)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  RNNZ = ANNZ
  RROW_COMPRESSED(1 : 201_w2f__i8) = AROW_COMPRESSED(1 : 201_w2f__i8)
  DO I = 1, ANNZ, 1
    RROW_INDEX(I) = AROW_INDEX(I)
    RCOL_INDEX(I) = ACOL_INDEX(I)
    RVALUES(INT(I)) = (AVALUES(I) * SCALAR)
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  RNNZ = ANNZ
  RROW_COMPRESSED(1 : 201_w2f__i8) = AROW_COMPRESSED(1 : 201_w2f__i8)
  OpenAD_Symbol_230 = 0_w2f__i8
  DO I = 1, ANNZ, 1
    RROW_INDEX(I) = AROW_INDEX(I)
    RCOL_INDEX(I) = ACOL_INDEX(I)
    RVALUES(INT(I)) = (AVALUES(I) * SCALAR)
    OpenAD_Symbol_230 = (INT(OpenAD_Symbol_230) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_230
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_228 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_229 = 1
  DO WHILE(INT(OpenAD_Symbol_229) .LE. INT(OpenAD_Symbol_228))
    OpenAD_Symbol_229 = INT(OpenAD_Symbol_229) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SCALAR_MULTIPLY_SPMAT
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYMIN_0_0_DOUBLE(SCALARIN1, SCALARIN2, SCALAROUT)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_234
  INTEGER(w2f__i8) OpenAD_Symbol_235
  INTEGER(w2f__i8) OpenAD_Symbol_236
  INTEGER(w2f__i8) OpenAD_Symbol_237
  INTEGER(w2f__i8) OpenAD_Symbol_238
  INTEGER(w2f__i8) OpenAD_Symbol_239
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) SCALARIN1
  REAL(w2f__8) SCALARIN2
  REAL(w2f__8) SCALAROUT


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  IF(SCALARIN1 .LE. SCALARIN2) THEN
    SCALAROUT = SCALARIN1
  ELSE
    SCALAROUT = SCALARIN2
  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  IF(SCALARIN1 .LE. SCALARIN2) THEN
    SCALAROUT = SCALARIN1
    OpenAD_Symbol_235 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_235
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    SCALAROUT = SCALARIN2
    OpenAD_Symbol_236 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_236
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_234 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_234 .ne. 0) THEN
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYMIN_0_0_DOUBLE
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYMIN_1_0_DOUBLE(VECTORIN, SCALARIN, VECTOROUT)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_240
  INTEGER(w2f__i8) OpenAD_Symbol_241
  INTEGER(w2f__i8) OpenAD_Symbol_242
  INTEGER(w2f__i8) OpenAD_Symbol_243
  INTEGER(w2f__i8) OpenAD_Symbol_244
  INTEGER(w2f__i8) OpenAD_Symbol_245
  INTEGER(w2f__i8) OpenAD_Symbol_246
  INTEGER(w2f__i8) OpenAD_Symbol_247
  INTEGER(w2f__i8) OpenAD_Symbol_248
  INTEGER(w2f__i8) OpenAD_Symbol_249
  INTEGER(w2f__i8) OpenAD_Symbol_250
  INTEGER(w2f__i8) OpenAD_Symbol_251
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) VECTORIN(1 :)
  REAL(w2f__8) SCALARIN
  REAL(w2f__8) VECTOROUT(1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(VECTORIN,size(VECTORIN),theArgFStack,theArgFStacko&
     &ffset,theArgFStackSize)

  call cp_store_real_scalar(SCALARIN,theArgFStack,theArgFStackoffset,theArgFStac&
     &kSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  SCALARIN = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  do cp_loop_variable_1 = ubound(VECTORIN,1),lbound(VECTORIN,1),-1
  VECTORIN(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  DO I = 1, SIZE(VECTORIN, 1), 1
    IF(VECTORIN(I) .GE. SCALARIN) THEN
      VECTOROUT(INT(I)) = SCALARIN
    ELSE
      VECTOROUT(INT(I)) = VECTORIN(I)
    ENDIF
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  OpenAD_Symbol_243 = 0_w2f__i8
  DO I = 1, SIZE(VECTORIN, 1), 1
    IF(VECTORIN(I) .GE. SCALARIN) THEN
      VECTOROUT(INT(I)) = SCALARIN
      OpenAD_Symbol_244 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_244
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      VECTOROUT(INT(I)) = VECTORIN(I)
      OpenAD_Symbol_245 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_245
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_243 = (INT(OpenAD_Symbol_243) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_243
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_240 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_241 = 1
  DO WHILE(INT(OpenAD_Symbol_241) .LE. INT(OpenAD_Symbol_240))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_242 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_242 .ne. 0) THEN
    ENDIF
    OpenAD_Symbol_241 = INT(OpenAD_Symbol_241) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYMIN_1_0_DOUBLE
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYMIN_1_1_DOUBLE(VECTORIN1, VECTORIN2, VECTOROUT)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_252
  INTEGER(w2f__i8) OpenAD_Symbol_253
  INTEGER(w2f__i8) OpenAD_Symbol_254
  INTEGER(w2f__i8) OpenAD_Symbol_255
  INTEGER(w2f__i8) OpenAD_Symbol_256
  INTEGER(w2f__i8) OpenAD_Symbol_257
  INTEGER(w2f__i8) OpenAD_Symbol_258
  INTEGER(w2f__i8) OpenAD_Symbol_259
  INTEGER(w2f__i8) OpenAD_Symbol_260
  INTEGER(w2f__i8) OpenAD_Symbol_261
  INTEGER(w2f__i8) OpenAD_Symbol_262
  INTEGER(w2f__i8) OpenAD_Symbol_263
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) VECTORIN1(1 :)
  REAL(w2f__8) VECTORIN2(1 :)
  REAL(w2f__8) VECTOROUT(1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  DO I = 1, SIZE(VECTORIN1, 1), 1
    IF(VECTORIN1(I) .GE. VECTORIN2(I)) THEN
      VECTOROUT(INT(I)) = VECTORIN2(I)
    ELSE
      VECTOROUT(INT(I)) = VECTORIN1(I)
    ENDIF
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  OpenAD_Symbol_255 = 0_w2f__i8
  DO I = 1, SIZE(VECTORIN1, 1), 1
    IF(VECTORIN1(I) .GE. VECTORIN2(I)) THEN
      VECTOROUT(INT(I)) = VECTORIN2(I)
      OpenAD_Symbol_256 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_256
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      VECTOROUT(INT(I)) = VECTORIN1(I)
      OpenAD_Symbol_257 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_257
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_255 = (INT(OpenAD_Symbol_255) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_255
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_252 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_253 = 1
  DO WHILE(INT(OpenAD_Symbol_253) .LE. INT(OpenAD_Symbol_252))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_254 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_254 .ne. 0) THEN
    ENDIF
    OpenAD_Symbol_253 = INT(OpenAD_Symbol_253) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYMIN_1_1_DOUBLE
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYMAX_0_0_DOUBLE(SCALARIN1, SCALARIN2, SCALAROUT)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_264
  INTEGER(w2f__i8) OpenAD_Symbol_265
  INTEGER(w2f__i8) OpenAD_Symbol_266
  INTEGER(w2f__i8) OpenAD_Symbol_267
  INTEGER(w2f__i8) OpenAD_Symbol_268
  INTEGER(w2f__i8) OpenAD_Symbol_269
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) SCALARIN1
  REAL(w2f__8) SCALARIN2
  REAL(w2f__8) SCALAROUT


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  IF(SCALARIN1 .GE. SCALARIN2) THEN
    SCALAROUT = SCALARIN1
  ELSE
    SCALAROUT = SCALARIN2
  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  IF(SCALARIN1 .GE. SCALARIN2) THEN
    SCALAROUT = SCALARIN1
    OpenAD_Symbol_265 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_265
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    SCALAROUT = SCALARIN2
    OpenAD_Symbol_266 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_266
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_264 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_264 .ne. 0) THEN
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYMAX_0_0_DOUBLE
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYMAX_1_0_DOUBLE(VECTORIN, SCALARIN, VECTOROUT)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_270
  INTEGER(w2f__i8) OpenAD_Symbol_271
  INTEGER(w2f__i8) OpenAD_Symbol_272
  INTEGER(w2f__i8) OpenAD_Symbol_273
  INTEGER(w2f__i8) OpenAD_Symbol_274
  INTEGER(w2f__i8) OpenAD_Symbol_275
  INTEGER(w2f__i8) OpenAD_Symbol_276
  INTEGER(w2f__i8) OpenAD_Symbol_277
  INTEGER(w2f__i8) OpenAD_Symbol_278
  INTEGER(w2f__i8) OpenAD_Symbol_279
  INTEGER(w2f__i8) OpenAD_Symbol_280
  INTEGER(w2f__i8) OpenAD_Symbol_281
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) VECTORIN(1 :)
  REAL(w2f__8) SCALARIN
  REAL(w2f__8) VECTOROUT(1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(VECTORIN,size(VECTORIN),theArgFStack,theArgFStacko&
     &ffset,theArgFStackSize)

  call cp_store_real_scalar(SCALARIN,theArgFStack,theArgFStackoffset,theArgFStac&
     &kSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  SCALARIN = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  do cp_loop_variable_1 = ubound(VECTORIN,1),lbound(VECTORIN,1),-1
  VECTORIN(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  DO I = 1, SIZE(VECTORIN, 1), 1
    IF(VECTORIN(I) .LE. SCALARIN) THEN
      VECTOROUT(INT(I)) = SCALARIN
    ELSE
      VECTOROUT(INT(I)) = VECTORIN(I)
    ENDIF
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  OpenAD_Symbol_273 = 0_w2f__i8
  DO I = 1, SIZE(VECTORIN, 1), 1
    IF(VECTORIN(I) .LE. SCALARIN) THEN
      VECTOROUT(INT(I)) = SCALARIN
      OpenAD_Symbol_274 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_274
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      VECTOROUT(INT(I)) = VECTORIN(I)
      OpenAD_Symbol_275 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_275
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_273 = (INT(OpenAD_Symbol_273) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_273
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_270 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_271 = 1
  DO WHILE(INT(OpenAD_Symbol_271) .LE. INT(OpenAD_Symbol_270))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_272 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_272 .ne. 0) THEN
    ENDIF
    OpenAD_Symbol_271 = INT(OpenAD_Symbol_271) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYMAX_1_0_DOUBLE
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE MYMAX_1_1_DOUBLE(VECTORIN1, VECTORIN2, VECTOROUT)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_282
  INTEGER(w2f__i8) OpenAD_Symbol_283
  INTEGER(w2f__i8) OpenAD_Symbol_284
  INTEGER(w2f__i8) OpenAD_Symbol_285
  INTEGER(w2f__i8) OpenAD_Symbol_286
  INTEGER(w2f__i8) OpenAD_Symbol_287
  INTEGER(w2f__i8) OpenAD_Symbol_288
  INTEGER(w2f__i8) OpenAD_Symbol_289
  INTEGER(w2f__i8) OpenAD_Symbol_290
  INTEGER(w2f__i8) OpenAD_Symbol_291
  INTEGER(w2f__i8) OpenAD_Symbol_292
  INTEGER(w2f__i8) OpenAD_Symbol_293
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) VECTORIN1(1 :)
  REAL(w2f__8) VECTORIN2(1 :)
  REAL(w2f__8) VECTOROUT(1 :)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  DO I = 1, SIZE(VECTORIN1, 1), 1
    IF(VECTORIN1(I) .LE. VECTORIN2(I)) THEN
      VECTOROUT(INT(I)) = VECTORIN2(I)
    ELSE
      VECTOROUT(INT(I)) = VECTORIN1(I)
    ENDIF
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  OpenAD_Symbol_285 = 0_w2f__i8
  DO I = 1, SIZE(VECTORIN1, 1), 1
    IF(VECTORIN1(I) .LE. VECTORIN2(I)) THEN
      VECTOROUT(INT(I)) = VECTORIN2(I)
      OpenAD_Symbol_286 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_286
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      VECTOROUT(INT(I)) = VECTORIN1(I)
      OpenAD_Symbol_287 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_287
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_285 = (INT(OpenAD_Symbol_285) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_285
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_282 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_283 = 1
  DO WHILE(INT(OpenAD_Symbol_283) .LE. INT(OpenAD_Symbol_282))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_284 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_284 .ne. 0) THEN
    ENDIF
    OpenAD_Symbol_283 = INT(OpenAD_Symbol_283) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine MYMAX_1_1_DOUBLE
END

MODULE linsolve
use OAD_active
use w2f__types
use oad_intrinsics
use parameters
use mathutil
use matrix
IMPLICIT NONE
SAVE
!
!     **** Top Level Pragmas ****
!
interface SOLVE
  module procedure SPARSE_SOLVE
end interface

!
!     **** Statements ****
!
CONTAINS
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SPARSE_SOLVE(ANNZ, AROW_INDEX, AROW_COMPRESSED, ACOL_INDEX, AVALUES&
     &, B, X)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) ANNZ
  INTEGER(w2f__i4) AROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) AROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) ACOL_INDEX(1 : 1400)
  REAL(w2f__8) AVALUES(1 : 1400)
  REAL(w2f__8) B(1 : 200)
  REAL(w2f__8) X(1 : 200)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) MATDIM
  PARAMETER ( MATDIM = 200)
  INTEGER(w2f__i4) MAXLEN
  PARAMETER ( MAXLEN = 1400)
  INTEGER(w2f__i4) OAD_CTMP0
  INTEGER(w2f__i4) OAD_CTMP1
  INTEGER(w2f__i4) OAD_CTMP2
  INTEGER(w2f__i4) OAD_CTMP3
  LOGICAL(w2f__i4) OAD_CTMP4


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(ANNZ,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  call cp_store_int_vector(AROW_INDEX,size(AROW_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_int_vector(AROW_COMPRESSED,size(AROW_COMPRESSED),theArgIStack,th&
     &eArgIStackoffset,theArgIStackSize)

  call cp_store_int_vector(ACOL_INDEX,size(ACOL_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_p_real_vector(AVALUES,size(AVALUES),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

  call cp_store_p_real_vector(B,size(B),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  call cp_store_p_real_vector(X,size(X),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(X,1),lbound(X,1),-1
  X(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(B,1),lbound(B,1),-1
  B(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AVALUES,1),lbound(AVALUES,1),-1
  AVALUES(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(ACOL_INDEX,1),lbound(ACOL_INDEX,1),-1
  ACOL_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_COMPRESSED,1),lbound(AROW_COMPRESSED,1),-1
  AROW_COMPRESSED(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_INDEX,1),lbound(AROW_INDEX,1),-1
  AROW_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  ANNZ = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  OAD_CTMP0 = 200
  OAD_CTMP1 = 1400
  OAD_CTMP2 = 64
  OAD_CTMP3 = 100000
  OAD_CTMP4 = .FALSE.
  CALL SPARSE_DUMMY_METHOD(OAD_CTMP0,ANNZ,OAD_CTMP1,AROW_INDEX,AROW_COMPRESSED,A&
     &COL_INDEX,AVALUES,B,X,OAD_CTMP2,OAD_CTMP3,OAD_CTMP4)


! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  OAD_CTMP0 = 200
  OAD_CTMP1 = 1400
  OAD_CTMP2 = 64
  OAD_CTMP3 = 100000
  OAD_CTMP4 = .FALSE.
  CALL SPARSE_DUMMY_METHOD(OAD_CTMP0,ANNZ,OAD_CTMP1,AROW_INDEX,AROW_COMPRESSED,A&
     &COL_INDEX,AVALUES,B,X,OAD_CTMP2,OAD_CTMP3,OAD_CTMP4)

  integer_tape(integer_tape_pointer) = OAD_CTMP0
  integer_tape_pointer = integer_tape_pointer+1
  integer_tape(integer_tape_pointer) = OAD_CTMP1
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OAD_CTMP1 = integer_tape(integer_tape_pointer)
  integer_tape_pointer = integer_tape_pointer-1
  OAD_CTMP0 = integer_tape(integer_tape_pointer)
  CALL SPARSE_DUMMY_METHOD(OAD_CTMP0,ANNZ,OAD_CTMP1,AROW_INDEX,AROW_COMPRESSED,A&
     &COL_INDEX,AVALUES,B,X,OAD_CTMP2,OAD_CTMP3,OAD_CTMP4)


! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SPARSE_SOLVE
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SPARSE_DUMMY_METHOD(N, ANNZ, ALEN, AROW_INDEX, AROW_COMPRESSED, ACO&
     &L_INDEX, AVALUES, B, X, SOLVER_INNER, SOLVER_OUTER, VERBOSE)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) N
  INTEGER(w2f__i4) ANNZ
  INTEGER(w2f__i4) ALEN
  INTEGER(w2f__i4) AROW_INDEX(1 : ALEN)
  INTEGER(w2f__i4) AROW_COMPRESSED(1 : INT((N + 1)))
  INTEGER(w2f__i4) ACOL_INDEX(1 : ALEN)
  REAL(w2f__8) AVALUES(1 : ALEN)
  REAL(w2f__8) B(1 : N)
  REAL(w2f__8) X(1 : N)
  INTEGER(w2f__i4) SOLVER_INNER
  INTEGER(w2f__i4) SOLVER_OUTER
  LOGICAL(w2f__i4) VERBOSE
!
!       **** Local Variables and Functions ****
!
  EXTERNAL spmat_multiply_vector2


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(ANNZ,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  call cp_store_int_vector(AROW_INDEX,size(AROW_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_int_vector(AROW_COMPRESSED,size(AROW_COMPRESSED),theArgIStack,th&
     &eArgIStackoffset,theArgIStackSize)

  call cp_store_int_vector(ACOL_INDEX,size(ACOL_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_p_real_vector(AVALUES,size(AVALUES),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

  call cp_store_p_real_vector(B,size(B),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  call cp_store_p_real_vector(X,size(X),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  call cp_store_int_scalar(N,theArgIStack,theArgIStackoffset,theArgIStackSize)
  call cp_store_int_scalar(ALEN,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  ALEN = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  N = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  do cp_loop_variable_1 = ubound(X,1),lbound(X,1),-1
  X(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(B,1),lbound(B,1),-1
  B(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AVALUES,1),lbound(AVALUES,1),-1
  AVALUES(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(ACOL_INDEX,1),lbound(ACOL_INDEX,1),-1
  ACOL_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_COMPRESSED,1),lbound(AROW_COMPRESSED,1),-1
  AROW_COMPRESSED(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_INDEX,1),lbound(AROW_INDEX,1),-1
  AROW_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  ANNZ = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  CALL spmat_multiply_vector2(ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES&
     &,B,X,'PRE')


! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  CALL spmat_multiply_vector2(ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES&
     &,B,X,'PRE')


! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SPARSE_DUMMY_METHOD
END

MODULE finitevolume
use OAD_active
use w2f__types
use oad_intrinsics
use parameters
use mathutil
use matrix
use linsolve
IMPLICIT NONE
SAVE
!
!     **** Top Level Pragmas ****
!
interface RELPERM
  module procedure RELPERM_VECTOR
  module procedure RELPERM_SCALAR
end interface

!
!     **** Statements ****
!
CONTAINS
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE NEWTRAPH(Q, V, S)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_294
  INTEGER(w2f__i8) OpenAD_Symbol_295
  INTEGER(w2f__i8) OpenAD_Symbol_296
  INTEGER(w2f__i8) OpenAD_Symbol_297
  INTEGER(w2f__i8) OpenAD_Symbol_298
  INTEGER(w2f__i8) OpenAD_Symbol_299
  INTEGER(w2f__i8) OpenAD_Symbol_300
  INTEGER(w2f__i8) OpenAD_Symbol_301
  INTEGER(w2f__i8) OpenAD_Symbol_302
  INTEGER(w2f__i8) OpenAD_Symbol_303
  INTEGER(w2f__i8) OpenAD_Symbol_304
  INTEGER(w2f__i8) OpenAD_Symbol_305
  INTEGER(w2f__i8) OpenAD_Symbol_306
  INTEGER(w2f__i8) OpenAD_Symbol_307
  INTEGER(w2f__i8) OpenAD_Symbol_308
  INTEGER(w2f__i8) OpenAD_Symbol_309
  INTEGER(w2f__i8) OpenAD_Symbol_310
  INTEGER(w2f__i8) OpenAD_Symbol_311
  INTEGER(w2f__i8) OpenAD_Symbol_312
  INTEGER(w2f__i8) OpenAD_Symbol_313
  INTEGER(w2f__i8) OpenAD_Symbol_314
  INTEGER(w2f__i8) OpenAD_Symbol_315
  INTEGER(w2f__i8) OpenAD_Symbol_316
  INTEGER(w2f__i8) OpenAD_Symbol_317
  INTEGER(w2f__i8) OpenAD_Symbol_318
  INTEGER(w2f__i8) OpenAD_Symbol_319
  INTEGER(w2f__i8) OpenAD_Symbol_320
  INTEGER(w2f__i8) OpenAD_Symbol_321
  INTEGER(w2f__i8) OpenAD_Symbol_322
  INTEGER(w2f__i8) OpenAD_Symbol_323
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) Q(1 : 200)
  REAL(w2f__8) V(1 : 3, 1 : 11, 1 : 11, 1 : 3)
  REAL(w2f__8) S(1 : 200)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) ACOL_INDEX(1 : 1400)
  INTEGER(w2f__i4) ANNZ
  INTEGER(w2f__i4) AROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) AROW_INDEX(1 : 1400)
  REAL(w2f__8) AVALUES(1 : 1400)
  INTEGER(w2f__i4) BCOL_INDEX(1 : 1400)
  REAL(w2f__8) BFW(1 : 200)
  INTEGER(w2f__i4) BNNZ
  INTEGER(w2f__i4) BROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) BROW_INDEX(1 : 1400)
  REAL(w2f__8) BVALUES(1 : 1400)
  LOGICAL(w2f__i4) CONVERGED
  REAL(w2f__8) DF(1 : 200)
  INTEGER(w2f__i4) DGCOL_INDEX(1 : 1400)
  INTEGER(w2f__i4) DGNNZ
  INTEGER(w2f__i4) DGROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) DGROW_INDEX(1 : 1400)
  REAL(w2f__8) DGVALUES(1 : 1400)
  REAL(w2f__8) DMO(1 : 200)
  REAL(w2f__8) DMW(1 : 200)
  REAL(w2f__8) DS(1 : 200)
  REAL(w2f__8) DSN
  REAL(w2f__8) DT
  REAL(w2f__8) DTX(1 : 200)
  REAL(w2f__8) FI(1 : 200)
  REAL(w2f__8) FW(1 : 200)
  REAL(w2f__8) G(1 : 200)
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) IT
  INTEGER(w2f__i4) J
  REAL(w2f__8) MO(1 : 200)
  REAL(w2f__8) MW(1 : 200)
  REAL(w2f__8) OAD_CTMP0
  REAL(w2f__8) OAD_CTMP1
  INTEGER(w2f__i4) OAD_CTMP2
  INTEGER(w2f__i4) OAD_CTMP3
  REAL(w2f__8) S_COPY(1 : 200)
  REAL(w2f__8) S_ITER_COPY(1 : 200)


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(Q,size(Q),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  do cp_loop_variable_4 = lbound(V,4),ubound(V,4)
  do cp_loop_variable_3 = lbound(V,3),ubound(V,3)
  do cp_loop_variable_2 = lbound(V,2),ubound(V,2)
  call cp_store_p_real_vector(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4),size(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variabl&
     &e_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
  call cp_store_p_real_vector(S,size(S),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  call cp_store_p_real_vector(POR,size(POR),theArgFStack,theArgFStackoffset,theA&
     &rgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(POR,1),lbound(POR,1),-1
  POR(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(S,1),lbound(S,1),-1
  S(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_4 = ubound(V,4),lbound(V,4),-1
  do cp_loop_variable_3 = ubound(V,3),lbound(V,3),-1
  do cp_loop_variable_2 = ubound(V,2),lbound(V,2),-1
  do cp_loop_variable_1 = ubound(V,1),lbound(V,1),-1
  V(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable_4)&
     & = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  do cp_loop_variable_1 = ubound(Q,1),lbound(Q,1),-1
  Q(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  CONVERGED = .FALSE.
  CALL GENA(V,Q,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)
  S_COPY(1 : 200) = S(1 : 200)
  IT = 0
  DO WHILE(.NOT. CONVERGED)
    DT = (5.0D00 /(2 ** IT))
    DTX(1 : 200) = (DT /(POR(1 : 200) * 1.13267386368000018138D+01))
    OAD_CTMP0 = 0.0D00
    CALL MYMAX_1_0_DOUBLE(Q,OAD_CTMP0,FI)
    FI(1 : 200) = (DTX(1 : 200) * FI(1 : 200))
    CALL SPMAT_MULTIPLY_DIAGONAL(ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVAL&
     &UES,DTX,BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,BVALUES,'POS')

    I = 0
    DO WHILE(I .LT.(2 ** IT))
      J = 0
      I = (I + 1)
      DSN = 1.0D00
      S_ITER_COPY(1 : 200) = S(1 : 200)
      DO WHILE((J .LT. 10) .AND.(DSN .GT. 1.00000000000000002082D-03))
        CALL RELPERM_VECTOR(S,MW,MO,DMW,DMO)
        DF(1 : 200) = ((DMW(1 : 200) /(MO(1 : 200) + MW(1 : 200)) ) -(MW(1 : 200&
     &) /((MO(1 : 200) + MW(1 : 200)) ** 2)) *(DMO(1 : 200) + DMW(1 : 200)))

        CALL SPMAT_MULTIPLY_DIAGONAL(BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,&
     &BVALUES,DF,DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALUES,'PRE')

        OAD_CTMP1 = (-1.0D00)
        OAD_CTMP2 = 0
        CALL ADDX_DIAGONAL(DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALU&
     &ES,OAD_CTMP1,OAD_CTMP2)

        FW(1 : 200) = (MW(1 : 200) /(MO(1 : 200) + MW(1 : 200)))
        CALL SPMAT_MULTIPLY_VECTOR(BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,BV&
     &ALUES,FW,BFW,'PRE')

        G(1 : 200) = (S(1 : 200) - S_ITER_COPY(1 : 200) - BFW(1 : 200) - FI(1 : &
     &200))

        CALL SPARSE_SOLVE(DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALUE&
     &S,G,DS)

        S(1 : 200) = (S(1 : 200) + DS(1 : 200))
        OAD_CTMP3 = 200
        CALL DNRM2(DS,OAD_CTMP3,DSN)
        J = (J + 1)
      END DO
      IF(DSN .GT. 1.00000000000000002082D-03) THEN
        I = (2 ** IT)
        S(1 : 200) = S_COPY(1 : 200)
      ENDIF
    END DO
    IF(DSN .LT. 1.00000000000000002082D-03) THEN
      CONVERGED = .TRUE.
    ELSE
      IT = (IT + 1)
    ENDIF
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  CONVERGED = .FALSE.
  CALL GENA(V,Q,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)
  S_COPY(1 : 200) = S(1 : 200)
  IT = 0
  OpenAD_Symbol_302 = 0_w2f__i8
  DO WHILE(.NOT. CONVERGED)
    DT = (5.0D00 /(2 ** IT))
    DTX(1 : 200) = (DT /(POR(1 : 200) * 1.13267386368000018138D+01))
    OAD_CTMP0 = 0.0D00
    CALL MYMAX_1_0_DOUBLE(Q,OAD_CTMP0,FI)
    FI(1 : 200) = (DTX(1 : 200) * FI(1 : 200))
    CALL SPMAT_MULTIPLY_DIAGONAL(ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVAL&
     &UES,DTX,BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,BVALUES,'POS')

    I = 0
    OpenAD_Symbol_303 = 0_w2f__i8
    DO WHILE(I .LT.(2 ** IT))
      J = 0
      I = (I + 1)
      DSN = 1.0D00
      S_ITER_COPY(1 : 200) = S(1 : 200)
      OpenAD_Symbol_304 = 0_w2f__i8
      DO WHILE((J .LT. 10) .AND.(DSN .GT. 1.00000000000000002082D-03))
        CALL RELPERM_VECTOR(S,MW,MO,DMW,DMO)
        DF(1 : 200) = ((DMW(1 : 200) /(MO(1 : 200) + MW(1 : 200)) ) -(MW(1 : 200&
     &) /((MO(1 : 200) + MW(1 : 200)) ** 2)) *(DMO(1 : 200) + DMW(1 : 200)))

        CALL SPMAT_MULTIPLY_DIAGONAL(BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,&
     &BVALUES,DF,DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALUES,'PRE')

        OAD_CTMP1 = (-1.0D00)
        OAD_CTMP2 = 0
        CALL ADDX_DIAGONAL(DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALU&
     &ES,OAD_CTMP1,OAD_CTMP2)

        FW(1 : 200) = (MW(1 : 200) /(MO(1 : 200) + MW(1 : 200)))
        CALL SPMAT_MULTIPLY_VECTOR(BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,BV&
     &ALUES,FW,BFW,'PRE')

        G(1 : 200) = (S(1 : 200) - S_ITER_COPY(1 : 200) - BFW(1 : 200) - FI(1 : &
     &200))

        CALL SPARSE_SOLVE(DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALUE&
     &S,G,DS)

        S(1 : 200) = (S(1 : 200) + DS(1 : 200))
        OAD_CTMP3 = 200
        CALL DNRM2(DS,OAD_CTMP3,DSN)
        integer_tape(integer_tape_pointer) = OAD_CTMP3
        integer_tape_pointer = integer_tape_pointer+1
        J = (J + 1)
        OpenAD_Symbol_304 = (INT(OpenAD_Symbol_304) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_304
      integer_tape_pointer = integer_tape_pointer+1
      IF(DSN .GT. 1.00000000000000002082D-03) THEN
        I = (2 ** IT)
        S(1 : 200) = S_COPY(1 : 200)
        OpenAD_Symbol_305 = 1_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_305
        integer_tape_pointer = integer_tape_pointer+1
      ELSE
        OpenAD_Symbol_306 = 0_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_306
        integer_tape_pointer = integer_tape_pointer+1
      ENDIF
      OpenAD_Symbol_303 = (INT(OpenAD_Symbol_303) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_303
    integer_tape_pointer = integer_tape_pointer+1
    IF(DSN .LT. 1.00000000000000002082D-03) THEN
      CONVERGED = .TRUE.
      OpenAD_Symbol_307 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_307
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      IT = (IT + 1)
      OpenAD_Symbol_308 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_308
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_302 = (INT(OpenAD_Symbol_302) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_302
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_294 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_295 = 1
  DO WHILE(INT(OpenAD_Symbol_295) .LE. INT(OpenAD_Symbol_294))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_296 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_296 .ne. 0) THEN
    ENDIF
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_297 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_298 = 1
    DO WHILE(INT(OpenAD_Symbol_298) .LE. INT(OpenAD_Symbol_297))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_299 = integer_tape(integer_tape_pointer)
      IF(OpenAD_Symbol_299 .ne. 0) THEN
      ENDIF
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_300 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_301 = 1
      DO WHILE(INT(OpenAD_Symbol_301) .LE. INT(OpenAD_Symbol_300) )
        integer_tape_pointer = integer_tape_pointer-1
        OAD_CTMP3 = integer_tape(integer_tape_pointer)
        CALL DNRM2(DS,OAD_CTMP3,DSN)
        CALL SPARSE_SOLVE(DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALUE&
     &S,G,DS)

        CALL SPMAT_MULTIPLY_VECTOR(BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,BV&
     &ALUES,FW,BFW,'PRE')

        CALL ADDX_DIAGONAL(DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALU&
     &ES,OAD_CTMP1,OAD_CTMP2)

        CALL SPMAT_MULTIPLY_DIAGONAL(BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,&
     &BVALUES,DF,DGNNZ,DGROW_INDEX,DGROW_COMPRESSED,DGCOL_INDEX,DGVALUES,'PRE')

        CALL RELPERM_VECTOR(S,MW,MO,DMW,DMO)
        OpenAD_Symbol_301 = INT(OpenAD_Symbol_301) + 1
      END DO
      OpenAD_Symbol_298 = INT(OpenAD_Symbol_298) + 1
    END DO
    CALL SPMAT_MULTIPLY_DIAGONAL(ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVAL&
     &UES,DTX,BNNZ,BROW_INDEX,BROW_COMPRESSED,BCOL_INDEX,BVALUES,'POS')

    CALL MYMAX_1_0_DOUBLE(Q,OAD_CTMP0,FI)
    OpenAD_Symbol_295 = INT(OpenAD_Symbol_295) + 1
  END DO
  CALL GENA(V,Q,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine NEWTRAPH
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE PRES(Q, S, P, V)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_342
  INTEGER(w2f__i8) OpenAD_Symbol_343
  INTEGER(w2f__i8) OpenAD_Symbol_344
  INTEGER(w2f__i8) OpenAD_Symbol_345
  INTEGER(w2f__i8) OpenAD_Symbol_346
  INTEGER(w2f__i8) OpenAD_Symbol_347
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) Q(1 : 200)
  REAL(w2f__8) S(1 : 200)
  REAL(w2f__8) P(1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) V(1 : 3, 1 : 11, 1 : 11, 1 : 3)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  REAL(w2f__8) KM(1 : 3, 1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) M(1 : 600)
  REAL(w2f__8) MO(1 : 200)
  REAL(w2f__8) MW(1 : 200)


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(Q,size(Q),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  call cp_store_p_real_vector(S,size(S),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  do cp_loop_variable_3 = lbound(P,3),ubound(P,3)
  do cp_loop_variable_2 = lbound(P,2),ubound(P,2)
  call cp_store_p_real_vector(P(:,cp_loop_variable_2,cp_loop_variable_3),size(P(&
     &:,cp_loop_variable_2,cp_loop_variable_3)),theArgFStack,theArgFStackoffset,&
     &theArgFStackSize)

  end do
  end do
  do cp_loop_variable_4 = lbound(V,4),ubound(V,4)
  do cp_loop_variable_3 = lbound(V,3),ubound(V,3)
  do cp_loop_variable_2 = lbound(V,2),ubound(V,2)
  call cp_store_p_real_vector(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4),size(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variabl&
     &e_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
  do cp_loop_variable_4 = lbound(PERM,4),ubound(PERM,4)
  do cp_loop_variable_3 = lbound(PERM,3),ubound(PERM,3)
  do cp_loop_variable_2 = lbound(PERM,2),ubound(PERM,2)
  call cp_store_p_real_vector(PERM(:,cp_loop_variable_2,cp_loop_variable_3,cp_lo&
     &op_variable_4),size(PERM(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_v&
     &ariable_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_4 = ubound(PERM,4),lbound(PERM,4),-1
  do cp_loop_variable_3 = ubound(PERM,3),lbound(PERM,3),-1
  do cp_loop_variable_2 = ubound(PERM,2),lbound(PERM,2),-1
  do cp_loop_variable_1 = ubound(PERM,1),lbound(PERM,1),-1
  PERM(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable&
     &_4) = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  do cp_loop_variable_4 = ubound(V,4),lbound(V,4),-1
  do cp_loop_variable_3 = ubound(V,3),lbound(V,3),-1
  do cp_loop_variable_2 = ubound(V,2),lbound(V,2),-1
  do cp_loop_variable_1 = ubound(V,1),lbound(V,1),-1
  V(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable_4)&
     & = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  do cp_loop_variable_3 = ubound(P,3),lbound(P,3),-1
  do cp_loop_variable_2 = ubound(P,2),lbound(P,2),-1
  do cp_loop_variable_1 = ubound(P,1),lbound(P,1),-1
  P(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3) = theArgFStack(the&
     &ArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  do cp_loop_variable_1 = ubound(S,1),lbound(S,1),-1
  S(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(Q,1),lbound(Q,1),-1
  Q(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  CALL RELPERM_VECTOR(S,MW,MO)
  DO I = 1, 200, 1
    M(I * 3 + (-2)) = (MO(I) + MW(I))
    M(I * 3 + (-1)) = M(I * 3 + (-2))
    M(I * 3) = M(I * 3 + (-2))
  END DO
  CALL MYRESHAPE_1_4(M,KM)
  KM(1 : 3, 1 : 10, 1 : 10, 1 : 2) = (KM(1 : 3, 1 : 10, 1 : 10, 1 : 2) * PERM(1 &
     &: 3, 1 : 10, 1 : 10, 1 : 2))

  CALL TPFA(KM,Q,P,V)

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  CALL RELPERM_VECTOR(S,MW,MO)
  OpenAD_Symbol_344 = 0_w2f__i8
  DO I = 1, 200, 1
    M(I * 3 + (-2)) = (MO(I) + MW(I))
    M(I * 3 + (-1)) = M(I * 3 + (-2))
    M(I * 3) = M(I * 3 + (-2))
    OpenAD_Symbol_344 = (INT(OpenAD_Symbol_344) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_344
  integer_tape_pointer = integer_tape_pointer+1
  CALL MYRESHAPE_1_4(M,KM)
  KM(1 : 3, 1 : 10, 1 : 10, 1 : 2) = (KM(1 : 3, 1 : 10, 1 : 10, 1 : 2) * PERM(1 &
     &: 3, 1 : 10, 1 : 10, 1 : 2))

  CALL TPFA(KM,Q,P,V)

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  CALL TPFA(KM,Q,P,V)
  CALL MYRESHAPE_1_4(M,KM)
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_342 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_343 = 1
  DO WHILE(INT(OpenAD_Symbol_343) .LE. INT(OpenAD_Symbol_342))
    OpenAD_Symbol_343 = INT(OpenAD_Symbol_343) + 1
  END DO
  CALL RELPERM_VECTOR(S,MW,MO)

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine PRES
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE RELPERM_VECTOR(S, MW, MO, DMW, DMO)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_324
  INTEGER(w2f__i8) OpenAD_Symbol_325
  INTEGER(w2f__i8) OpenAD_Symbol_326
  INTEGER(w2f__i8) OpenAD_Symbol_327
  INTEGER(w2f__i8) OpenAD_Symbol_328
  INTEGER(w2f__i8) OpenAD_Symbol_329
  INTEGER(w2f__i8) OpenAD_Symbol_330
  INTEGER(w2f__i8) OpenAD_Symbol_331
  INTEGER(w2f__i8) OpenAD_Symbol_332
  INTEGER(w2f__i8) OpenAD_Symbol_333
  INTEGER(w2f__i8) OpenAD_Symbol_334
  INTEGER(w2f__i8) OpenAD_Symbol_335
  INTEGER(w2f__i8) OpenAD_Symbol_336
  INTEGER(w2f__i8) OpenAD_Symbol_337
  INTEGER(w2f__i8) OpenAD_Symbol_338
  INTEGER(w2f__i8) OpenAD_Symbol_339
  INTEGER(w2f__i8) OpenAD_Symbol_340
  INTEGER(w2f__i8) OpenAD_Symbol_341
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) S(1 : 200)
  REAL(w2f__8) MW(1 : 200)
  REAL(w2f__8) MO(1 : 200)
  REAL(w2f__8) DMW(1 : 200)
  OPTIONAL DMW
  REAL(w2f__8) DMO(1 : 200)
  OPTIONAL DMO
!
!       **** Local Variables and Functions ****
!
  REAL(w2f__8) S_TEMP(1 : 200)
  LOGICAL(w2f__i4) t__101


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(DMW,size(DMW),theArgFStack,theArgFStackoffset,theA&
     &rgFStackSize)

  call cp_store_p_real_vector(DMO,size(DMO),theArgFStack,theArgFStackoffset,theA&
     &rgFStackSize)

  call cp_store_p_real_vector(S,size(S),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(S,1),lbound(S,1),-1
  S(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(DMO,1),lbound(DMO,1),-1
  DMO(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(DMW,1),lbound(DMW,1),-1
  DMW(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  S_TEMP(1 : 200) = ((S(1 : 200) +(-2.00000000000000011102D-01)) / 6.00000000000&
     &000088818D-01)

  MW(1 : 200) = ((S_TEMP(1 : 200) ** 2) / 2.99999999999999973719D-04)
  MO(1 : 200) = (((1.0D00 - S_TEMP(1 : 200)) ** 2) / 3.00000000000000006245D-03)
  t__101 = .TRUE.
  IF(.NOT. PRESENT(DMO)) THEN
    t__101 = .FALSE.
  ELSE
    IF(.NOT. PRESENT(DMW)) THEN
      t__101 = .FALSE.
    ENDIF
  ENDIF
  IF(t__101) THEN
    DMW(1 : 200) = (((S_TEMP(1 : 200) * 2.0D00) / 2.99999999999999973719D-04) / &
     &6.00000000000000088818D-01)

    DMO(1 : 200) = ((((1.0D00 - S_TEMP(1 : 200)) * 2.0D00) / 3.00000000000000006&
     &245D-03) /(-6.00000000000000088818D-01))

  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  S_TEMP(1 : 200) = ((S(1 : 200) +(-2.00000000000000011102D-01)) / 6.00000000000&
     &000088818D-01)

  MW(1 : 200) = ((S_TEMP(1 : 200) ** 2) / 2.99999999999999973719D-04)
  MO(1 : 200) = (((1.0D00 - S_TEMP(1 : 200)) ** 2) / 3.00000000000000006245D-03)
  t__101 = .TRUE.
  IF(.NOT. PRESENT(DMO)) THEN
    t__101 = .FALSE.
    OpenAD_Symbol_329 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_329
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    IF(.NOT. PRESENT(DMW)) THEN
      t__101 = .FALSE.
      OpenAD_Symbol_327 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_327
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      OpenAD_Symbol_328 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_328
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_330 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_330
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF
  IF(t__101) THEN
    DMW(1 : 200) = (((S_TEMP(1 : 200) * 2.0D00) / 2.99999999999999973719D-04) / &
     &6.00000000000000088818D-01)

    DMO(1 : 200) = ((((1.0D00 - S_TEMP(1 : 200)) * 2.0D00) / 3.00000000000000006&
     &245D-03) /(-6.00000000000000088818D-01))

    OpenAD_Symbol_331 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_331
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    OpenAD_Symbol_332 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_332
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_324 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_324 .ne. 0) THEN
  ENDIF
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_325 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_325 .ne. 0) THEN
  ELSE
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_326 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_326 .ne. 0) THEN
    ENDIF
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine RELPERM_VECTOR
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE RELPERM_SCALAR(S, MW, MO, DMW, DMO)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_366
  INTEGER(w2f__i8) OpenAD_Symbol_367
  INTEGER(w2f__i8) OpenAD_Symbol_368
  INTEGER(w2f__i8) OpenAD_Symbol_369
  INTEGER(w2f__i8) OpenAD_Symbol_370
  INTEGER(w2f__i8) OpenAD_Symbol_371
  INTEGER(w2f__i8) OpenAD_Symbol_372
  INTEGER(w2f__i8) OpenAD_Symbol_373
  INTEGER(w2f__i8) OpenAD_Symbol_374
  INTEGER(w2f__i8) OpenAD_Symbol_375
  INTEGER(w2f__i8) OpenAD_Symbol_376
  INTEGER(w2f__i8) OpenAD_Symbol_377
  INTEGER(w2f__i8) OpenAD_Symbol_378
  INTEGER(w2f__i8) OpenAD_Symbol_379
  INTEGER(w2f__i8) OpenAD_Symbol_380
  INTEGER(w2f__i8) OpenAD_Symbol_381
  INTEGER(w2f__i8) OpenAD_Symbol_382
  INTEGER(w2f__i8) OpenAD_Symbol_383
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) S
  REAL(w2f__8) MW
  REAL(w2f__8) MO
  REAL(w2f__8) DMW
  OPTIONAL DMW
  REAL(w2f__8) DMO
  OPTIONAL DMO
!
!       **** Local Variables and Functions ****
!
  REAL(w2f__8) S_TEMP
  LOGICAL(w2f__i4) t__102


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_real_scalar(S,theArgFStack,theArgFStackoffset,theArgFStackSize)
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  S = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  S_TEMP = ((S +(-2.00000000000000011102D-01)) / 6.00000000000000088818D-01)
  MW = ((S_TEMP ** 2) / 2.99999999999999973719D-04)
  MO = (((1.0D00 - S_TEMP) ** 2) / 3.00000000000000006245D-03)
  t__102 = .TRUE.
  IF(.NOT. PRESENT(DMO)) THEN
    t__102 = .FALSE.
  ELSE
    IF(.NOT. PRESENT(DMW)) THEN
      t__102 = .FALSE.
    ENDIF
  ENDIF
  IF(t__102) THEN
    DMW = (((S_TEMP * 2.0D00) / 2.99999999999999973719D-04) / 6.0000000000000008&
     &8818D-01)

    DMO = ((((1.0D00 - S_TEMP) * 2.0D00) / 3.00000000000000006245D-03) /(-6.0000&
     &0000000000088818D-01))

  ENDIF

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  S_TEMP = ((S +(-2.00000000000000011102D-01)) / 6.00000000000000088818D-01)
  MW = ((S_TEMP ** 2) / 2.99999999999999973719D-04)
  MO = (((1.0D00 - S_TEMP) ** 2) / 3.00000000000000006245D-03)
  t__102 = .TRUE.
  IF(.NOT. PRESENT(DMO)) THEN
    t__102 = .FALSE.
    OpenAD_Symbol_371 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_371
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    IF(.NOT. PRESENT(DMW)) THEN
      t__102 = .FALSE.
      OpenAD_Symbol_369 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_369
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      OpenAD_Symbol_370 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_370
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_372 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_372
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF
  IF(t__102) THEN
    DMW = (((S_TEMP * 2.0D00) / 2.99999999999999973719D-04) / 6.0000000000000008&
     &8818D-01)

    DMO = ((((1.0D00 - S_TEMP) * 2.0D00) / 3.00000000000000006245D-03) /(-6.0000&
     &0000000000088818D-01))

    OpenAD_Symbol_373 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_373
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    OpenAD_Symbol_374 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_374
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_366 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_366 .ne. 0) THEN
  ENDIF
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_367 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_367 .ne. 0) THEN
  ELSE
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_368 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_368 .ne. 0) THEN
    ENDIF
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine RELPERM_SCALAR
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE GENA(V, Q, ANNZ, AROW_INDEX, AROW_COMPRESSED, ACOL_INDEX, AVALUES)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) V(1 : 3, 1 : 11, 1 : 11, 1 : 3)
  REAL(w2f__8) Q(1 : 200)
  INTEGER(w2f__i4) ANNZ
  INTEGER(w2f__i4) AROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) AROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) ACOL_INDEX(1 : 1400)
  REAL(w2f__8) AVALUES(1 : 1400)
!
!       **** Local Variables and Functions ****
!
  REAL(w2f__8) DIAGS(1 : 200, 1 : 7)
  REAL(w2f__8) DIAG_TMP(1 : 200)
  REAL(w2f__8) OAD_CTMP0
  REAL(w2f__8) OAD_CTMP1
  REAL(w2f__8) OAD_CTMP2
  REAL(w2f__8) OAD_CTMP3
  REAL(w2f__8) OAD_CTMP4
  REAL(w2f__8) OAD_CTMP5
  REAL(w2f__8) OAD_CTMP6
  REAL(w2f__8) VXYZ(1 : 10, 1 : 10, 1 : 2)


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(Q,size(Q),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  call cp_store_int_scalar(ANNZ,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  call cp_store_int_vector(AROW_INDEX,size(AROW_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_int_vector(AROW_COMPRESSED,size(AROW_COMPRESSED),theArgIStack,th&
     &eArgIStackoffset,theArgIStackSize)

  call cp_store_int_vector(ACOL_INDEX,size(ACOL_INDEX),theArgIStack,theArgIStack&
     &offset,theArgIStackSize)

  call cp_store_p_real_vector(AVALUES,size(AVALUES),theArgFStack,theArgFStackoff&
     &set,theArgFStackSize)

  do cp_loop_variable_4 = lbound(V,4),ubound(V,4)
  do cp_loop_variable_3 = lbound(V,3),ubound(V,3)
  do cp_loop_variable_2 = lbound(V,2),ubound(V,2)
  call cp_store_p_real_vector(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4),size(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variabl&
     &e_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_4 = ubound(V,4),lbound(V,4),-1
  do cp_loop_variable_3 = ubound(V,3),lbound(V,3),-1
  do cp_loop_variable_2 = ubound(V,2),lbound(V,2),-1
  do cp_loop_variable_1 = ubound(V,1),lbound(V,1),-1
  V(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable_4)&
     & = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  do cp_loop_variable_1 = ubound(AVALUES,1),lbound(AVALUES,1),-1
  AVALUES(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(ACOL_INDEX,1),lbound(ACOL_INDEX,1),-1
  ACOL_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_COMPRESSED,1),lbound(AROW_COMPRESSED,1),-1
  AROW_COMPRESSED(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(AROW_INDEX,1),lbound(AROW_INDEX,1),-1
  AROW_INDEX(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  ANNZ = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  do cp_loop_variable_1 = ubound(Q,1),lbound(Q,1),-1
  Q(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  DIAGS(1 : 200, 1 : 7) = 0.0D00
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(3, 1 : 10, 1 : 10, 2 : 3)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,1))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(2, 1 : 10, 2 : 11, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,2))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(1, 2 : 11, 1 : 10, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,3))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(1, 1 : 10, 1 : 10, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,5))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(2, 1 : 10, 1 : 10, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,6))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(3, 1 : 10, 1 : 10, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,7))
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP0 = 0.0D00
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,1),OAD_CTMP0,DIAG_TMP)
  DIAGS(1 : 200, 1) = DIAG_TMP(1 : 200)
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP1 = 0.0D00
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,2),OAD_CTMP1,DIAG_TMP)
  DIAGS(1 : 200, 2) = DIAG_TMP(1 : 200)
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP2 = 0.0D00
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,3),OAD_CTMP2,DIAG_TMP)
  DIAGS(1 : 200, 3) = DIAG_TMP(1 : 200)
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP3 = 0.0D00
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,5),OAD_CTMP3,DIAG_TMP)
  DIAGS(1 : 200, 5) = (- DIAG_TMP(1 : 200))
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP4 = 0.0D00
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,6),OAD_CTMP4,DIAG_TMP)
  DIAGS(1 : 200, 6) = (- DIAG_TMP(1 : 200))
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP5 = 0.0D00
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,7),OAD_CTMP5,DIAG_TMP)
  DIAGS(1 : 200, 7) = (- DIAG_TMP(1 : 200))
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP6 = 0.0D00
  CALL MYMIN_1_0_DOUBLE(Q,OAD_CTMP6,DIAG_TMP)
  DIAGS(1 : 200, 4) = (DIAG_TMP(1 : 200) - DIAGS(1 : 200, 5) - DIAGS(1 : 200, 3)&
     & - DIAGS(1 : 200, 6) - DIAGS(1 : 200, 2) - DIAGS(1 : 200, 7) - DIAGS(1 : 2&
     &00, 1))

  CALL SPDIAGS_FVM_CSR(DIAGS,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  DIAGS(1 : 200, 1 : 7) = 0.0D00
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(3, 1 : 10, 1 : 10, 2 : 3)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,1))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(2, 1 : 10, 2 : 11, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,2))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(1, 2 : 11, 1 : 10, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,3))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(1, 1 : 10, 1 : 10, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,5))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(2, 1 : 10, 1 : 10, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,6))
  VXYZ(1 : 10, 1 : 10, 1 : 2) = V(3, 1 : 10, 1 : 10, 1 : 2)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,7))
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP0 = 0.0D00
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,1),OAD_CTMP0,DIAG_TMP)
  DIAGS(1 : 200, 1) = DIAG_TMP(1 : 200)
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP1 = 0.0D00
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,2),OAD_CTMP1,DIAG_TMP)
  DIAGS(1 : 200, 2) = DIAG_TMP(1 : 200)
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP2 = 0.0D00
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,3),OAD_CTMP2,DIAG_TMP)
  DIAGS(1 : 200, 3) = DIAG_TMP(1 : 200)
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP3 = 0.0D00
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,5),OAD_CTMP3,DIAG_TMP)
  DIAGS(1 : 200, 5) = (- DIAG_TMP(1 : 200))
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP4 = 0.0D00
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,6),OAD_CTMP4,DIAG_TMP)
  DIAGS(1 : 200, 6) = (- DIAG_TMP(1 : 200))
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP5 = 0.0D00
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,7),OAD_CTMP5,DIAG_TMP)
  DIAGS(1 : 200, 7) = (- DIAG_TMP(1 : 200))
  DIAG_TMP(1 : 200) = 0.0D00
  OAD_CTMP6 = 0.0D00
  CALL MYMIN_1_0_DOUBLE(Q,OAD_CTMP6,DIAG_TMP)
  DIAGS(1 : 200, 4) = (DIAG_TMP(1 : 200) - DIAGS(1 : 200, 5) - DIAGS(1 : 200, 3)&
     & - DIAGS(1 : 200, 6) - DIAGS(1 : 200, 2) - DIAGS(1 : 200, 7) - DIAGS(1 : 2&
     &00, 1))

  CALL SPDIAGS_FVM_CSR(DIAGS,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  CALL SPDIAGS_FVM_CSR(DIAGS,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)
  CALL MYMIN_1_0_DOUBLE(Q,OAD_CTMP6,DIAG_TMP)
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,7),OAD_CTMP5,DIAG_TMP)
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,6),OAD_CTMP4,DIAG_TMP)
  CALL MYMIN_1_0_DOUBLE(DIAGS(1:200,5),OAD_CTMP3,DIAG_TMP)
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,3),OAD_CTMP2,DIAG_TMP)
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,2),OAD_CTMP1,DIAG_TMP)
  CALL MYMAX_1_0_DOUBLE(DIAGS(1:200,1),OAD_CTMP0,DIAG_TMP)
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,7))
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,6))
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,5))
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,3))
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,2))
  CALL MYRESHAPE_3_1(VXYZ,DIAGS(1:200,1))

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine GENA
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE TPFA(K, Q, P, V)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_348
  INTEGER(w2f__i8) OpenAD_Symbol_349
  INTEGER(w2f__i8) OpenAD_Symbol_350
  INTEGER(w2f__i8) OpenAD_Symbol_351
  INTEGER(w2f__i8) OpenAD_Symbol_352
  INTEGER(w2f__i8) OpenAD_Symbol_353
  INTEGER(w2f__i8) OpenAD_Symbol_354
  INTEGER(w2f__i8) OpenAD_Symbol_355
  INTEGER(w2f__i8) OpenAD_Symbol_356
  INTEGER(w2f__i8) OpenAD_Symbol_357
  INTEGER(w2f__i8) OpenAD_Symbol_358
  INTEGER(w2f__i8) OpenAD_Symbol_359
  INTEGER(w2f__i8) OpenAD_Symbol_360
  INTEGER(w2f__i8) OpenAD_Symbol_361
  INTEGER(w2f__i8) OpenAD_Symbol_362
  INTEGER(w2f__i8) OpenAD_Symbol_363
  INTEGER(w2f__i8) OpenAD_Symbol_364
  INTEGER(w2f__i8) OpenAD_Symbol_365
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) K(1 : 3, 1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) Q(1 : 200)
  REAL(w2f__8) P(1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) V(1 : 3, 1 : 11, 1 : 11, 1 : 3)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) ACOL_INDEX(1 : 1400)
  INTEGER(w2f__i4) ANNZ
  INTEGER(w2f__i4) AROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) AROW_INDEX(1 : 1400)
  REAL(w2f__8) AVALUES(1 : 1400)
  REAL(w2f__8) DIAGS(1 : 200, 1 : 7)
  INTEGER(w2f__i4) I
  REAL(w2f__8) L(1 : 3, 1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) TX(1 : 11, 1 : 10, 1 : 2)
  REAL(w2f__8) TXYZ(1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) TX_
  REAL(w2f__8) TY(1 : 10, 1 : 11, 1 : 2)
  REAL(w2f__8) TY_
  REAL(w2f__8) TZ(1 : 10, 1 : 10, 1 : 3)
  REAL(w2f__8) TZ_
  REAL(w2f__8) U(1 : 200)


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(Q,size(Q),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  do cp_loop_variable_3 = lbound(P,3),ubound(P,3)
  do cp_loop_variable_2 = lbound(P,2),ubound(P,2)
  call cp_store_p_real_vector(P(:,cp_loop_variable_2,cp_loop_variable_3),size(P(&
     &:,cp_loop_variable_2,cp_loop_variable_3)),theArgFStack,theArgFStackoffset,&
     &theArgFStackSize)

  end do
  end do
  do cp_loop_variable_4 = lbound(K,4),ubound(K,4)
  do cp_loop_variable_3 = lbound(K,3),ubound(K,3)
  do cp_loop_variable_2 = lbound(K,2),ubound(K,2)
  call cp_store_p_real_vector(K(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4),size(K(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variabl&
     &e_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_4 = ubound(K,4),lbound(K,4),-1
  do cp_loop_variable_3 = ubound(K,3),lbound(K,3),-1
  do cp_loop_variable_2 = ubound(K,2),lbound(K,2),-1
  do cp_loop_variable_1 = ubound(K,1),lbound(K,1),-1
  K(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable_4)&
     & = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  do cp_loop_variable_3 = ubound(P,3),lbound(P,3),-1
  do cp_loop_variable_2 = ubound(P,2),lbound(P,2),-1
  do cp_loop_variable_1 = ubound(P,1),lbound(P,1),-1
  P(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3) = theArgFStack(the&
     &ArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  do cp_loop_variable_1 = ubound(Q,1),lbound(Q,1),-1
  Q(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  L(1 : 3, 1 : 10, 1 : 10, 1 : 2) = (1.0D00 / K(1 : 3, 1 : 10, 1 : 10, 1 : 2))
  TX_ = 6.09600000000000030731D-01
  TY_ = 2.43840000000000012292D00
  TZ_ = 6.09600000000000008527D+01
  TX(1 : 11, 1 : 10, 1 : 2) = 0.0D00
  TY(1 : 10, 1 : 11, 1 : 2) = 0.0D00
  TZ(1 : 10, 1 : 10, 1 : 3) = 0.0D00
  TX(2 : 10, 1 : 10, 1 : 2) = (TX_ /(L(1, 1 : 9, 1 : 10, 1 : 2) + L(1, 2 : 10, 1&
     & : 10, 1 : 2)))

  TY(1 : 10, 2 : 10, 1 : 2) = (TY_ /(L(2, 1 : 10, 1 : 9, 1 : 2) + L(2, 1 : 10, 2&
     & : 10, 1 : 2)))

  TZ(1 : 10, 1 : 10, 2 : 2) = (TZ_ /(L(3, 1 : 10, 1 : 10, 1 : 1) + L(3, 1 : 10, &
     &1 : 10, 2 : 2)))

  DIAGS(1 : 200, 1 : 7) = 0.0D00
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TX(1 : 10, 1 : 10, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,5))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TY(1 : 10, 1 : 10, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,6))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TZ(1 : 10, 1 : 10, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,7))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TX(2 : 11, 1 : 10, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,3))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TY(1 : 10, 2 : 11, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,2))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TZ(1 : 10, 1 : 10, 2 : 3))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,1))
  DIAGS(1 : 200, 4) = (-(DIAGS(1 : 200, 7) + DIAGS(1 : 200, 6) + DIAGS(1 : 200, &
     &5) + DIAGS(1 : 200, 3) + DIAGS(1 : 200, 1) + DIAGS(1 : 200, 2)))

  CALL SPDIAGS_FVM_CSR(DIAGS,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)
  DO I = 1, ANNZ, 1
    IF((MOD(AROW_INDEX(I), 10) .eq. 1) .AND.(AROW_INDEX(I) .LT. 100)) THEN
      IF(ACOL_INDEX(I) .eq. AROW_INDEX(I)) THEN
        AVALUES(INT(I)) = 1
      ELSE
        AVALUES(INT(I)) = 0
      ENDIF
    ENDIF
  END DO
  CALL SPARSE_SOLVE(ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES,Q,U)
  CALL MYRESHAPE_1_3(U,P)
  V(1, 2 : 10, 1 : 10, 1 : 2) = (TX(2 : 10, 1 : 10, 1 : 2) *(P(1 : 9, 1 : 10, 1 &
     &: 2) - P(2 : 10, 1 : 10, 1 : 2)))

  V(2, 1 : 10, 2 : 10, 1 : 2) = (TY(1 : 10, 2 : 10, 1 : 2) *(P(1 : 10, 1 : 9, 1 &
     &: 2) - P(1 : 10, 2 : 10, 1 : 2)))

  V(3, 1 : 10, 1 : 10, 2 : 2) = (TZ(1 : 10, 1 : 10, 2 : 2) *(P(1 : 10, 1 : 10, 1&
     & : 1) - P(1 : 10, 1 : 10, 2 : 2)))


! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  L(1 : 3, 1 : 10, 1 : 10, 1 : 2) = (1.0D00 / K(1 : 3, 1 : 10, 1 : 10, 1 : 2))
  TX_ = 6.09600000000000030731D-01
  TY_ = 2.43840000000000012292D00
  TZ_ = 6.09600000000000008527D+01
  TX(1 : 11, 1 : 10, 1 : 2) = 0.0D00
  TY(1 : 10, 1 : 11, 1 : 2) = 0.0D00
  TZ(1 : 10, 1 : 10, 1 : 3) = 0.0D00
  TX(2 : 10, 1 : 10, 1 : 2) = (TX_ /(L(1, 1 : 9, 1 : 10, 1 : 2) + L(1, 2 : 10, 1&
     & : 10, 1 : 2)))

  TY(1 : 10, 2 : 10, 1 : 2) = (TY_ /(L(2, 1 : 10, 1 : 9, 1 : 2) + L(2, 1 : 10, 2&
     & : 10, 1 : 2)))

  TZ(1 : 10, 1 : 10, 2 : 2) = (TZ_ /(L(3, 1 : 10, 1 : 10, 1 : 1) + L(3, 1 : 10, &
     &1 : 10, 2 : 2)))

  DIAGS(1 : 200, 1 : 7) = 0.0D00
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TX(1 : 10, 1 : 10, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,5))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TY(1 : 10, 1 : 10, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,6))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TZ(1 : 10, 1 : 10, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,7))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TX(2 : 11, 1 : 10, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,3))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TY(1 : 10, 2 : 11, 1 : 2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,2))
  TXYZ(1 : 10, 1 : 10, 1 : 2) = (- TZ(1 : 10, 1 : 10, 2 : 3))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,1))
  DIAGS(1 : 200, 4) = (-(DIAGS(1 : 200, 7) + DIAGS(1 : 200, 6) + DIAGS(1 : 200, &
     &5) + DIAGS(1 : 200, 3) + DIAGS(1 : 200, 1) + DIAGS(1 : 200, 2)))

  CALL SPDIAGS_FVM_CSR(DIAGS,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)
  OpenAD_Symbol_352 = 0_w2f__i8
  DO I = 1, ANNZ, 1
    IF((MOD(AROW_INDEX(I), 10) .eq. 1) .AND.(AROW_INDEX(I) .LT. 100)) THEN
      IF(ACOL_INDEX(I) .eq. AROW_INDEX(I)) THEN
        AVALUES(INT(I)) = 1
        OpenAD_Symbol_353 = 1_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_353
        integer_tape_pointer = integer_tape_pointer+1
      ELSE
        AVALUES(INT(I)) = 0
        OpenAD_Symbol_354 = 0_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_354
        integer_tape_pointer = integer_tape_pointer+1
      ENDIF
      OpenAD_Symbol_356 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_356
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      OpenAD_Symbol_355 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_355
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    OpenAD_Symbol_352 = (INT(OpenAD_Symbol_352) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_352
  integer_tape_pointer = integer_tape_pointer+1
  CALL SPARSE_SOLVE(ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES,Q,U)
  CALL MYRESHAPE_1_3(U,P)
  V(1, 2 : 10, 1 : 10, 1 : 2) = (TX(2 : 10, 1 : 10, 1 : 2) *(P(1 : 9, 1 : 10, 1 &
     &: 2) - P(2 : 10, 1 : 10, 1 : 2)))

  V(2, 1 : 10, 2 : 10, 1 : 2) = (TY(1 : 10, 2 : 10, 1 : 2) *(P(1 : 10, 1 : 9, 1 &
     &: 2) - P(1 : 10, 2 : 10, 1 : 2)))

  V(3, 1 : 10, 1 : 10, 2 : 2) = (TZ(1 : 10, 1 : 10, 2 : 2) *(P(1 : 10, 1 : 10, 1&
     & : 1) - P(1 : 10, 1 : 10, 2 : 2)))


! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  CALL MYRESHAPE_1_3(U,P)
  CALL SPARSE_SOLVE(ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES,Q,U)
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_348 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_349 = 1
  DO WHILE(INT(OpenAD_Symbol_349) .LE. INT(OpenAD_Symbol_348))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_350 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_350 .ne. 0) THEN
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_351 = integer_tape(integer_tape_pointer)
      IF(OpenAD_Symbol_351 .ne. 0) THEN
      ENDIF
    ENDIF
    OpenAD_Symbol_349 = INT(OpenAD_Symbol_349) + 1
  END DO
  CALL SPDIAGS_FVM_CSR(DIAGS,ANNZ,AROW_INDEX,AROW_COMPRESSED,ACOL_INDEX,AVALUES)
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,1))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,2))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,3))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,7))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,6))
  CALL MYRESHAPE_3_1(TXYZ,DIAGS(1:200,5))

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine TPFA
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SPDIAGS_FVM(IMATRIX, ONNZ, OROW_INDEX, OROW_COMPRESSED, OCOL_INDEX,&
     & OVALUES)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_426
  INTEGER(w2f__i8) OpenAD_Symbol_427
  INTEGER(w2f__i8) OpenAD_Symbol_428
  INTEGER(w2f__i8) OpenAD_Symbol_429
  INTEGER(w2f__i8) OpenAD_Symbol_430
  INTEGER(w2f__i8) OpenAD_Symbol_431
  INTEGER(w2f__i8) OpenAD_Symbol_432
  INTEGER(w2f__i8) OpenAD_Symbol_433
  INTEGER(w2f__i8) OpenAD_Symbol_434
  INTEGER(w2f__i8) OpenAD_Symbol_435
  INTEGER(w2f__i8) OpenAD_Symbol_436
  INTEGER(w2f__i8) OpenAD_Symbol_437
  INTEGER(w2f__i8) OpenAD_Symbol_438
  INTEGER(w2f__i8) OpenAD_Symbol_439
  INTEGER(w2f__i8) OpenAD_Symbol_440
  INTEGER(w2f__i8) OpenAD_Symbol_441
  INTEGER(w2f__i8) OpenAD_Symbol_442
  INTEGER(w2f__i8) OpenAD_Symbol_443
  INTEGER(w2f__i8) OpenAD_Symbol_444
  INTEGER(w2f__i8) OpenAD_Symbol_445
  INTEGER(w2f__i8) OpenAD_Symbol_446
  INTEGER(w2f__i8) OpenAD_Symbol_447
  INTEGER(w2f__i8) OpenAD_Symbol_448
  INTEGER(w2f__i8) OpenAD_Symbol_449
  INTEGER(w2f__i8) OpenAD_Symbol_450
  INTEGER(w2f__i8) OpenAD_Symbol_451
  INTEGER(w2f__i8) OpenAD_Symbol_452
  INTEGER(w2f__i8) OpenAD_Symbol_453
  INTEGER(w2f__i8) OpenAD_Symbol_454
  INTEGER(w2f__i8) OpenAD_Symbol_455
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) IMATRIX(1 : 200, 1 : 7)
  INTEGER(w2f__i4) ONNZ
  INTEGER(w2f__i4) OROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) OROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) OCOL_INDEX(1 : 1400)
  REAL(w2f__8) OVALUES(1 : 1400)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) COL
  INTEGER(w2f__i4) END_ROW_IMATRIX
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) IDIAGS(1 : 7)
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) ROW
  INTEGER(w2f__i4) START_ROW_IMATRIX


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  IDIAGS(1) = (-100)
  IDIAGS(2) = (-10)
  IDIAGS(3) = (-1)
  IDIAGS(4) = 0
  IDIAGS(5) = 1
  IDIAGS(6) = 10
  IDIAGS(7) = 100
  ONNZ = 0
  OROW_COMPRESSED(1 : 201_w2f__i8) = 0
  DO I = 1, 7, 1
    IF(IDIAGS(I) .GT. 0) THEN
      START_ROW_IMATRIX = (IDIAGS(I) + 1)
      END_ROW_IMATRIX = 200
    ELSE
      IF(IDIAGS(I) .LE. 0) THEN
        START_ROW_IMATRIX = 1
        END_ROW_IMATRIX = (IDIAGS(I) + 200)
      ENDIF
    ENDIF
    CALL FIRSTELM(IDIAGS(I),ROW,COL)
    DO J = START_ROW_IMATRIX, END_ROW_IMATRIX, 1
      IF((COL .eq. ROW) .OR.(IMATRIX(J, I) .ne. 0.0D00)) THEN
        ONNZ = (ONNZ + 1)
        OROW_INDEX(ONNZ) = ROW
        OCOL_INDEX(ONNZ) = COL
        OVALUES(INT(ONNZ)) = IMATRIX(J, I)
      ENDIF
      ROW = (ROW + 1)
      COL = (COL + 1)
    END DO
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  IDIAGS(1) = (-100)
  IDIAGS(2) = (-10)
  IDIAGS(3) = (-1)
  IDIAGS(4) = 0
  IDIAGS(5) = 1
  IDIAGS(6) = 10
  IDIAGS(7) = 100
  ONNZ = 0
  OROW_COMPRESSED(1 : 201_w2f__i8) = 0
  OpenAD_Symbol_433 = 0_w2f__i8
  DO I = 1, 7, 1
    IF(IDIAGS(I) .GT. 0) THEN
      START_ROW_IMATRIX = (IDIAGS(I) + 1)
      END_ROW_IMATRIX = 200
      OpenAD_Symbol_436 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_436
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      IF(IDIAGS(I) .LE. 0) THEN
        START_ROW_IMATRIX = 1
        END_ROW_IMATRIX = (IDIAGS(I) + 200)
        OpenAD_Symbol_434 = 1_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_434
        integer_tape_pointer = integer_tape_pointer+1
      ELSE
        OpenAD_Symbol_435 = 0_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_435
        integer_tape_pointer = integer_tape_pointer+1
      ENDIF
      OpenAD_Symbol_437 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_437
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    CALL FIRSTELM(IDIAGS(I),ROW,COL)
    integer_tape(integer_tape_pointer) = I
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_438 = 0_w2f__i8
    DO J = START_ROW_IMATRIX, END_ROW_IMATRIX, 1
      IF((COL .eq. ROW) .OR.(IMATRIX(J, I) .ne. 0.0D00)) THEN
        ONNZ = (ONNZ + 1)
        OVALUES(INT(ONNZ)) = IMATRIX(J, I)
        OROW_INDEX(ONNZ) = ROW
        OCOL_INDEX(ONNZ) = COL
        OpenAD_Symbol_439 = 1_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_439
        integer_tape_pointer = integer_tape_pointer+1
      ELSE
        OpenAD_Symbol_440 = 0_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_440
        integer_tape_pointer = integer_tape_pointer+1
      ENDIF
      ROW = (ROW + 1)
      COL = (COL + 1)
      OpenAD_Symbol_438 = (INT(OpenAD_Symbol_438) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_438
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_433 = (INT(OpenAD_Symbol_433) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_433
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_426 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_427 = 1
  DO WHILE(INT(OpenAD_Symbol_427) .LE. INT(OpenAD_Symbol_426))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_428 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_429 = 1
    DO WHILE(INT(OpenAD_Symbol_429) .LE. INT(OpenAD_Symbol_428))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_430 = integer_tape(integer_tape_pointer)
      IF(OpenAD_Symbol_430 .ne. 0) THEN
      ENDIF
      OpenAD_Symbol_429 = INT(OpenAD_Symbol_429) + 1
    END DO
    integer_tape_pointer = integer_tape_pointer-1
    I = integer_tape(integer_tape_pointer)
    CALL FIRSTELM(IDIAGS(I),ROW,COL)
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_431 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_431 .ne. 0) THEN
    ELSE
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_432 = integer_tape(integer_tape_pointer)
      IF(OpenAD_Symbol_432 .ne. 0) THEN
      ENDIF
    ENDIF
    OpenAD_Symbol_427 = INT(OpenAD_Symbol_427) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SPDIAGS_FVM
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SPDIAGS_FVM_CSR(IMATRIX, ONNZ, OROW_INDEX, OROW_COMPRESSED, OCOL_IN&
     &DEX, OVALUES)

    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_384
  INTEGER(w2f__i8) OpenAD_Symbol_385
  INTEGER(w2f__i8) OpenAD_Symbol_386
  INTEGER(w2f__i8) OpenAD_Symbol_387
  INTEGER(w2f__i8) OpenAD_Symbol_388
  INTEGER(w2f__i8) OpenAD_Symbol_389
  INTEGER(w2f__i8) OpenAD_Symbol_390
  INTEGER(w2f__i8) OpenAD_Symbol_391
  INTEGER(w2f__i8) OpenAD_Symbol_392
  INTEGER(w2f__i8) OpenAD_Symbol_393
  INTEGER(w2f__i8) OpenAD_Symbol_394
  INTEGER(w2f__i8) OpenAD_Symbol_395
  INTEGER(w2f__i8) OpenAD_Symbol_396
  INTEGER(w2f__i8) OpenAD_Symbol_397
  INTEGER(w2f__i8) OpenAD_Symbol_398
  INTEGER(w2f__i8) OpenAD_Symbol_399
  INTEGER(w2f__i8) OpenAD_Symbol_400
  INTEGER(w2f__i8) OpenAD_Symbol_401
  INTEGER(w2f__i8) OpenAD_Symbol_402
  INTEGER(w2f__i8) OpenAD_Symbol_403
  INTEGER(w2f__i8) OpenAD_Symbol_404
  INTEGER(w2f__i8) OpenAD_Symbol_405
  INTEGER(w2f__i8) OpenAD_Symbol_406
  INTEGER(w2f__i8) OpenAD_Symbol_407
  INTEGER(w2f__i8) OpenAD_Symbol_408
  INTEGER(w2f__i8) OpenAD_Symbol_409
  INTEGER(w2f__i8) OpenAD_Symbol_410
  INTEGER(w2f__i8) OpenAD_Symbol_411
  INTEGER(w2f__i8) OpenAD_Symbol_412
  INTEGER(w2f__i8) OpenAD_Symbol_413
  INTEGER(w2f__i8) OpenAD_Symbol_414
  INTEGER(w2f__i8) OpenAD_Symbol_415
  INTEGER(w2f__i8) OpenAD_Symbol_416
  INTEGER(w2f__i8) OpenAD_Symbol_417
  INTEGER(w2f__i8) OpenAD_Symbol_418
  INTEGER(w2f__i8) OpenAD_Symbol_419
  INTEGER(w2f__i8) OpenAD_Symbol_420
  INTEGER(w2f__i8) OpenAD_Symbol_421
  INTEGER(w2f__i8) OpenAD_Symbol_422
  INTEGER(w2f__i8) OpenAD_Symbol_423
  INTEGER(w2f__i8) OpenAD_Symbol_424
  INTEGER(w2f__i8) OpenAD_Symbol_425
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) IMATRIX(1 : 200, 1 : 7)
  INTEGER(w2f__i4) ONNZ
  INTEGER(w2f__i4) OROW_INDEX(1 : 1400)
  INTEGER(w2f__i4) OROW_COMPRESSED(1 : 201)
  INTEGER(w2f__i4) OCOL_INDEX(1 : 1400)
  REAL(w2f__8) OVALUES(1 : 1400)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) COL_DIAG(1 : 7)
  INTEGER(w2f__i4) END_ROW_IMATRIX(1 : 7)
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) IDIAGS(1 : 7)
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) ROWNNZ
  INTEGER(w2f__i4) ROW_DIAG(1 : 7)
  INTEGER(w2f__i4) START_ROW_IMATRIX(1 : 7)


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(ONNZ,theArgIStack,theArgIStackoffset,theArgIStackSize&
     &)

  do cp_loop_variable_2 = lbound(IMATRIX,2),ubound(IMATRIX,2)
  call cp_store_p_real_vector(IMATRIX(:,cp_loop_variable_2),size(IMATRIX(:,cp_lo&
     &op_variable_2)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  call cp_store_int_vector(OROW_COMPRESSED,size(OROW_COMPRESSED),theArgIStack,th&
     &eArgIStackoffset,theArgIStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(OROW_COMPRESSED,1),lbound(OROW_COMPRESSED,1),-1
  OROW_COMPRESSED(cp_loop_variable_1) = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  end do
  do cp_loop_variable_2 = ubound(IMATRIX,2),lbound(IMATRIX,2),-1
  do cp_loop_variable_1 = ubound(IMATRIX,1),lbound(IMATRIX,1),-1
  IMATRIX(cp_loop_variable_1,cp_loop_variable_2) = theArgFStack(theArgFStackoffs&
     &et)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  ONNZ = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  IDIAGS(1) = (-100)
  IDIAGS(2) = (-10)
  IDIAGS(3) = (-1)
  IDIAGS(4) = 0
  IDIAGS(5) = 1
  IDIAGS(6) = 10
  IDIAGS(7) = 100
  ONNZ = 0
  OROW_COMPRESSED(1) = 1
  DO I = 1, 7, 1
    IF(IDIAGS(I) .GT. 0) THEN
      START_ROW_IMATRIX(I) = (IDIAGS(I) + 1)
      END_ROW_IMATRIX(I) = 200
    ELSE
      IF(IDIAGS(I) .LE. 0) THEN
        START_ROW_IMATRIX(I) = 1
        END_ROW_IMATRIX(I) = (IDIAGS(I) + 200)
      ENDIF
    ENDIF
    CALL FIRSTELM(IDIAGS(I),ROW_DIAG(I),COL_DIAG(I))
  END DO
  DO I = 1, 200, 1
    ROWNNZ = 0
    DO J = 1, 7, 1
      IF((END_ROW_IMATRIX(J) .GE. START_ROW_IMATRIX(J)) .AND.( ROW_DIAG(J) .LE. &
     &I)) THEN

        IF(IMATRIX(START_ROW_IMATRIX(J), J) .ne. 0.0D00) THEN
          ONNZ = (ONNZ + 1)
          ROWNNZ = (ROWNNZ + 1)
          OROW_INDEX(ONNZ) = I
          OCOL_INDEX(ONNZ) = COL_DIAG(J)
          OVALUES(INT(ONNZ)) = IMATRIX(START_ROW_IMATRIX(J), J)
        ENDIF
        START_ROW_IMATRIX(J) = (START_ROW_IMATRIX(J) + 1)
        COL_DIAG(J) = (COL_DIAG(J) + 1)
      ENDIF
    END DO
    OROW_COMPRESSED(I + 1) = (OROW_COMPRESSED(I) + ROWNNZ)
  END DO

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  IDIAGS(1) = (-100)
  IDIAGS(2) = (-10)
  IDIAGS(3) = (-1)
  IDIAGS(4) = 0
  IDIAGS(5) = 1
  IDIAGS(6) = 10
  IDIAGS(7) = 100
  ONNZ = 0
  OROW_COMPRESSED(1) = 1
  OpenAD_Symbol_394 = 0_w2f__i8
  DO I = 1, 7, 1
    IF(IDIAGS(I) .GT. 0) THEN
      START_ROW_IMATRIX(I) = (IDIAGS(I) + 1)
      END_ROW_IMATRIX(I) = 200
      OpenAD_Symbol_397 = 1_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_397
      integer_tape_pointer = integer_tape_pointer+1
    ELSE
      IF(IDIAGS(I) .LE. 0) THEN
        START_ROW_IMATRIX(I) = 1
        END_ROW_IMATRIX(I) = (IDIAGS(I) + 200)
        OpenAD_Symbol_395 = 1_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_395
        integer_tape_pointer = integer_tape_pointer+1
      ELSE
        OpenAD_Symbol_396 = 0_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_396
        integer_tape_pointer = integer_tape_pointer+1
      ENDIF
      OpenAD_Symbol_398 = 0_w2f__i8
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_398
      integer_tape_pointer = integer_tape_pointer+1
    ENDIF
    CALL FIRSTELM(IDIAGS(I),ROW_DIAG(I),COL_DIAG(I))
    integer_tape(integer_tape_pointer) = I
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_394 = (INT(OpenAD_Symbol_394) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_394
  integer_tape_pointer = integer_tape_pointer+1
  OpenAD_Symbol_399 = 0_w2f__i8
  DO I = 1, 200, 1
    ROWNNZ = 0
    OpenAD_Symbol_400 = 0_w2f__i8
    DO J = 1, 7, 1
      IF((END_ROW_IMATRIX(J) .GE. START_ROW_IMATRIX(J)) .AND.( ROW_DIAG(J) .LE. &
     &I)) THEN

        IF(IMATRIX(START_ROW_IMATRIX(J), J) .ne. 0.0D00) THEN
          ONNZ = (ONNZ + 1)
          ROWNNZ = (ROWNNZ + 1)
          OVALUES(INT(ONNZ)) = IMATRIX(START_ROW_IMATRIX(J), J)
          OROW_INDEX(ONNZ) = I
          OCOL_INDEX(ONNZ) = COL_DIAG(J)
          OpenAD_Symbol_401 = 1_w2f__i8
          integer_tape(integer_tape_pointer) = OpenAD_Symbol_401
          integer_tape_pointer = integer_tape_pointer+1
        ELSE
          OpenAD_Symbol_402 = 0_w2f__i8
          integer_tape(integer_tape_pointer) = OpenAD_Symbol_402
          integer_tape_pointer = integer_tape_pointer+1
        ENDIF
        START_ROW_IMATRIX(J) = (START_ROW_IMATRIX(J) + 1)
        COL_DIAG(J) = (COL_DIAG(J) + 1)
        OpenAD_Symbol_404 = 1_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_404
        integer_tape_pointer = integer_tape_pointer+1
      ELSE
        OpenAD_Symbol_403 = 0_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_403
        integer_tape_pointer = integer_tape_pointer+1
      ENDIF
      OpenAD_Symbol_400 = (INT(OpenAD_Symbol_400) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_400
    integer_tape_pointer = integer_tape_pointer+1
    OROW_COMPRESSED(I + 1) = (OROW_COMPRESSED(I) + ROWNNZ)
    OpenAD_Symbol_399 = (INT(OpenAD_Symbol_399) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_399
  integer_tape_pointer = integer_tape_pointer+1

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_384 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_385 = 1
  DO WHILE(INT(OpenAD_Symbol_385) .LE. INT(OpenAD_Symbol_384))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_386 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_387 = 1
    DO WHILE(INT(OpenAD_Symbol_387) .LE. INT(OpenAD_Symbol_386))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_388 = integer_tape(integer_tape_pointer)
      IF(OpenAD_Symbol_388 .ne. 0) THEN
        integer_tape_pointer = integer_tape_pointer-1
        OpenAD_Symbol_389 = integer_tape(integer_tape_pointer)
        IF(OpenAD_Symbol_389 .ne. 0) THEN
        ENDIF
      ENDIF
      OpenAD_Symbol_387 = INT(OpenAD_Symbol_387) + 1
    END DO
    OpenAD_Symbol_385 = INT(OpenAD_Symbol_385) + 1
  END DO
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_390 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_391 = 1
  DO WHILE(INT(OpenAD_Symbol_391) .LE. INT(OpenAD_Symbol_390))
    integer_tape_pointer = integer_tape_pointer-1
    I = integer_tape(integer_tape_pointer)
    CALL FIRSTELM(IDIAGS(I),ROW_DIAG(I),COL_DIAG(I))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_392 = integer_tape(integer_tape_pointer)
    IF(OpenAD_Symbol_392 .ne. 0) THEN
    ELSE
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_393 = integer_tape(integer_tape_pointer)
      IF(OpenAD_Symbol_393 .ne. 0) THEN
      ENDIF
    ENDIF
    OpenAD_Symbol_391 = INT(OpenAD_Symbol_391) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SPDIAGS_FVM_CSR
END

MODULE simulation
use OAD_active
use w2f__types
use oad_intrinsics
use parameters
use matrix
use finitevolume
IMPLICIT NONE
SAVE
!
!     **** Statements ****
!
CONTAINS
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE READ_PERMEABILITY_AND_POROSITY(PERM, POR)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_456
  INTEGER(w2f__i8) OpenAD_Symbol_457
  INTEGER(w2f__i8) OpenAD_Symbol_458
  INTEGER(w2f__i8) OpenAD_Symbol_459
  INTEGER(w2f__i8) OpenAD_Symbol_460
  INTEGER(w2f__i8) OpenAD_Symbol_461
  INTEGER(w2f__i8) OpenAD_Symbol_462
  INTEGER(w2f__i8) OpenAD_Symbol_463
  INTEGER(w2f__i8) OpenAD_Symbol_464
  INTEGER(w2f__i8) OpenAD_Symbol_465
  INTEGER(w2f__i8) OpenAD_Symbol_466
  INTEGER(w2f__i8) OpenAD_Symbol_467
  INTEGER(w2f__i8) OpenAD_Symbol_468
  INTEGER(w2f__i8) OpenAD_Symbol_469
  INTEGER(w2f__i8) OpenAD_Symbol_470
  INTEGER(w2f__i8) OpenAD_Symbol_471
  INTEGER(w2f__i8) OpenAD_Symbol_472
  INTEGER(w2f__i8) OpenAD_Symbol_473
  INTEGER(w2f__i8) OpenAD_Symbol_474
  INTEGER(w2f__i8) OpenAD_Symbol_475
  INTEGER(w2f__i8) OpenAD_Symbol_476
  INTEGER(w2f__i8) OpenAD_Symbol_477
  INTEGER(w2f__i8) OpenAD_Symbol_478
  INTEGER(w2f__i8) OpenAD_Symbol_479
  INTEGER(w2f__i8) OpenAD_Symbol_480
  INTEGER(w2f__i8) OpenAD_Symbol_481
  INTEGER(w2f__i8) OpenAD_Symbol_482
  INTEGER(w2f__i8) OpenAD_Symbol_483
  INTEGER(w2f__i8) OpenAD_Symbol_484
  INTEGER(w2f__i8) OpenAD_Symbol_485
  INTEGER(w2f__i8) OpenAD_Symbol_486
  INTEGER(w2f__i8) OpenAD_Symbol_487
  INTEGER(w2f__i8) OpenAD_Symbol_488
  INTEGER(w2f__i8) OpenAD_Symbol_489
  INTEGER(w2f__i8) OpenAD_Symbol_490
  INTEGER(w2f__i8) OpenAD_Symbol_491
  INTEGER(w2f__i8) OpenAD_Symbol_492
  INTEGER(w2f__i8) OpenAD_Symbol_493
  INTEGER(w2f__i8) OpenAD_Symbol_494
  INTEGER(w2f__i8) OpenAD_Symbol_495
  INTEGER(w2f__i8) OpenAD_Symbol_496
  INTEGER(w2f__i8) OpenAD_Symbol_497
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) PERM(1 : 3, 1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) POR(1 : 200)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) K
  INTEGER(w2f__i4) KINDICES(1 : 600)
  REAL(w2f__8) KUR(1 : 180, 1 : 18700)
  REAL(w2f__8) KURL(1 : 3366000)
  INTEGER(w2f__i4) L
  INTEGER(w2f__i4) M
  REAL(w2f__8) OAD_CTMP0
  INTEGER(w2f__i4) PINDICES(1 : 200)
  REAL(w2f__8) PUR(1 : 1122000)
  CHARACTER(4) t__144
  CHARACTER(4) t__145


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  PERM(1 : 3, 1 : 10, 1 : 10, 1 : 2) = 0.0D00
  POR(1 : 200) = 0.0D00
!       open(1,file=permeability_file,status='old')
  t__144 = 'OLD '
  OPEN(UNIT = 1, STATUS = t__144(1_w2f__i8 : 3), FILE = '../data/data_1/KUr.txt'&
     &)

  READ(1,*) ((KUR(I,J),J=1,18700,1),I=1,180,1)
!       close(1)
  CLOSE(UNIT = 1)
  CALL MYRESHAPE_2_1(KUR,KURL)
  M = 0
  DO L = 1, 2, 1
    DO K = 1, 10, 1
      DO J = 1, 10, 1
        DO I = 1, 3, 1
          M = (M + 1)
          KINDICES(M) = (I + K * 180 + L * 39600 + J * 3 +(-39783 ))
        END DO
      END DO
    END DO
  END DO
  CALL MYRESHAPE_1_4(KURL(KINDICES),PERM)
!       open(1,file=porosity_file,status='old')
  t__145 = 'OLD '
  OPEN(UNIT = 1, STATUS = t__145(1_w2f__i8 : 3), FILE = '../data/data_1/pUr.txt'&
     &)

  READ(1,*) (PUR(I),I=1,1122000,1)
!       close(1)
  CLOSE(UNIT = 1)
  M = 0
  DO K = 1, 2, 1
    DO J = 1, 10, 1
      DO I = 1, 10, 1
        M = (M + 1)
        PINDICES(M) = (I + J * 60 + K * 13200 +(-13260))
      END DO
    END DO
  END DO
  OAD_CTMP0 = 1.00000000000000002082D-03
  CALL MYMAX_1_0_DOUBLE(PUR(PINDICES),OAD_CTMP0,POR)

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  PERM(1 : 3, 1 : 10, 1 : 10, 1 : 2) = 0.0D00
  POR(1 : 200) = 0.0D00
!       open(1,file=permeability_file,status='old')
  t__144 = 'OLD '
  OPEN(UNIT = 1, STATUS = t__144(1_w2f__i8 : 3), FILE = '../data/data_1/KUr.txt'&
     &)

  READ(1,*) ((KUR(I,J),J=1,18700,1),I=1,180,1)
!       close(1)
  CLOSE(UNIT = 1)
  CALL MYRESHAPE_2_1(KUR,KURL)
  M = 0
  OpenAD_Symbol_470 = 0_w2f__i8
  DO L = 1, 2, 1
    OpenAD_Symbol_471 = 0_w2f__i8
    DO K = 1, 10, 1
      OpenAD_Symbol_472 = 0_w2f__i8
      DO J = 1, 10, 1
        OpenAD_Symbol_473 = 0_w2f__i8
        DO I = 1, 3, 1
          M = (M + 1)
          KINDICES(M) = (I + K * 180 + L * 39600 + J * 3 +(-39783 ))
          OpenAD_Symbol_473 = (INT(OpenAD_Symbol_473) + INT( 1_w2f__i8))
        END DO
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_473
        integer_tape_pointer = integer_tape_pointer+1
        OpenAD_Symbol_472 = (INT(OpenAD_Symbol_472) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_472
      integer_tape_pointer = integer_tape_pointer+1
      OpenAD_Symbol_471 = (INT(OpenAD_Symbol_471) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_471
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_470 = (INT(OpenAD_Symbol_470) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_470
  integer_tape_pointer = integer_tape_pointer+1
  CALL MYRESHAPE_1_4(KURL(KINDICES),PERM)
  integer_tape(integer_tape_pointer:integer_tape_pointer+size(KINDICES)-1) = KIN&
     &DICES(:)

  integer_tape_pointer = integer_tape_pointer+size(KINDICES)
!       open(1,file=porosity_file,status='old')
  t__145 = 'OLD '
  OPEN(UNIT = 1, STATUS = t__145(1_w2f__i8 : 3), FILE = '../data/data_1/pUr.txt'&
     &)

  READ(1,*) (PUR(I),I=1,1122000,1)
!       close(1)
  CLOSE(UNIT = 1)
  M = 0
  OpenAD_Symbol_474 = 0_w2f__i8
  DO K = 1, 2, 1
    OpenAD_Symbol_475 = 0_w2f__i8
    DO J = 1, 10, 1
      OpenAD_Symbol_476 = 0_w2f__i8
      DO I = 1, 10, 1
        M = (M + 1)
        PINDICES(M) = (I + J * 60 + K * 13200 +(-13260))
        OpenAD_Symbol_476 = (INT(OpenAD_Symbol_476) + INT( 1_w2f__i8))
      END DO
      integer_tape(integer_tape_pointer) = OpenAD_Symbol_476
      integer_tape_pointer = integer_tape_pointer+1
      OpenAD_Symbol_475 = (INT(OpenAD_Symbol_475) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_475
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_474 = (INT(OpenAD_Symbol_474) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_474
  integer_tape_pointer = integer_tape_pointer+1
  OAD_CTMP0 = 1.00000000000000002082D-03
  CALL MYMAX_1_0_DOUBLE(PUR(PINDICES),OAD_CTMP0,POR)
  integer_tape(integer_tape_pointer:integer_tape_pointer+size(PINDICES)-1) = PIN&
     &DICES(:)

  integer_tape_pointer = integer_tape_pointer+size(PINDICES)

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-size(PINDICES,1)
  PINDICES(:) = integer_tape(integer_tape_pointer:integer_tape_pointer+size(PIND&
     &ICES,1)-1)

  CALL MYMAX_1_0_DOUBLE(PUR(PINDICES),OAD_CTMP0,POR)
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_456 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_457 = 1
  DO WHILE(INT(OpenAD_Symbol_457) .LE. INT(OpenAD_Symbol_456))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_458 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_459 = 1
    DO WHILE(INT(OpenAD_Symbol_459) .LE. INT(OpenAD_Symbol_458))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_460 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_461 = 1
      DO WHILE(INT(OpenAD_Symbol_461) .LE. INT(OpenAD_Symbol_460) )
        OpenAD_Symbol_461 = INT(OpenAD_Symbol_461) + 1
      END DO
      OpenAD_Symbol_459 = INT(OpenAD_Symbol_459) + 1
    END DO
    OpenAD_Symbol_457 = INT(OpenAD_Symbol_457) + 1
  END DO
  integer_tape_pointer = integer_tape_pointer-size(KINDICES,1)
  KINDICES(:) = integer_tape(integer_tape_pointer:integer_tape_pointer+size(KIND&
     &ICES,1)-1)

  CALL MYRESHAPE_1_4(KURL(KINDICES),PERM)
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_462 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_463 = 1
  DO WHILE(INT(OpenAD_Symbol_463) .LE. INT(OpenAD_Symbol_462))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_464 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_465 = 1
    DO WHILE(INT(OpenAD_Symbol_465) .LE. INT(OpenAD_Symbol_464))
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_466 = integer_tape(integer_tape_pointer)
      OpenAD_Symbol_467 = 1
      DO WHILE(INT(OpenAD_Symbol_467) .LE. INT(OpenAD_Symbol_466) )
        integer_tape_pointer = integer_tape_pointer-1
        OpenAD_Symbol_468 = integer_tape(integer_tape_pointer)
        OpenAD_Symbol_469 = 1
        DO WHILE(INT(OpenAD_Symbol_469) .LE. INT( OpenAD_Symbol_468))
          OpenAD_Symbol_469 = INT(OpenAD_Symbol_469) + 1
        END DO
        OpenAD_Symbol_467 = INT(OpenAD_Symbol_467) + 1
      END DO
      OpenAD_Symbol_465 = INT(OpenAD_Symbol_465) + 1
    END DO
    OpenAD_Symbol_463 = INT(OpenAD_Symbol_463) + 1
  END DO
  CALL MYRESHAPE_2_1(KUR,KURL)

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine READ_PERMEABILITY_AND_POROSITY
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT(MU, SIGMA, Q)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_498
  INTEGER(w2f__i8) OpenAD_Symbol_499
  INTEGER(w2f__i8) OpenAD_Symbol_500
  INTEGER(w2f__i8) OpenAD_Symbol_501
  INTEGER(w2f__i8) OpenAD_Symbol_502
  INTEGER(w2f__i8) OpenAD_Symbol_503
  INTEGER(w2f__i8) OpenAD_Symbol_504
  INTEGER(w2f__i8) OpenAD_Symbol_505
  INTEGER(w2f__i8) OpenAD_Symbol_506
  INTEGER(w2f__i8) OpenAD_Symbol_507
  INTEGER(w2f__i8) OpenAD_Symbol_508
  INTEGER(w2f__i8) OpenAD_Symbol_509
  INTEGER(w2f__i8) OpenAD_Symbol_510
  INTEGER(w2f__i8) OpenAD_Symbol_511
  INTEGER(w2f__i8) OpenAD_Symbol_512
  INTEGER(w2f__i8) OpenAD_Symbol_513
  INTEGER(w2f__i8) OpenAD_Symbol_514
  INTEGER(w2f__i8) OpenAD_Symbol_515
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) MU
  REAL(w2f__8) SIGMA
  REAL(w2f__8) Q(1 : 200)
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  REAL(w2f__8) IDX(1 : 10)
  INTEGER(w2f__i4) J
  REAL(w2f__8) MASS
  REAL(w2f__8) PDF
  REAL(w2f__8) PI
  REAL(w2f__8) Q_X(1 : 10)
  REAL(w2f__8) X


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_real_scalar(MU,theArgFStack,theArgFStackoffset,theArgFStackSize)
  call cp_store_real_scalar(SIGMA,theArgFStack,theArgFStackoffset,theArgFStackSi&
     &ze)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  SIGMA = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  MU = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  PI = 3.141592653589793116D00
  MASS = 0.0D00
  Q_X(1 : 10) = 0.0D00
  DO I = 1, 10, 1
    X = ((((I +(-1)) * 3.0D00) / 9.0D00) +(-1.5D00))
    PDF = (EXP((((X - MU) / SIGMA) ** 2.0D00) *(-5.0D-01)) *( 1.0D00 /(SIGMA * S&
     &QRT(PI * 2.0D00))))

    Q_X(INT(I)) = PDF
    MASS = (MASS + PDF)
    IDX(INT(I)) = I
  END DO
  DO I = 1, 10, 1
    Q_X(INT(I)) = ((Q_X(I) / MASS) * 1.4171123504638671875D-01)
  END DO
  J = 1
  DO I = 1, 100, 10
    Q(INT(I)) = Q_X(J)
    J = (J + 1)
  END DO
  Q(200) = (-1.4171123504638671875D-01)

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  PI = 3.141592653589793116D00
  MASS = 0.0D00
  Q_X(1 : 10) = 0.0D00
  OpenAD_Symbol_504 = 0_w2f__i8
  DO I = 1, 10, 1
    X = ((((I +(-1)) * 3.0D00) / 9.0D00) +(-1.5D00))
    PDF = (EXP((((X - MU) / SIGMA) ** 2.0D00) *(-5.0D-01)) *( 1.0D00 /(SIGMA * S&
     &QRT(PI * 2.0D00))))

    Q_X(INT(I)) = PDF
    MASS = (MASS + PDF)
    IDX(INT(I)) = I
    OpenAD_Symbol_504 = (INT(OpenAD_Symbol_504) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_504
  integer_tape_pointer = integer_tape_pointer+1
  OpenAD_Symbol_505 = 0_w2f__i8
  DO I = 1, 10, 1
    Q_X(INT(I)) = ((Q_X(I) / MASS) * 1.4171123504638671875D-01)
    OpenAD_Symbol_505 = (INT(OpenAD_Symbol_505) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_505
  integer_tape_pointer = integer_tape_pointer+1
  J = 1
  OpenAD_Symbol_506 = 0_w2f__i8
  DO I = 1, 100, 10
    Q(INT(I)) = Q_X(J)
    J = (J + 1)
    OpenAD_Symbol_506 = (INT(OpenAD_Symbol_506) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_506
  integer_tape_pointer = integer_tape_pointer+1
  Q(200) = (-1.4171123504638671875D-01)

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_498 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_499 = 1
  DO WHILE(INT(OpenAD_Symbol_499) .LE. INT(OpenAD_Symbol_498))
    OpenAD_Symbol_499 = INT(OpenAD_Symbol_499) + 1
  END DO
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_500 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_501 = 1
  DO WHILE(INT(OpenAD_Symbol_501) .LE. INT(OpenAD_Symbol_500))
    OpenAD_Symbol_501 = INT(OpenAD_Symbol_501) + 1
  END DO
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_502 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_503 = 1
  DO WHILE(INT(OpenAD_Symbol_503) .LE. INT(OpenAD_Symbol_502))
    OpenAD_Symbol_503 = INT(OpenAD_Symbol_503) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine INIT_FLW_TRNC_NORM_XIN_PT_OUT
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE SIMULATE_RESERVOIR(Q, S, P, V, TT, PC, OIL)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  use parameters
  use parameters
  use parameters
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_516
  INTEGER(w2f__i8) OpenAD_Symbol_517
  INTEGER(w2f__i8) OpenAD_Symbol_518
  INTEGER(w2f__i8) OpenAD_Symbol_519
  INTEGER(w2f__i8) OpenAD_Symbol_520
  INTEGER(w2f__i8) OpenAD_Symbol_521
  INTEGER(w2f__i8) OpenAD_Symbol_522
  INTEGER(w2f__i8) OpenAD_Symbol_523
  INTEGER(w2f__i8) OpenAD_Symbol_524
  INTEGER(w2f__i8) OpenAD_Symbol_525
  INTEGER(w2f__i8) OpenAD_Symbol_526
  INTEGER(w2f__i8) OpenAD_Symbol_527
  INTEGER(w2f__i8) OpenAD_Symbol_528
  INTEGER(w2f__i8) OpenAD_Symbol_529
  INTEGER(w2f__i8) OpenAD_Symbol_530
  INTEGER(w2f__i8) OpenAD_Symbol_531
  INTEGER(w2f__i8) OpenAD_Symbol_532
  INTEGER(w2f__i8) OpenAD_Symbol_533
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) Q(1 : 200)
  REAL(w2f__8) S(1 : 200)
  REAL(w2f__8) P(1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) V(1 : 3, 1 : 11, 1 : 11, 1 : 3)
  REAL(w2f__8) TT(1 : 401)
  REAL(w2f__8) PC(1 : 2, 1 : 401)
  REAL(w2f__8) OIL
!
!       **** Local Variables and Functions ****
!
  INTEGER(w2f__i4) I
  INTEGER(w2f__i4) J
  INTEGER(w2f__i4) K
  REAL(w2f__8) MO
  REAL(w2f__8) MT
  REAL(w2f__8) MW
  INTEGER(w2f__i4) OAD_CTMP0
  INTEGER(w2f__i4) OAD_CTMP1
  INTEGER(w2f__i4) OAD_CTMP2
  REAL(w2f__8) TEMPOIL1
  REAL(w2f__8) TEMPOIL2


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(Q,size(Q),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  call cp_store_p_real_vector(S,size(S),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  do cp_loop_variable_3 = lbound(P,3),ubound(P,3)
  do cp_loop_variable_2 = lbound(P,2),ubound(P,2)
  call cp_store_p_real_vector(P(:,cp_loop_variable_2,cp_loop_variable_3),size(P(&
     &:,cp_loop_variable_2,cp_loop_variable_3)),theArgFStack,theArgFStackoffset,&
     &theArgFStackSize)

  end do
  end do
  do cp_loop_variable_4 = lbound(V,4),ubound(V,4)
  do cp_loop_variable_3 = lbound(V,3),ubound(V,3)
  do cp_loop_variable_2 = lbound(V,2),ubound(V,2)
  call cp_store_p_real_vector(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4),size(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variabl&
     &e_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
  do cp_loop_variable_2 = lbound(PC,2),ubound(PC,2)
  call cp_store_p_real_vector(PC(:,cp_loop_variable_2),size(PC(:,cp_loop_variabl&
     &e_2)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  do cp_loop_variable_4 = lbound(PERM,4),ubound(PERM,4)
  do cp_loop_variable_3 = lbound(PERM,3),ubound(PERM,3)
  do cp_loop_variable_2 = lbound(PERM,2),ubound(PERM,2)
  call cp_store_p_real_vector(PERM(:,cp_loop_variable_2,cp_loop_variable_3,cp_lo&
     &op_variable_4),size(PERM(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_v&
     &ariable_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
  call cp_store_p_real_vector(POR,size(POR),theArgFStack,theArgFStackoffset,theA&
     &rgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(POR,1),lbound(POR,1),-1
  POR(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_4 = ubound(PERM,4),lbound(PERM,4),-1
  do cp_loop_variable_3 = ubound(PERM,3),lbound(PERM,3),-1
  do cp_loop_variable_2 = ubound(PERM,2),lbound(PERM,2),-1
  do cp_loop_variable_1 = ubound(PERM,1),lbound(PERM,1),-1
  PERM(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable&
     &_4) = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  do cp_loop_variable_2 = ubound(PC,2),lbound(PC,2),-1
  do cp_loop_variable_1 = ubound(PC,1),lbound(PC,1),-1
  PC(cp_loop_variable_1,cp_loop_variable_2) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  do cp_loop_variable_4 = ubound(V,4),lbound(V,4),-1
  do cp_loop_variable_3 = ubound(V,3),lbound(V,3),-1
  do cp_loop_variable_2 = ubound(V,2),lbound(V,2),-1
  do cp_loop_variable_1 = ubound(V,1),lbound(V,1),-1
  V(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable_4)&
     & = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  do cp_loop_variable_3 = ubound(P,3),lbound(P,3),-1
  do cp_loop_variable_2 = ubound(P,2),lbound(P,2),-1
  do cp_loop_variable_1 = ubound(P,1),lbound(P,1),-1
  P(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3) = theArgFStack(the&
     &ArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  do cp_loop_variable_1 = ubound(S,1),lbound(S,1),-1
  S(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(Q,1),lbound(Q,1),-1
  Q(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  S(1 : 200) = 2.00000000000000011102D-01
  PC(1, 1) = 0.0D00
  PC(2, 1) = 1.0D00
  TT(1) = 0.0D00
  TEMPOIL1 = 0.0D00
  TEMPOIL2 = 0.0D00
  K = 1
  DO I = 1, 20, 1
    DO J = 1, 20, 1
      K = (K + 1)
      IF(J .eq. 1) THEN
        OAD_CTMP0 = 1
        CALL STEPFORWARD(OAD_CTMP0,Q,S,P,V,MW,MO)
      ELSE
        OAD_CTMP1 = 0
        CALL STEPFORWARD(OAD_CTMP1,Q,S,P,V,MW,MO)
      ENDIF
      MT = (MO + MW)
      TT(INT(K)) = (K * 5.0D00)
      PC(1, INT(K)) = (MW / MT)
      PC(2, INT(K)) = (MO / MT)
      OAD_CTMP2 = 5
      CALL UPDATE_OIL(PC,K,OAD_CTMP2,TEMPOIL1,TEMPOIL2)
      TEMPOIL1 = TEMPOIL2
    END DO
  END DO
  OIL = TEMPOIL2

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  S(1 : 200) = 2.00000000000000011102D-01
  PC(1, 1) = 0.0D00
  PC(2, 1) = 1.0D00
  TT(1) = 0.0D00
  TEMPOIL1 = 0.0D00
  TEMPOIL2 = 0.0D00
  K = 1
  OpenAD_Symbol_521 = 0_w2f__i8
  DO I = 1, 20, 1
    OpenAD_Symbol_522 = 0_w2f__i8
    DO J = 1, 20, 1
      K = (K + 1)
      IF(J .eq. 1) THEN
        OAD_CTMP0 = 1
        CALL STEPFORWARD(OAD_CTMP0,Q,S,P,V,MW,MO)
        OpenAD_Symbol_523 = 1_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_523
        integer_tape_pointer = integer_tape_pointer+1
      ELSE
        OAD_CTMP1 = 0
        CALL STEPFORWARD(OAD_CTMP1,Q,S,P,V,MW,MO)
        OpenAD_Symbol_524 = 0_w2f__i8
        integer_tape(integer_tape_pointer) = OpenAD_Symbol_524
        integer_tape_pointer = integer_tape_pointer+1
      ENDIF
      MT = (MO + MW)
      TT(INT(K)) = (K * 5.0D00)
      PC(1, INT(K)) = (MW / MT)
      PC(2, INT(K)) = (MO / MT)
      OAD_CTMP2 = 5
      CALL UPDATE_OIL(PC,K,OAD_CTMP2,TEMPOIL1,TEMPOIL2)
      integer_tape(integer_tape_pointer) = OAD_CTMP2
      integer_tape_pointer = integer_tape_pointer+1
      TEMPOIL1 = TEMPOIL2
      OpenAD_Symbol_522 = (INT(OpenAD_Symbol_522) + INT(1_w2f__i8 ))
    END DO
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_522
    integer_tape_pointer = integer_tape_pointer+1
    OpenAD_Symbol_521 = (INT(OpenAD_Symbol_521) + INT(1_w2f__i8))
  END DO
  integer_tape(integer_tape_pointer) = OpenAD_Symbol_521
  integer_tape_pointer = integer_tape_pointer+1
  OIL = TEMPOIL2

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_516 = integer_tape(integer_tape_pointer)
  OpenAD_Symbol_517 = 1
  DO WHILE(INT(OpenAD_Symbol_517) .LE. INT(OpenAD_Symbol_516))
    integer_tape_pointer = integer_tape_pointer-1
    OpenAD_Symbol_518 = integer_tape(integer_tape_pointer)
    OpenAD_Symbol_519 = 1
    DO WHILE(INT(OpenAD_Symbol_519) .LE. INT(OpenAD_Symbol_518))
      integer_tape_pointer = integer_tape_pointer-1
      OAD_CTMP2 = integer_tape(integer_tape_pointer)
      CALL UPDATE_OIL(PC,K,OAD_CTMP2,TEMPOIL1,TEMPOIL2)
      integer_tape_pointer = integer_tape_pointer-1
      OpenAD_Symbol_520 = integer_tape(integer_tape_pointer)
      IF(OpenAD_Symbol_520 .ne. 0) THEN
        CALL STEPFORWARD(OAD_CTMP0,Q,S,P,V,MW,MO)
      ELSE
        CALL STEPFORWARD(OAD_CTMP1,Q,S,P,V,MW,MO)
      ENDIF
      OpenAD_Symbol_519 = INT(OpenAD_Symbol_519) + 1
    END DO
    OpenAD_Symbol_517 = INT(OpenAD_Symbol_517) + 1
  END DO

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine SIMULATE_RESERVOIR
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE STEPFORWARD(PRESSURE_STEP, Q, S, P, V, MW, MO)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Global Variables & Derived Type Definitions ****
!
  INTEGER(w2f__i8) OpenAD_Symbol_534
  INTEGER(w2f__i8) OpenAD_Symbol_535
  INTEGER(w2f__i8) OpenAD_Symbol_536
  INTEGER(w2f__i8) OpenAD_Symbol_537
  INTEGER(w2f__i8) OpenAD_Symbol_538
  INTEGER(w2f__i8) OpenAD_Symbol_539
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) PRESSURE_STEP
  REAL(w2f__8) Q(1 : 200)
  REAL(w2f__8) S(1 : 200)
  REAL(w2f__8) P(1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) V(1 : 3, 1 : 11, 1 : 11, 1 : 3)
  REAL(w2f__8) MW
  REAL(w2f__8) MO


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_p_real_vector(Q,size(Q),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  call cp_store_p_real_vector(S,size(S),theArgFStack,theArgFStackoffset,theArgFS&
     &tackSize)

  do cp_loop_variable_3 = lbound(P,3),ubound(P,3)
  do cp_loop_variable_2 = lbound(P,2),ubound(P,2)
  call cp_store_p_real_vector(P(:,cp_loop_variable_2,cp_loop_variable_3),size(P(&
     &:,cp_loop_variable_2,cp_loop_variable_3)),theArgFStack,theArgFStackoffset,&
     &theArgFStackSize)

  end do
  end do
  do cp_loop_variable_4 = lbound(V,4),ubound(V,4)
  do cp_loop_variable_3 = lbound(V,3),ubound(V,3)
  do cp_loop_variable_2 = lbound(V,2),ubound(V,2)
  call cp_store_p_real_vector(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4),size(V(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variabl&
     &e_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
  call cp_store_real_scalar(MW,theArgFStack,theArgFStackoffset,theArgFStackSize)
  call cp_store_real_scalar(MO,theArgFStack,theArgFStackoffset,theArgFStackSize)
  call cp_store_int_scalar(PRESSURE_STEP,theArgIStack,theArgIStackoffset,theArgI&
     &StackSize)

  do cp_loop_variable_4 = lbound(PERM,4),ubound(PERM,4)
  do cp_loop_variable_3 = lbound(PERM,3),ubound(PERM,3)
  do cp_loop_variable_2 = lbound(PERM,2),ubound(PERM,2)
  call cp_store_p_real_vector(PERM(:,cp_loop_variable_2,cp_loop_variable_3,cp_lo&
     &op_variable_4),size(PERM(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_v&
     &ariable_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
  call cp_store_p_real_vector(POR,size(POR),theArgFStack,theArgFStackoffset,theA&
     &rgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(POR,1),lbound(POR,1),-1
  POR(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_4 = ubound(PERM,4),lbound(PERM,4),-1
  do cp_loop_variable_3 = ubound(PERM,3),lbound(PERM,3),-1
  do cp_loop_variable_2 = ubound(PERM,2),lbound(PERM,2),-1
  do cp_loop_variable_1 = ubound(PERM,1),lbound(PERM,1),-1
  PERM(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable&
     &_4) = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  PRESSURE_STEP = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  MO = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  MW = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  do cp_loop_variable_4 = ubound(V,4),lbound(V,4),-1
  do cp_loop_variable_3 = ubound(V,3),lbound(V,3),-1
  do cp_loop_variable_2 = ubound(V,2),lbound(V,2),-1
  do cp_loop_variable_1 = ubound(V,1),lbound(V,1),-1
  V(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable_4)&
     & = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
  do cp_loop_variable_3 = ubound(P,3),lbound(P,3),-1
  do cp_loop_variable_2 = ubound(P,2),lbound(P,2),-1
  do cp_loop_variable_1 = ubound(P,1),lbound(P,1),-1
  P(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3) = theArgFStack(the&
     &ArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  do cp_loop_variable_1 = ubound(S,1),lbound(S,1),-1
  S(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_1 = ubound(Q,1),lbound(Q,1),-1
  Q(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  IF(PRESSURE_STEP .eq. 1) THEN
    CALL PRES(Q,S,P,V)
  ENDIF
  CALL NEWTRAPH(Q,V,S)
  CALL RELPERM_SCALAR(S(200),MW,MO)

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  IF(PRESSURE_STEP .eq. 1) THEN
    CALL PRES(Q,S,P,V)
    OpenAD_Symbol_535 = 1_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_535
    integer_tape_pointer = integer_tape_pointer+1
  ELSE
    OpenAD_Symbol_536 = 0_w2f__i8
    integer_tape(integer_tape_pointer) = OpenAD_Symbol_536
    integer_tape_pointer = integer_tape_pointer+1
  ENDIF
  CALL NEWTRAPH(Q,V,S)
  CALL RELPERM_SCALAR(S(200),MW,MO)

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  CALL RELPERM_SCALAR(S(200),MW,MO)
  CALL NEWTRAPH(Q,V,S)
  integer_tape_pointer = integer_tape_pointer-1
  OpenAD_Symbol_534 = integer_tape(integer_tape_pointer)
  IF(OpenAD_Symbol_534 .ne. 0) THEN
    CALL PRES(Q,S,P,V)
  ENDIF

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine STEPFORWARD
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE UPDATE_OIL(PC, K, ST, OILIN, OILOUT)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Parameters and Result ****
!
  INTEGER(w2f__i4) K
  INTEGER(w2f__i4) ST
  REAL(w2f__8) OILIN
  REAL(w2f__8) OILOUT
  REAL(w2f__8) PC(1 : 2, 1 : INT(((2000 / ST) + 1)))


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  call cp_store_int_scalar(K,theArgIStack,theArgIStackoffset,theArgIStackSize)
  call cp_store_int_scalar(ST,theArgIStack,theArgIStackoffset,theArgIStackSize)
  call cp_store_real_scalar(OILIN,theArgFStack,theArgFStackoffset,theArgFStackSi&
     &ze)

  do cp_loop_variable_2 = lbound(PC,2),ubound(PC,2)
  call cp_store_p_real_vector(PC(:,cp_loop_variable_2),size(PC(:,cp_loop_variabl&
     &e_2)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_2 = ubound(PC,2),lbound(PC,2),-1
  do cp_loop_variable_1 = ubound(PC,1),lbound(PC,1),-1
  PC(cp_loop_variable_1,cp_loop_variable_2) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  OILIN = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  ST = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
  K = theArgIStack(theArgIStackoffset)
  theArgIStackoffset = theArgIStackoffset-1
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  OILOUT = (OILIN + ST * PC(2, K))

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  OILOUT = (OILIN + ST * PC(2, K))

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine UPDATE_OIL
!#########################################################
! This file is part of OpenAD released under the LGPL.   #
! The full COPYRIGHT notice can be found in the top      #
! level directory of the OpenAD distribution             #
!#########################################################

  SUBROUTINE WRAPPER(MU, SIGMA, Q, S, P, V, TT, PC, OIL)
    use OAD_tape
    use OAD_rev
    use OAD_cp

! original arguments get inserted before version
!         ! and declared here together with all local variables
!         ! generated by xaifBooster

  use w2f__types
  IMPLICIT NONE
!
!       **** Parameters and Result ****
!
  REAL(w2f__8) MU
  REAL(w2f__8) SIGMA
  REAL(w2f__8) Q(1 : 200)
  REAL(w2f__8) S(1 : 200)
  REAL(w2f__8) P(1 : 10, 1 : 10, 1 : 2)
  REAL(w2f__8) V(1 : 3, 1 : 11, 1 : 11, 1 : 3)
  REAL(w2f__8) TT(1 : 401)
  REAL(w2f__8) PC(1 : 2, 1 : 401)
  REAL(w2f__8) OIL


! checkpointing stacks and offsets
    integer :: cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_&
     &variable_4,cp_loop_variable_5,cp_loop_variable_6


! floats 'F'
    double precision, dimension(:), allocatable, save :: theArgFStack
    integer, save :: theArgFStackoffset=0, theArgFStackSize=0
! integers 'I'
    integer, dimension(:), allocatable, save :: theArgIStack
    integer, save :: theArgIStackoffset=0, theArgIStackSize=0
! booleans 'B'
    logical, dimension(:), allocatable, save :: theArgBStack
    integer, save :: theArgBStackoffset=0, theArgBStackSize=0
! strings 'S'
    character*(80), dimension(:), allocatable, save :: theArgSStack
    integer, save :: theArgSStackoffset=0, theArgSStackSize=0

    type(modeType) :: our_orig_mode

! external C function used in inlined code
    integer iaddr
    external iaddr
!
!       **** Top Level Pragmas ****
!
!$OPENAD INDEPENDENT(MU)
!$OPENAD DEPENDENT(OIL)
!
!       **** Statements ****
!

    if (our_rev_mode%arg_store) then
! store arguments
  do cp_loop_variable_4 = lbound(PERM,4),ubound(PERM,4)
  do cp_loop_variable_3 = lbound(PERM,3),ubound(PERM,3)
  do cp_loop_variable_2 = lbound(PERM,2),ubound(PERM,2)
  call cp_store_p_real_vector(PERM(:,cp_loop_variable_2,cp_loop_variable_3,cp_lo&
     &op_variable_4),size(PERM(:,cp_loop_variable_2,cp_loop_variable_3,cp_loop_v&
     &ariable_4)),theArgFStack,theArgFStackoffset,theArgFStackSize)

  end do
  end do
  end do
  call cp_store_p_real_vector(POR,size(POR),theArgFStack,theArgFStackoffset,theA&
     &rgFStackSize)

    end if
    if (our_rev_mode%arg_restore) then
! restore arguments
  do cp_loop_variable_1 = ubound(POR,1),lbound(POR,1),-1
  POR(cp_loop_variable_1) = theArgFStack(theArgFStackoffset)
  theArgFStackoffset = theArgFStackoffset-1
  end do
  do cp_loop_variable_4 = ubound(PERM,4),lbound(PERM,4),-1
  do cp_loop_variable_3 = ubound(PERM,3),lbound(PERM,3),-1
  do cp_loop_variable_2 = ubound(PERM,2),lbound(PERM,2),-1
  do cp_loop_variable_1 = ubound(PERM,1),lbound(PERM,1),-1
  PERM(cp_loop_variable_1,cp_loop_variable_2,cp_loop_variable_3,cp_loop_variable&
     &_4) = theArgFStack(theArgFStackoffset)

  theArgFStackoffset = theArgFStackoffset-1
  end do
  end do
  end do
  end do
    end if
    if (our_rev_mode%plain) then
      our_orig_mode=our_rev_mode
      our_rev_mode%arg_store=.FALSE.
! original function
  CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT(MU,SIGMA,Q)
  CALL SIMULATE_RESERVOIR(Q,S,P,V,TT,PC,OIL)

! original function end
      our_rev_mode=our_orig_mode
    end if
    if (our_rev_mode%tape) then
!            print*, " tape       ", our_rev_mode
      our_rev_mode%arg_store=.TRUE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.TRUE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.FALSE.
! taping
  CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT(MU,SIGMA,Q)
  CALL SIMULATE_RESERVOIR(Q,S,P,V,TT,PC,OIL)

! taping end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.FALSE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.FALSE.
      our_rev_mode%adjoint=.TRUE.
    end if
    if (our_rev_mode%adjoint) then
!            print*, " adjoint    ", our_rev_mode
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
! adjoint
  CALL SIMULATE_RESERVOIR(Q,S,P,V,TT,PC,OIL)
  CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT(MU,SIGMA,Q)

! adjoint end
      our_rev_mode%arg_store=.FALSE.
      our_rev_mode%arg_restore=.TRUE.
      our_rev_mode%plain=.FALSE.
      our_rev_mode%tape=.TRUE.
      our_rev_mode%adjoint=.FALSE.
    end if
  end subroutine WRAPPER
END
