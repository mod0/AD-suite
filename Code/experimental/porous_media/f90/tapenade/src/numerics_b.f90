!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
MODULE PARAMETERS_B
  IMPLICIT NONE
! FIXED PARAMETERS
! grid parameters 
  INTEGER :: nx_, ny_, nz_, n_
  DOUBLE PRECISION :: hx_, hy_, hz_, v_, ir
  INTEGER :: maxnx, maxny, maxnz
  PARAMETER (maxnx=60, maxny=220, maxnz=85, nx_=10, ny_=10, nz_=2, hx_=&
&   20.0d0*0.3048d0, hy_=10.0d0*0.3048d0, hz_=2.0d0*0.3048d0, n_=nx_*ny_&
&   *nz_, v_=hx_*hy_*hz_, ir=795.0*nx_*ny_*nz_/(maxnx*maxny*maxnz))
! Dimension in x-direction
! Dimension in y-direction
! Dimension in z-direction
! step size in x-direction
! step size in y-direction
! step size in z-direction
! Total number of grid cells
! Volume of each grid cell
! Magic number
! fluid parameters
  DOUBLE PRECISION :: vw_, vo_, swc_, sor_
  PARAMETER (vw_=3d-4, vo_=3d-3, swc_=0.2d0, sor_=0.2d0)
! Viscosity of Water
! Viscosity of Oil
! Saturation of water cut
! Saturation of oil cut
! timestepping parameters
  INTEGER :: st, pt, nd
  PARAMETER (st=5, pt=100, nd=2000)
! Max saturation time step
! Pressure time step
! Number of days in simulation
! filenames
  CHARACTER(len=*), PARAMETER :: data_directory='../../data/'
  CHARACTER(len=*), PARAMETER :: porosity_file=data_directory//&
&   '/shared/pUr.txt'
  CHARACTER(len=*), PARAMETER :: permeability_file=data_directory//&
&   '/shared/KUr.txt'
! PARAMETERS READ FROM FILE
! porosity and permeability parameters
! Porosities
  DOUBLE PRECISION, DIMENSION(n_) :: por
! Permeabilities  
  DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: perm
! PARAMETERS SET IN DRIVER
! linear solver parameters
  LOGICAL :: verbose
  INTEGER :: solver_inner, solver_outer
END MODULE PARAMETERS_B

MODULE MATHUTIL_B
  IMPLICIT NONE
  PUBLIC dnrm2

CONTAINS
!
! Subroutine computes the 2 norm of the vector
! adapted from the original function version
! of the corresponding blas routine from
! NETLIB
!
  SUBROUTINE DNRM2(v, len_v, n)
    IMPLICIT NONE
    INTEGER :: i, len_v
    DOUBLE PRECISION :: n
    DOUBLE PRECISION, DIMENSION(len_v) :: v
    DOUBLE PRECISION :: scalein, scaleout
    INTRINSIC ABS
    INTRINSIC SQRT
    DOUBLE PRECISION :: abs0
    n = 0.0d0
    scalein = 0.0d0
    scaleout = 0.0d0
    DO i=1,len_v
      IF (v(i) .GE. 0.) THEN
        abs0 = v(i)
      ELSE
        abs0 = -v(i)
      END IF
      CALL SCALAR_MAX(scalein, abs0, scaleout)
      scalein = scaleout
    END DO
    IF (scaleout .EQ. 0.0d0) THEN
      n = 0.0d0
    ELSE
      DO i=1,len_v
        n = n + (v(i)/scaleout)**2
      END DO
      n = scaleout*SQRT(n)
    END IF
  END SUBROUTINE DNRM2
  SUBROUTINE SCALAR_MAX(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .LE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE SCALAR_MAX
END MODULE MATHUTIL_B

MODULE MATRIX_B
  USE PARAMETERS_B
  IMPLICIT NONE
! export module interface
!,disp_spmat
  PUBLIC myreshape, add_x, spmat_multiply, mymin, mymax
  PUBLIC myreshape_b, add_x_b, spmat_multiply_b, mymin_b, mymax_b
  INTERFACE MYRESHAPE
      MODULE PROCEDURE MYRESHAPE_1_2
      MODULE PROCEDURE MYRESHAPE_2_1
      MODULE PROCEDURE MYRESHAPE_1_3
      MODULE PROCEDURE MYRESHAPE_3_1
      MODULE PROCEDURE MYRESHAPE_1_4
      MODULE PROCEDURE MYRESHAPE_4_1
  END INTERFACE MYRESHAPE

  INTERFACE MYRESHAPE_B
      MODULE PROCEDURE MYRESHAPE_1_3_B
      MODULE PROCEDURE MYRESHAPE_3_1_B
      MODULE PROCEDURE MYRESHAPE_1_4_B
  END INTERFACE

  INTERFACE ADD_X
      MODULE PROCEDURE ADDX_ELEM
      MODULE PROCEDURE ADDX_DIAGONAL
  END INTERFACE ADD_X

  INTERFACE ADD_X_B
      MODULE PROCEDURE ADDX_DIAGONAL_B
  END INTERFACE

  INTERFACE SPMAT_MULTIPLY
      MODULE PROCEDURE SPMAT_MULTIPLY_DIAGONAL
      MODULE PROCEDURE SPMAT_MULTIPLY_VECTOR
      MODULE PROCEDURE SCALAR_MULTIPLY_SPMAT
  END INTERFACE

  INTERFACE SPMAT_MULTIPLY_B
      MODULE PROCEDURE SPMAT_MULTIPLY_DIAGONAL_B
      MODULE PROCEDURE SPMAT_MULTIPLY_VECTOR_B
  END INTERFACE

  INTERFACE MYMIN
      MODULE PROCEDURE MYMIN_0_0_DOUBLE
      MODULE PROCEDURE MYMIN_1_0_DOUBLE
      MODULE PROCEDURE MYMIN_1_1_DOUBLE
  END INTERFACE MYMIN

  INTERFACE MYMIN_B
      MODULE PROCEDURE MYMIN_1_0_DOUBLE_B
  END INTERFACE

  INTERFACE MYMAX
      MODULE PROCEDURE MYMAX_0_0_DOUBLE
      MODULE PROCEDURE MYMAX_1_0_DOUBLE
      MODULE PROCEDURE MYMAX_1_1_DOUBLE
  END INTERFACE MYMAX

  INTERFACE MYMAX_B
      MODULE PROCEDURE MYMAX_1_0_DOUBLE_B
  END INTERFACE


CONTAINS
! !
! ! Display the matrix entries
! !
! subroutine disp_spmat(innz, irow_index, irow_compressed, icol_index, ivalues, output)
!     implicit none
!     integer :: k, output
!
!     integer ::  innz
!     integer, dimension(7 * N_) :: irow_index
!     integer, dimension(7 * N_) :: icol_index
!     double precision, dimension(7 * N_) :: ivalues
!     integer, dimension(N_ + 1) :: irow_compressed
!
!     if(output /= 0) then
!         do k = 1, innz
!             write (*, '(a, i7, a, i7, a, a, e23.16)'), "(", irow_index(k), ",", &
!                         icol_index(k), ")", " ", ivalues(k)
!         end do
!         write (*, *) irow_compressed
!     end if
! end subroutine disp_spmat
!
! Subroutine adds x to a particular element.
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix. Further the element may be non-existent. Structure of
! SPMAT has to be changed to allow arbitrary fill-ins.
!
  SUBROUTINE ADDX_ELEM(innz, irow_index, irow_compressed, icol_index, &
&   ivalues, x, row, col)
    IMPLICIT NONE
    DOUBLE PRECISION :: x
    INTEGER :: i, row, col
    INTEGER :: n, innz
    INTEGER, DIMENSION(7*n_) :: irow_index
    INTEGER, DIMENSION(7*n_) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivalues
    INTEGER, DIMENSION(n_ + 1) :: irow_compressed
    DO i=1,innz
      IF (irow_index(i) .EQ. row .AND. icol_index(i) .EQ. col) THEN
        ivalues(i) = ivalues(i) + x
        GOTO 100
      END IF
    END DO
 100 CONTINUE
  END SUBROUTINE ADDX_ELEM
!  Differentiation of addx_diagonal in reverse (adjoint) mode:
!   gradient     of useful results: ivalues
!   with respect to varying inputs: ivalues
!
! Subroutine adds x to a particular diagonal
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix
!
  SUBROUTINE ADDX_DIAGONAL_B(innz, irow_index, irow_compressed, &
&   icol_index, ivalues, ivaluesb, x, diag)
    IMPLICIT NONE
    INTEGER :: i, diag
    DOUBLE PRECISION :: x
    INTEGER :: innz
    INTEGER, DIMENSION(7*n_) :: irow_index
    INTEGER, DIMENSION(7*n_) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivaluesb
    INTEGER, DIMENSION(n_ + 1) :: irow_compressed
  END SUBROUTINE ADDX_DIAGONAL_B
!
! Subroutine adds x to a particular diagonal
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix
!
  SUBROUTINE ADDX_DIAGONAL(innz, irow_index, irow_compressed, icol_index&
&   , ivalues, x, diag)
    IMPLICIT NONE
    INTEGER :: i, diag
    DOUBLE PRECISION :: x
    INTEGER :: innz
    INTEGER, DIMENSION(7*n_) :: irow_index
    INTEGER, DIMENSION(7*n_) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivalues
    INTEGER, DIMENSION(n_ + 1) :: irow_compressed
    DO i=1,innz
      IF (icol_index(i) - irow_index(i) .EQ. diag) ivalues(i) = ivalues(&
&         i) + x
    END DO
  END SUBROUTINE ADDX_DIAGONAL
!
! Gets the diagonal on which the row, col lie
!
  SUBROUTINE GETDIAG(row, col, diag)
    IMPLICIT NONE
    INTEGER :: diag, row, col
    diag = col - row
  END SUBROUTINE GETDIAG
!
! Gets the number of elements on the diagonal for a given output
! matrix size.
!
  SUBROUTINE NOELEMS(diag, orows, ocols, n)
    IMPLICIT NONE
    INTEGER :: diag, orows, ocols, row, col, n
    INTRINSIC MIN
! first element along diagonal
    CALL FIRSTELM(diag, row, col)
    IF (diag .LT. 0) THEN
! subdiagonal read from top
! number of elements along diagonal
      n = orows - row + 1
    ELSE IF (diag .EQ. 0) THEN
      IF (orows .GT. ocols) THEN
        n = ocols
      ELSE
        n = orows
      END IF
    ELSE
! super diagonal read from bottom (possible middle)
! number of elements along diagonal
      n = ocols - col + 1
    END IF
  END SUBROUTINE NOELEMS
!
! Gets the indices of the first element on
! diagonal
!
  SUBROUTINE FIRSTELM(diag, row, col)
    IMPLICIT NONE
    INTEGER :: diag, row, col
    IF (diag .LT. 0) THEN
      row = 1 - diag
      col = 1
    ELSE IF (diag .EQ. 0) THEN
      row = 1
      col = 1
    ELSE
      row = 1
      col = 1 + diag
    END IF
  END SUBROUTINE FIRSTELM
!
! Reshape a 2d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_2_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k
    DOUBLE PRECISION, DIMENSION(:, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    k = 0
    DO j=1,SIZE(amatrix, 2)
      DO i=1,SIZE(amatrix, 1)
        k = k + 1
        bmatrix(k) = amatrix(i, j)
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_2_1
!
! Reshape a 1d matrix to a 2D array
!
  SUBROUTINE MYRESHAPE_1_2(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :) :: bmatrix
    INTRINSIC SIZE
    k = 0
    DO j=1,SIZE(bmatrix, 2)
      DO i=1,SIZE(bmatrix, 1)
        k = k + 1
        bmatrix(i, j) = amatrix(k)
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_2
!  Differentiation of myreshape_3_1 in reverse (adjoint) mode:
!   gradient     of useful results: bmatrix
!   with respect to varying inputs: bmatrix amatrix
!
! Reshape a 3d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_3_1_B(amatrix, amatrixb, bmatrix, bmatrixb)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrixb
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrixb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    l = 0
    DO k=1,SIZE(amatrix, 3)
      DO j=1,SIZE(amatrix, 2)
        DO i=1,SIZE(amatrix, 1)
          CALL PUSHINTEGER4(l)
          l = l + 1
        END DO
        CALL PUSHINTEGER4(i - 1)
      END DO
      CALL PUSHINTEGER4(j - 1)
    END DO
    ad_to1 = k - 1
    amatrixb = 0.D0
    DO k=ad_to1,1,-1
      CALL POPINTEGER4(ad_to0)
      DO j=ad_to0,1,-1
        CALL POPINTEGER4(ad_to)
        DO i=ad_to,1,-1
          amatrixb(i, j, k) = amatrixb(i, j, k) + bmatrixb(l)
          bmatrixb(l) = 0.D0
          CALL POPINTEGER4(l)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_3_1_B
!
! Reshape a 3d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_3_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    l = 0
    DO k=1,SIZE(amatrix, 3)
      DO j=1,SIZE(amatrix, 2)
        DO i=1,SIZE(amatrix, 1)
          l = l + 1
          bmatrix(l) = amatrix(i, j, k)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_3_1
!  Differentiation of myreshape_1_3 in reverse (adjoint) mode:
!   gradient     of useful results: bmatrix
!   with respect to varying inputs: bmatrix amatrix
!
! Reshape a 1d matrix to a 3D array
!
  SUBROUTINE MYRESHAPE_1_3_B(amatrix, amatrixb, bmatrix, bmatrixb)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: amatrixb
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrixb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    l = 0
    DO k=1,SIZE(bmatrix, 3)
      DO j=1,SIZE(bmatrix, 2)
        DO i=1,SIZE(bmatrix, 1)
          CALL PUSHINTEGER4(l)
          l = l + 1
          bmatrix(i, j, k) = amatrix(l)
        END DO
        CALL PUSHINTEGER4(i - 1)
      END DO
      CALL PUSHINTEGER4(j - 1)
    END DO
    ad_to1 = k - 1
    amatrixb = 0.D0
    DO k=ad_to1,1,-1
      CALL POPINTEGER4(ad_to0)
      DO j=ad_to0,1,-1
        CALL POPINTEGER4(ad_to)
        DO i=ad_to,1,-1
          amatrixb(l) = amatrixb(l) + bmatrixb(i, j, k)
          bmatrixb(i, j, k) = 0.D0
          CALL POPINTEGER4(l)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_3_B
!
! Reshape a 1d matrix to a 3D array
!
  SUBROUTINE MYRESHAPE_1_3(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrix
    INTRINSIC SIZE
    l = 0
    DO k=1,SIZE(bmatrix, 3)
      DO j=1,SIZE(bmatrix, 2)
        DO i=1,SIZE(bmatrix, 1)
          l = l + 1
          bmatrix(i, j, k) = amatrix(l)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_3
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_4_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    m = 0
    DO l=1,SIZE(amatrix, 4)
      DO k=1,SIZE(amatrix, 3)
        DO j=1,SIZE(amatrix, 2)
          DO i=1,SIZE(amatrix, 1)
            m = m + 1
            bmatrix(m) = amatrix(i, j, k, l)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_4_1
!  Differentiation of myreshape_1_4 in reverse (adjoint) mode:
!   gradient     of useful results: bmatrix
!   with respect to varying inputs: amatrix
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_1_4_B(amatrix, amatrixb, bmatrix, bmatrixb)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: amatrixb
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrixb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    INTEGER :: ad_to2
    m = 0
    DO l=1,SIZE(bmatrix, 4)
      DO k=1,SIZE(bmatrix, 3)
        DO j=1,SIZE(bmatrix, 2)
          DO i=1,SIZE(bmatrix, 1)
            CALL PUSHINTEGER4(m)
            m = m + 1
            bmatrix(i, j, k, l) = amatrix(m)
          END DO
          CALL PUSHINTEGER4(i - 1)
        END DO
        CALL PUSHINTEGER4(j - 1)
      END DO
      CALL PUSHINTEGER4(k - 1)
    END DO
    ad_to2 = l - 1
    amatrixb = 0.D0
    DO l=ad_to2,1,-1
      CALL POPINTEGER4(ad_to1)
      DO k=ad_to1,1,-1
        CALL POPINTEGER4(ad_to0)
        DO j=ad_to0,1,-1
          CALL POPINTEGER4(ad_to)
          DO i=ad_to,1,-1
            amatrixb(m) = amatrixb(m) + bmatrixb(i, j, k, l)
            bmatrixb(i, j, k, l) = 0.D0
            CALL POPINTEGER4(m)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_4_B
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_1_4(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrix
    INTRINSIC SIZE
    m = 0
    DO l=1,SIZE(bmatrix, 4)
      DO k=1,SIZE(bmatrix, 3)
        DO j=1,SIZE(bmatrix, 2)
          DO i=1,SIZE(bmatrix, 1)
            m = m + 1
            bmatrix(i, j, k, l) = amatrix(m)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_4
!  Differentiation of spmat_multiply_diagonal in reverse (adjoint) mode:
!   gradient     of useful results: avalues rvalues
!   with respect to varying inputs: avalues dmatrix rvalues
!
! This routine pre-multiplies a diagonal matrix by a sparse matrix
!
  SUBROUTINE SPMAT_MULTIPLY_DIAGONAL_B(annz, arow_index, arow_compressed&
&   , acol_index, avalues, avaluesb, dmatrix, dmatrixb, rnnz, rrow_index&
&   , rrow_compressed, rcol_index, rvalues, rvaluesb, order)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    CHARACTER(len=3) :: order
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesb
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n_) :: rrow_index
    INTEGER, DIMENSION(7*n_) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: rvalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: rvaluesb
    INTEGER, DIMENSION(n_ + 1) :: rrow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: dmatrix
    DOUBLE PRECISION, DIMENSION(n_) :: dmatrixb
    IF (order .EQ. 'PRE') THEN
      dmatrixb = 0.D0
      DO i=annz,1,-1
        avaluesb(i) = avaluesb(i) + dmatrix(acol_index(i))*rvaluesb(i)
        dmatrixb(acol_index(i)) = dmatrixb(acol_index(i)) + avalues(i)*&
&         rvaluesb(i)
        rvaluesb(i) = 0.D0
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      dmatrixb = 0.D0
      DO i=annz,1,-1
        avaluesb(i) = avaluesb(i) + dmatrix(arow_index(i))*rvaluesb(i)
        dmatrixb(arow_index(i)) = dmatrixb(arow_index(i)) + avalues(i)*&
&         rvaluesb(i)
        rvaluesb(i) = 0.D0
      END DO
    ELSE
      dmatrixb = 0.D0
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_DIAGONAL_B
!
! This routine pre-multiplies a diagonal matrix by a sparse matrix
!
  SUBROUTINE SPMAT_MULTIPLY_DIAGONAL(annz, arow_index, arow_compressed, &
&   acol_index, avalues, dmatrix, rnnz, rrow_index, rrow_compressed, &
&   rcol_index, rvalues, order)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    CHARACTER(len=3) :: order
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n_) :: rrow_index
    INTEGER, DIMENSION(7*n_) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: rvalues
    INTEGER, DIMENSION(n_ + 1) :: rrow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: dmatrix
    rnnz = annz
    rrow_compressed = arow_compressed
    IF (order .EQ. 'PRE') THEN
      DO i=1,annz
        rrow_index(i) = arow_index(i)
        rcol_index(i) = acol_index(i)
! take combination of columns of amatrix
        rvalues(i) = avalues(i)*dmatrix(acol_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      DO i=1,annz
        rrow_index(i) = arow_index(i)
        rcol_index(i) = acol_index(i)
! take combination of rows of amatrix
        rvalues(i) = avalues(i)*dmatrix(arow_index(i))
      END DO
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_DIAGONAL
!  Differentiation of spmat_multiply_vector in reverse (adjoint) mode:
!   gradient     of useful results: avalues cvector
!   with respect to varying inputs: bvector avalues
!
! The routine multiplies a vector by a sparse matrix (PRE/POST)
!
  SUBROUTINE SPMAT_MULTIPLY_VECTOR_B(annz, arow_index, arow_compressed, &
&   acol_index, avalues, avaluesb, bvector, bvectorb, cvector, cvectorb&
&   , order)
    IMPLICIT NONE
    INTEGER :: i
    CHARACTER(len=3) :: order
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesb
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: bvector
    DOUBLE PRECISION, DIMENSION(n_) :: bvectorb
    DOUBLE PRECISION, DIMENSION(n_) :: cvector
    DOUBLE PRECISION, DIMENSION(n_) :: cvectorb
    IF (order .EQ. 'PRE') THEN
      bvectorb = 0.D0
      DO i=annz,1,-1
        avaluesb(i) = avaluesb(i) + bvector(acol_index(i))*cvectorb(&
&         arow_index(i))
        bvectorb(acol_index(i)) = bvectorb(acol_index(i)) + avalues(i)*&
&         cvectorb(arow_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      bvectorb = 0.D0
      DO i=annz,1,-1
        avaluesb(i) = avaluesb(i) + bvector(arow_index(i))*cvectorb(&
&         acol_index(i))
        bvectorb(arow_index(i)) = bvectorb(arow_index(i)) + avalues(i)*&
&         cvectorb(acol_index(i))
      END DO
    ELSE
      bvectorb = 0.D0
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_VECTOR_B
!
! The routine multiplies a vector by a sparse matrix (PRE/POST)
!
  SUBROUTINE SPMAT_MULTIPLY_VECTOR(annz, arow_index, arow_compressed, &
&   acol_index, avalues, bvector, cvector, order)
    IMPLICIT NONE
    INTEGER :: i
    CHARACTER(len=3) :: order
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: bvector
    DOUBLE PRECISION, DIMENSION(n_) :: cvector
    cvector = 0.0d0
    IF (order .EQ. 'PRE') THEN
      DO i=1,annz
! Combination of the columns of amatrix
        cvector(arow_index(i)) = cvector(arow_index(i)) + avalues(i)*&
&         bvector(acol_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      DO i=1,annz
! Combination of the rows of amatrix
        cvector(acol_index(i)) = cvector(acol_index(i)) + avalues(i)*&
&         bvector(arow_index(i))
      END DO
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_VECTOR
!
! This routine multiplies each element of the SPMAT
! by a scalar.
! Allows amatrix to be the same as rmatrix
!
  SUBROUTINE SCALAR_MULTIPLY_SPMAT(annz, arow_index, arow_compressed, &
&   acol_index, avalues, scalar, rnnz, rrow_index, rrow_compressed, &
&   rcol_index, rvalues)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    DOUBLE PRECISION :: scalar
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n_) :: rrow_index
    INTEGER, DIMENSION(7*n_) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: rvalues
    INTEGER, DIMENSION(n_ + 1) :: rrow_compressed
    rnnz = annz
    rrow_compressed = arow_compressed
    DO i=1,annz
      rrow_index(i) = arow_index(i)
      rcol_index(i) = acol_index(i)
      rvalues(i) = scalar*avalues(i)
    END DO
  END SUBROUTINE SCALAR_MULTIPLY_SPMAT
  SUBROUTINE MYMIN_0_0_DOUBLE(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .GE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE MYMIN_0_0_DOUBLE
!  Differentiation of mymin_1_0_double in reverse (adjoint) mode:
!   gradient     of useful results: vectorout vectorin
!   with respect to varying inputs: vectorin
  SUBROUTINE MYMIN_1_0_DOUBLE_B(vectorin, vectorinb, scalarin, vectorout&
&   , vectoroutb)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    DOUBLE PRECISION, DIMENSION(:) :: vectorinb, vectoroutb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .GE. scalarin) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to = i - 1
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        vectorinb(i) = vectorinb(i) + vectoroutb(i)
        vectoroutb(i) = 0.D0
      ELSE
        vectoroutb(i) = 0.D0
      END IF
    END DO
  END SUBROUTINE MYMIN_1_0_DOUBLE_B
  SUBROUTINE MYMIN_1_0_DOUBLE(vectorin, scalarin, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .GE. scalarin) THEN
        vectorout(i) = scalarin
      ELSE
        vectorout(i) = vectorin(i)
      END IF
    END DO
  END SUBROUTINE MYMIN_1_0_DOUBLE
  SUBROUTINE MYMIN_1_1_DOUBLE(vectorin1, vectorin2, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(:) :: vectorin1, vectorin2, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin1, 1)
      IF (vectorin1(i) .GE. vectorin2(i)) THEN
        vectorout(i) = vectorin2(i)
      ELSE
        vectorout(i) = vectorin1(i)
      END IF
    END DO
  END SUBROUTINE MYMIN_1_1_DOUBLE
  SUBROUTINE MYMAX_0_0_DOUBLE(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .LE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE MYMAX_0_0_DOUBLE
!  Differentiation of mymax_1_0_double in reverse (adjoint) mode:
!   gradient     of useful results: vectorout vectorin
!   with respect to varying inputs: vectorout vectorin
  SUBROUTINE MYMAX_1_0_DOUBLE_B(vectorin, vectorinb, scalarin, vectorout&
&   , vectoroutb)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    DOUBLE PRECISION, DIMENSION(:) :: vectorinb, vectoroutb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .LE. scalarin) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to = i - 1
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        vectorinb(i) = vectorinb(i) + vectoroutb(i)
        vectoroutb(i) = 0.D0
      ELSE
        vectoroutb(i) = 0.D0
      END IF
    END DO
  END SUBROUTINE MYMAX_1_0_DOUBLE_B
  SUBROUTINE MYMAX_1_0_DOUBLE(vectorin, scalarin, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .LE. scalarin) THEN
        vectorout(i) = scalarin
      ELSE
        vectorout(i) = vectorin(i)
      END IF
    END DO
  END SUBROUTINE MYMAX_1_0_DOUBLE
  SUBROUTINE MYMAX_1_1_DOUBLE(vectorin1, vectorin2, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(:) :: vectorin1, vectorin2, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin1, 1)
      IF (vectorin1(i) .LE. vectorin2(i)) THEN
        vectorout(i) = vectorin2(i)
      ELSE
        vectorout(i) = vectorin1(i)
      END IF
    END DO
  END SUBROUTINE MYMAX_1_1_DOUBLE
END MODULE MATRIX_B

MODULE LINSOLVE_B
  USE PARAMETERS_B
  USE MATHUTIL_B
  USE MATRIX_B
  IMPLICIT NONE
! !%>LINSOLVE
! !
! ! A method to test OpenAD without solver
! !
! subroutine sparse_dummy_method(n, annz, alen, arow_index, arow_compressed, &
!                                acol_index, avalues, b, x, solver_inner, solver_outer, verbose)
!   integer :: i
!   logical :: verbose
!   integer :: solver_inner, solver_outer
!   double precision :: sum
!   integer :: n, annz, alen
!   integer, dimension(alen) :: arow_index
!   integer, dimension(alen) :: acol_index
!   double precision, dimension(alen) :: avalues
!   integer, dimension(n + 1) :: arow_compressed
!   double precision, dimension(n) :: b
!   double precision, dimension(n) :: x
!   x = 0.0d0
!   sum = 0.0d0
!   do i = 1, annz
!       sum = sum + avalues(i)
!   end do
!   x = b/sum
! end subroutine sparse_dummy_method
! !%<LINSOLVE
! export solve
  PUBLIC solve
  PUBLIC solve_b
  INTERFACE SOLVE
      MODULE PROCEDURE SPARSE_SOLVE
  END INTERFACE SOLVE

  INTERFACE SOLVE_B
      MODULE PROCEDURE SPARSE_SOLVE_B
  END INTERFACE


CONTAINS
!  Differentiation of sparse_solve in reverse (adjoint) mode:
!   gradient     of useful results: avalues x b
!   with respect to varying inputs: avalues x b
!
! Calls a specific solver - here the jacobi method
!
  SUBROUTINE SPARSE_SOLVE_B(annz, arow_index, arow_compressed, &
&   acol_index, avalues, avaluesb, b, bb, x, xb)
    IMPLICIT NONE
    INTEGER :: annz
    INTEGER, PARAMETER :: matdim=n_
    INTEGER, PARAMETER :: maxlen=7*matdim
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesb
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: b
    DOUBLE PRECISION, DIMENSION(n_) :: bb
    DOUBLE PRECISION, DIMENSION(n_) :: x
    DOUBLE PRECISION, DIMENSION(n_) :: xb
    EXTERNAL SPARSE_DUMMY_METHOD
    EXTERNAL SPARSE_DUMMY_METHOD_B
    INTEGER :: arg1
    arg1 = 7*n_
    CALL SPARSE_DUMMY_METHOD_B(n_, annz, arg1, arow_index, &
&                        arow_compressed, acol_index, avalues, avaluesb&
&                        , b, bb, x, xb, solver_inner, solver_outer, &
&                        verbose)
  END SUBROUTINE SPARSE_SOLVE_B
!
! Calls a specific solver - here the jacobi method
!
  SUBROUTINE SPARSE_SOLVE(annz, arow_index, arow_compressed, acol_index&
&   , avalues, b, x)
    IMPLICIT NONE
    INTEGER :: annz
    INTEGER, PARAMETER :: matdim=n_
    INTEGER, PARAMETER :: maxlen=7*matdim
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: b
    DOUBLE PRECISION, DIMENSION(n_) :: x
    EXTERNAL SPARSE_DUMMY_METHOD
    INTEGER :: arg1
    arg1 = 7*n_
    CALL SPARSE_DUMMY_METHOD(n_, annz, arg1, arow_index, arow_compressed&
&                      , acol_index, avalues, b, x, solver_inner, &
&                      solver_outer, verbose)
  END SUBROUTINE SPARSE_SOLVE
END MODULE LINSOLVE_B

MODULE FINITEVOLUME_B
  USE PARAMETERS_B
  USE MATHUTIL_B
  USE MATRIX_B
  USE LINSOLVE_B
  IMPLICIT NONE
  INTERFACE RELPERM
      MODULE PROCEDURE RELPERM_SCALAR
      MODULE PROCEDURE RELPERM_VECTOR
  END INTERFACE RELPERM

  INTERFACE RELPERM_B
      MODULE PROCEDURE RELPERM_SCALAR_B
      MODULE PROCEDURE RELPERM_VECTOR_B
  END INTERFACE


CONTAINS
!  Differentiation of newtraph in reverse (adjoint) mode:
!   gradient     of useful results: q s v
!   with respect to varying inputs: q s v
!
! Performs Newton Raphson to solve for saturations
!
  SUBROUTINE NEWTRAPH_B(q, qb, v, vb, s, sb)
    IMPLICIT NONE
    INTEGER :: i, j, it
    LOGICAL :: converged
    DOUBLE PRECISION :: dt, dsn
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sb
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qb
    DOUBLE PRECISION, DIMENSION(n_) :: s_copy
    DOUBLE PRECISION, DIMENSION(n_) :: s_copyb
    DOUBLE PRECISION, DIMENSION(n_) :: s_iter_copy
    DOUBLE PRECISION, DIMENSION(n_) :: s_iter_copyb
    DOUBLE PRECISION, DIMENSION(n_) :: dtx
    DOUBLE PRECISION, DIMENSION(n_) :: dtxb
    DOUBLE PRECISION, DIMENSION(n_) :: fi
    DOUBLE PRECISION, DIMENSION(n_) :: fib
    DOUBLE PRECISION, DIMENSION(n_) :: fw
    DOUBLE PRECISION, DIMENSION(n_) :: fwb
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mwb
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: mob
    DOUBLE PRECISION, DIMENSION(n_) :: dmw
    DOUBLE PRECISION, DIMENSION(n_) :: dmwb
    DOUBLE PRECISION, DIMENSION(n_) :: dmo
    DOUBLE PRECISION, DIMENSION(n_) :: dmob
    DOUBLE PRECISION, DIMENSION(n_) :: df
    DOUBLE PRECISION, DIMENSION(n_) :: dfb
    DOUBLE PRECISION, DIMENSION(n_) :: g
    DOUBLE PRECISION, DIMENSION(n_) :: gb
    DOUBLE PRECISION, DIMENSION(n_) :: ds
    DOUBLE PRECISION, DIMENSION(n_) :: dsb
    DOUBLE PRECISION, DIMENSION(n_) :: bfw
    DOUBLE PRECISION, DIMENSION(n_) :: bfwb
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vb
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesb
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: bnnz
    INTEGER, DIMENSION(7*n_) :: brow_index
    INTEGER, DIMENSION(7*n_) :: bcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: bvalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: bvaluesb
    INTEGER, DIMENSION(n_ + 1) :: brow_compressed
    INTEGER :: dgnnz
    INTEGER, DIMENSION(7*n_) :: dgrow_index
    INTEGER, DIMENSION(7*n_) :: dgcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: dgvalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: dgvaluesb
    INTEGER, DIMENSION(n_ + 1) :: dgrow_compressed
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: ad_count0
    INTEGER :: i1
    INTEGER :: branch
    INTEGER :: ad_count1
    INTEGER :: i2
    DOUBLE PRECISION :: tempb4(n_)
    DOUBLE PRECISION :: tempb3(n_)
    DOUBLE PRECISION :: tempb2(n_)
    DOUBLE PRECISION :: tempb1(n_)
    DOUBLE PRECISION :: tempb0(n_)
    DOUBLE PRECISION :: tempb(n_)
! not yet converged
    converged = .false.
! Assemble system matrix
    CALL GENA(v, q, annz, arow_index, arow_compressed, acol_index, &
&       avalues)
! copy S over
    s_copy = s
! set scaling factor
    it = 0
    ad_count1 = 0
    DO WHILE (.NOT.converged)
      dt = 1.0d0*st/2**it
      dtx = dt/(v_*por)
      CALL MYMAX_1_0_DOUBLE(q, 0.0d0, fi)
      fi = fi*dtx
! Matrix-diagonal matrix product
      CALL PUSHREAL8ARRAY(bvalues, 1400)
      CALL PUSHINTEGER4ARRAY(bcol_index, 1400)
      CALL PUSHINTEGER4ARRAY(brow_index, 1400)
      CALL PUSHINTEGER4(bnnz)
      CALL SPMAT_MULTIPLY_DIAGONAL(annz, arow_index, arow_compressed, &
&                            acol_index, avalues, dtx, bnnz, brow_index&
&                            , brow_compressed, bcol_index, bvalues, &
&                            'POS')
      i = 0
      ad_count0 = 0
      DO WHILE (i .LT. 2**it)
        j = 0
        i = i + 1
        dsn = 1.0d0
        s_iter_copy = s
        ad_count = 0
        DO WHILE (dsn .GT. 1.0d-3 .AND. j .LT. 10)
          CALL PUSHREAL8ARRAY(dmo, 200)
          CALL PUSHREAL8ARRAY(dmw, 200)
          CALL PUSHREAL8ARRAY(mo, 200)
          CALL PUSHREAL8ARRAY(mw, 200)
          CALL RELPERM(s, mw, mo, dmw, dmo)
          df = dmw/(mw+mo) - mw/(mw+mo)**2*(dmw+dmo)
! Matrix-diagonal matrix product
          CALL PUSHREAL8ARRAY(dgvalues, 1400)
          CALL PUSHINTEGER4ARRAY(dgcol_index, 1400)
          CALL PUSHINTEGER4ARRAY(dgrow_compressed, 201)
          CALL PUSHINTEGER4ARRAY(dgrow_index, 1400)
          CALL PUSHINTEGER4(dgnnz)
          CALL SPMAT_MULTIPLY_DIAGONAL(bnnz, brow_index, brow_compressed&
&                                , bcol_index, bvalues, df, dgnnz, &
&                                dgrow_index, dgrow_compressed, &
&                                dgcol_index, dgvalues, 'PRE')
          CALL ADDX_DIAGONAL(dgnnz, dgrow_index, dgrow_compressed, &
&                      dgcol_index, dgvalues, -1.0d0, 0)
          fw = mw/(mw+mo)
! Matrix-vector matrix product
          CALL SPMAT_MULTIPLY_VECTOR(bnnz, brow_index, brow_compressed, &
&                              bcol_index, bvalues, fw, bfw, 'PRE')
          CALL PUSHREAL8ARRAY(g, 200)
          g = s - s_iter_copy - bfw - fi
          CALL PUSHREAL8ARRAY(ds, 200)
          CALL SOLVE(dgnnz, dgrow_index, dgrow_compressed, dgcol_index, &
&              dgvalues, g, ds)
          CALL PUSHREAL8ARRAY(s, 200)
          s = s + ds
          CALL DNRM2(ds, n_, dsn)
          j = j + 1
          ad_count = ad_count + 1
        END DO
        CALL PUSHINTEGER4(ad_count)
        IF (dsn .GT. 1.0d-3) THEN
! Breaks out of while loop.
          i = 2**it
          CALL PUSHREAL8ARRAY(s, 200)
          s = s_copy
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        ad_count0 = ad_count0 + 1
      END DO
      CALL PUSHINTEGER4(ad_count0)
      IF (dsn .LT. 1.0d-3) THEN
        CALL PUSHCONTROL1B(1)
        converged = .true.
      ELSE
        CALL PUSHINTEGER4(it)
        it = it + 1
        CALL PUSHCONTROL1B(0)
      END IF
      ad_count1 = ad_count1 + 1
    END DO
    avaluesb = 0.D0
    dsb = 0.D0
    s_copyb = 0.D0
    dgvaluesb = 0.D0
    fib = 0.D0
    bvaluesb = 0.D0
    dmob = 0.D0
    dmwb = 0.D0
    DO i2=1,ad_count1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) CALL POPINTEGER4(it)
      CALL POPINTEGER4(ad_count0)
      DO i1=1,ad_count0
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPREAL8ARRAY(s, 200)
          s_copyb = s_copyb + sb
          sb = 0.D0
        END IF
        s_iter_copyb = 0.D0
        CALL POPINTEGER4(ad_count)
        DO i0=1,ad_count
          CALL POPREAL8ARRAY(s, 200)
          dsb = dsb + sb
          CALL POPREAL8ARRAY(ds, 200)
          gb = 0.D0
          CALL SOLVE_B(dgnnz, dgrow_index, dgrow_compressed, dgcol_index&
&                , dgvalues, dgvaluesb, g, gb, ds, dsb)
          bfwb = 0.D0
          CALL POPREAL8ARRAY(g, 200)
          sb = sb + gb
          s_iter_copyb = s_iter_copyb - gb
          bfwb = -gb
          fib = fib - gb
          fw = mw/(mw+mo)
          CALL SPMAT_MULTIPLY_VECTOR_B(bnnz, brow_index, brow_compressed&
&                                , bcol_index, bvalues, bvaluesb, fw, &
&                                fwb, bfw, bfwb, 'PRE')
          mob = 0.D0
          mwb = 0.D0
          tempb = fwb/(mw+mo)
          tempb0 = -(mw*tempb/(mw+mo))
          CALL ADDX_DIAGONAL_B(dgnnz, dgrow_index, dgrow_compressed, &
&                        dgcol_index, dgvalues, dgvaluesb, -1.0d0, 0)
          df = dmw/(mw+mo) - mw/(mw+mo)**2*(dmw+dmo)
          CALL POPINTEGER4(dgnnz)
          CALL POPINTEGER4ARRAY(dgrow_index, 1400)
          CALL POPINTEGER4ARRAY(dgrow_compressed, 201)
          CALL POPINTEGER4ARRAY(dgcol_index, 1400)
          CALL POPREAL8ARRAY(dgvalues, 1400)
          CALL SPMAT_MULTIPLY_DIAGONAL_B(bnnz, brow_index, &
&                                  brow_compressed, bcol_index, bvalues&
&                                  , bvaluesb, df, dfb, dgnnz, &
&                                  dgrow_index, dgrow_compressed, &
&                                  dgcol_index, dgvalues, dgvaluesb, &
&                                  'PRE')
          tempb4 = dfb/(mw+mo)
          tempb1 = -(dmw*tempb4/(mw+mo))
          tempb2 = -(dfb/(mw+mo)**2)
          tempb3 = -(2*mw*(dmw+dmo)*tempb2/(mw+mo))
          mwb = tempb1 + (dmw+dmo)*tempb2 + tempb3 + tempb0 + tempb
          mob = tempb1 + tempb3 + tempb0
          dmwb = dmwb + mw*tempb2 + tempb4
          dmob = dmob + mw*tempb2
          CALL POPREAL8ARRAY(mw, 200)
          CALL POPREAL8ARRAY(mo, 200)
          CALL POPREAL8ARRAY(dmw, 200)
          CALL POPREAL8ARRAY(dmo, 200)
          CALL RELPERM_B(s, sb, mw, mwb, mo, mob, dmw, dmwb, dmo, dmob)
        END DO
        sb = sb + s_iter_copyb
      END DO
      dt = 1.0d0*st/2**it
      dtx = dt/(v_*por)
      CALL POPINTEGER4(bnnz)
      CALL POPINTEGER4ARRAY(brow_index, 1400)
      CALL POPINTEGER4ARRAY(bcol_index, 1400)
      CALL POPREAL8ARRAY(bvalues, 1400)
      CALL SPMAT_MULTIPLY_DIAGONAL_B(annz, arow_index, arow_compressed, &
&                              acol_index, avalues, avaluesb, dtx, dtxb&
&                              , bnnz, brow_index, brow_compressed, &
&                              bcol_index, bvalues, bvaluesb, 'POS')
      fib = dtx*fib
      CALL MYMAX_1_0_DOUBLE_B(q, qb, 0.0d0, fi, fib)
    END DO
    sb = sb + s_copyb
    CALL GENA_B(v, vb, q, qb, annz, arow_index, arow_compressed, &
&         acol_index, avalues, avaluesb)
  END SUBROUTINE NEWTRAPH_B
!
! Performs Newton Raphson to solve for saturations
!
  SUBROUTINE NEWTRAPH(q, v, s)
    IMPLICIT NONE
    INTEGER :: i, j, it
    LOGICAL :: converged
    DOUBLE PRECISION :: dt, dsn
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: s_copy
    DOUBLE PRECISION, DIMENSION(n_) :: s_iter_copy
    DOUBLE PRECISION, DIMENSION(n_) :: dtx
    DOUBLE PRECISION, DIMENSION(n_) :: fi
    DOUBLE PRECISION, DIMENSION(n_) :: fw
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: dmw
    DOUBLE PRECISION, DIMENSION(n_) :: dmo
    DOUBLE PRECISION, DIMENSION(n_) :: df
    DOUBLE PRECISION, DIMENSION(n_) :: g
    DOUBLE PRECISION, DIMENSION(n_) :: ds
    DOUBLE PRECISION, DIMENSION(n_) :: bfw
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: bnnz
    INTEGER, DIMENSION(7*n_) :: brow_index
    INTEGER, DIMENSION(7*n_) :: bcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: bvalues
    INTEGER, DIMENSION(n_ + 1) :: brow_compressed
    INTEGER :: dgnnz
    INTEGER, DIMENSION(7*n_) :: dgrow_index
    INTEGER, DIMENSION(7*n_) :: dgcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: dgvalues
    INTEGER, DIMENSION(n_ + 1) :: dgrow_compressed
! not yet converged
    converged = .false.
! Assemble system matrix
    CALL GENA(v, q, annz, arow_index, arow_compressed, acol_index, &
&       avalues)
! copy S over
    s_copy = s
! set scaling factor
    it = 0
    DO WHILE (.NOT.converged)
      dt = 1.0d0*st/2**it
      dtx = dt/(v_*por)
      CALL MYMAX_1_0_DOUBLE(q, 0.0d0, fi)
      fi = fi*dtx
! Matrix-diagonal matrix product
      CALL SPMAT_MULTIPLY_DIAGONAL(annz, arow_index, arow_compressed, &
&                            acol_index, avalues, dtx, bnnz, brow_index&
&                            , brow_compressed, bcol_index, bvalues, &
&                            'POS')
      i = 0
      DO WHILE (i .LT. 2**it)
        j = 0
        i = i + 1
        dsn = 1.0d0
        s_iter_copy = s
        DO WHILE (dsn .GT. 1.0d-3 .AND. j .LT. 10)
          CALL RELPERM(s, mw, mo, dmw, dmo)
          df = dmw/(mw+mo) - mw/(mw+mo)**2*(dmw+dmo)
! Matrix-diagonal matrix product
          CALL SPMAT_MULTIPLY_DIAGONAL(bnnz, brow_index, brow_compressed&
&                                , bcol_index, bvalues, df, dgnnz, &
&                                dgrow_index, dgrow_compressed, &
&                                dgcol_index, dgvalues, 'PRE')
          CALL ADDX_DIAGONAL(dgnnz, dgrow_index, dgrow_compressed, &
&                      dgcol_index, dgvalues, -1.0d0, 0)
          fw = mw/(mw+mo)
! Matrix-vector matrix product
          CALL SPMAT_MULTIPLY_VECTOR(bnnz, brow_index, brow_compressed, &
&                              bcol_index, bvalues, fw, bfw, 'PRE')
          g = s - s_iter_copy - bfw - fi
          CALL SOLVE(dgnnz, dgrow_index, dgrow_compressed, dgcol_index, &
&              dgvalues, g, ds)
          s = s + ds
          CALL DNRM2(ds, n_, dsn)
          j = j + 1
        END DO
        IF (dsn .GT. 1.0d-3) THEN
! Breaks out of while loop.
          i = 2**it
          s = s_copy
        END IF
      END DO
      IF (dsn .LT. 1.0d-3) THEN
        converged = .true.
      ELSE
        it = it + 1
      END IF
    END DO
  END SUBROUTINE NEWTRAPH
!  Differentiation of pres in reverse (adjoint) mode:
!   gradient     of useful results: p q s v
!   with respect to varying inputs: p q s v
!
! Pressure Solver
!
  SUBROUTINE PRES_B(q, qb, s, sb, p, pb, v, vb)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sb
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qb
    DOUBLE PRECISION, DIMENSION(3*n_) :: m
    DOUBLE PRECISION, DIMENSION(3*n_) :: mb
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: km
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: kmb
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vb
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mwb
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: mob
    CALL RELPERM(s, mw, mo)
    DO i=1,n_
      m(1+(i-1)*3) = mw(i) + mo(i)
      m(2+(i-1)*3) = m(1+(i-1)*3)
      m(3+(i-1)*3) = m(1+(i-1)*3)
    END DO
    CALL PUSHREAL8ARRAY(km, 3*10**2*2)
    CALL MYRESHAPE_1_4(m, km)
! point-wise multiply
    km = km*perm
    CALL TPFA_B(km, kmb, q, qb, p, pb, v, vb)
    kmb = perm*kmb
    CALL POPREAL8ARRAY(km, 3*10**2*2)
    CALL MYRESHAPE_1_4_B(m, mb, km, kmb)
    mob = 0.D0
    mwb = 0.D0
    DO i=n_,1,-1
      mb(1+(i-1)*3) = mb(1+(i-1)*3) + mb(3+(i-1)*3)
      mb(3+(i-1)*3) = 0.D0
      mb(1+(i-1)*3) = mb(1+(i-1)*3) + mb(2+(i-1)*3)
      mb(2+(i-1)*3) = 0.D0
      mwb(i) = mwb(i) + mb(1+(i-1)*3)
      mob(i) = mob(i) + mb(1+(i-1)*3)
      mb(1+(i-1)*3) = 0.D0
    END DO
    CALL RELPERM_B(s, sb, mw, mwb, mo, mob)
  END SUBROUTINE PRES_B
!
! Pressure Solver
!
  SUBROUTINE PRES(q, s, p, v)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(3*n_) :: m
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: km
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    CALL RELPERM(s, mw, mo)
    DO i=1,n_
      m(1+(i-1)*3) = mw(i) + mo(i)
      m(2+(i-1)*3) = m(1+(i-1)*3)
      m(3+(i-1)*3) = m(1+(i-1)*3)
    END DO
    CALL MYRESHAPE_1_4(m, km)
! point-wise multiply
    km = km*perm
    CALL TPFA(km, q, p, v)
  END SUBROUTINE PRES
!  Differentiation of relperm_vector in reverse (adjoint) mode:
!   gradient     of useful results: s dmo mo dmw mw
!   with respect to varying inputs: s dmo dmw
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_VECTOR_B(s, sb, mw, mwb, mo, mob, dmw, dmwb, dmo, &
&   dmob)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sb
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mwb
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: mob
    DOUBLE PRECISION, DIMENSION(n_) :: s_temp
    DOUBLE PRECISION, DIMENSION(n_) :: s_tempb
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmw
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmwb
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmo
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmob
    INTRINSIC PRESENT
! rescale saturation
    s_temp = (s-swc_)/(1.0d0-swc_-sor_)
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      s_tempb = 0.D0
      s_tempb = 2*dmwb/(vw_*(1-sor_-swc_)) + 2*dmob/(vo_*(1-sor_-swc_))
      dmob = 0.D0
      dmwb = 0.D0
    ELSE
      s_tempb = 0.D0
    END IF
    s_tempb = s_tempb + 2*s_temp*mwb/vw_ - 2*(1-s_temp)*mob/vo_
    sb = sb + s_tempb/(1.0d0-sor_-swc_)
  END SUBROUTINE RELPERM_VECTOR_B
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_VECTOR(s, mw, mo, dmw, dmo)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: s_temp
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmw
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmo
    INTRINSIC PRESENT
! rescale saturation
    s_temp = (s-swc_)/(1.0d0-swc_-sor_)
    mw = s_temp**2/vw_
    mo = (1-s_temp)**2/vo_
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      dmw = 2*s_temp/vw_/(1-swc_-sor_)
      dmo = -(2*(1-s_temp)/vo_/(1-swc_-sor_))
    END IF
  END SUBROUTINE RELPERM_VECTOR
!  Differentiation of relperm_scalar in reverse (adjoint) mode:
!   gradient     of useful results: s mo mw
!   with respect to varying inputs: s
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_SCALAR_B(s, sb, mw, mwb, mo, mob, dmw, dmo)
    IMPLICIT NONE
    DOUBLE PRECISION :: s, mw, mo, s_temp
    DOUBLE PRECISION :: sb, mwb, mob, s_tempb
    DOUBLE PRECISION, OPTIONAL :: dmw, dmo
    INTRINSIC PRESENT
! rescale saturation
    s_temp = (s-swc_)/(1.0d0-swc_-sor_)
    s_tempb = 2*s_temp*mwb/vw_ - 2*(1-s_temp)*mob/vo_
    sb = sb + s_tempb/(1.0d0-sor_-swc_)
  END SUBROUTINE RELPERM_SCALAR_B
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_SCALAR(s, mw, mo, dmw, dmo)
    IMPLICIT NONE
    DOUBLE PRECISION :: s, mw, mo, s_temp
    DOUBLE PRECISION, OPTIONAL :: dmw, dmo
    INTRINSIC PRESENT
! rescale saturation
    s_temp = (s-swc_)/(1.0d0-swc_-sor_)
    mw = s_temp**2/vw_
    mo = (1-s_temp)**2/vo_
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      dmw = 2*s_temp/vw_/(1-swc_-sor_)
      dmo = -(2*(1-s_temp)/vo_/(1-swc_-sor_))
    END IF
  END SUBROUTINE RELPERM_SCALAR
!  Differentiation of gena in reverse (adjoint) mode:
!   gradient     of useful results: avalues q v
!   with respect to varying inputs: q v
!
! Generate A matrix
!
  SUBROUTINE GENA_B(v, vb, q, qb, annz, arow_index, arow_compressed, &
&   acol_index, avalues, avaluesb)
    IMPLICIT NONE
    INTEGER, DIMENSION(7) :: idiags
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qb
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diags
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diagsb
    DOUBLE PRECISION, DIMENSION(n_) :: diag_tmp
    DOUBLE PRECISION, DIMENSION(n_) :: diag_tmpb
! V has an extra length
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vb
! across each x, y, z
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: vxyz
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: vxyzb
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesb
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
! initialize diags
    diags = 0.0d0
! reshape arrays first
    vxyz = v(3, 1:nx_, 1:ny_, 2:nz_+1)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 1))
! z2
    vxyz = v(2, 1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 2))
! y2
    vxyz = v(1, 2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 3))
! x2
    vxyz = v(1, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 5))
! x1
    vxyz = v(2, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 6))
! y1
    vxyz = v(3, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 7))
! z1
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 1), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 1), 200)
    diags(:, 1) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 2), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 2), 200)
    diags(:, 2) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 3), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 3), 200)
    diags(:, 3) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 5), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 5), 200)
    diags(:, 5) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 6), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 6), 200)
    diags(:, 6) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 7), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 7), 200)
    diags(:, 7) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(q, 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 4), 200)
    diags(:, 4) = diag_tmp - diags(:, 5) - diags(:, 3) - diags(:, 6) - &
&     diags(:, 2) - diags(:, 7) - diags(:, 1)
    CALL SPDIAGS_FVM_CSR_B(diags, diagsb, annz, arow_index, &
&                    arow_compressed, acol_index, avalues, avaluesb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 4), 200)
    diag_tmpb = diagsb(:, 4)
    diagsb(:, 5) = diagsb(:, 5) - diagsb(:, 4)
    diagsb(:, 3) = diagsb(:, 3) - diagsb(:, 4)
    diagsb(:, 6) = diagsb(:, 6) - diagsb(:, 4)
    diagsb(:, 2) = diagsb(:, 2) - diagsb(:, 4)
    diagsb(:, 7) = diagsb(:, 7) - diagsb(:, 4)
    diagsb(:, 1) = diagsb(:, 1) - diagsb(:, 4)
    diagsb(:, 4) = 0.D0
    CALL MYMIN_1_0_DOUBLE_B(q, qb, 0.0d0, diag_tmp, diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 7), 200)
    diag_tmpb = -diagsb(:, 7)
    diagsb(:, 7) = 0.D0
    CALL MYMIN_1_0_DOUBLE_B(diags(:, 7), diagsb(:, 7), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 6), 200)
    diag_tmpb = -diagsb(:, 6)
    diagsb(:, 6) = 0.D0
    CALL MYMIN_1_0_DOUBLE_B(diags(:, 6), diagsb(:, 6), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 5), 200)
    diag_tmpb = -diagsb(:, 5)
    diagsb(:, 5) = 0.D0
    CALL MYMIN_1_0_DOUBLE_B(diags(:, 5), diagsb(:, 5), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 3), 200)
    diag_tmpb = diagsb(:, 3)
    diagsb(:, 3) = 0.D0
    CALL MYMAX_1_0_DOUBLE_B(diags(:, 3), diagsb(:, 3), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 2), 200)
    diag_tmpb = diagsb(:, 2)
    diagsb(:, 2) = 0.D0
    CALL MYMAX_1_0_DOUBLE_B(diags(:, 2), diagsb(:, 2), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 1), 200)
    diag_tmpb = diagsb(:, 1)
    diagsb(:, 1) = 0.D0
    CALL MYMAX_1_0_DOUBLE_B(diags(:, 1), diagsb(:, 1), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 7), diagsb(:, 7))
    vb(3, 1:nx_, 1:ny_, 1:nz_) = vb(3, 1:nx_, 1:ny_, 1:nz_) + vxyzb
    vxyz = v(2, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 6), diagsb(:, 6))
    vb(2, 1:nx_, 1:ny_, 1:nz_) = vb(2, 1:nx_, 1:ny_, 1:nz_) + vxyzb
    vxyz = v(1, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 5), diagsb(:, 5))
    vb(1, 1:nx_, 1:ny_, 1:nz_) = vb(1, 1:nx_, 1:ny_, 1:nz_) + vxyzb
    vxyz = v(1, 2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 3), diagsb(:, 3))
    vb(1, 2:nx_+1, 1:ny_, 1:nz_) = vb(1, 2:nx_+1, 1:ny_, 1:nz_) + vxyzb
    vxyz = v(2, 1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 2), diagsb(:, 2))
    vb(2, 1:nx_, 2:ny_+1, 1:nz_) = vb(2, 1:nx_, 2:ny_+1, 1:nz_) + vxyzb
    vxyz = v(3, 1:nx_, 1:ny_, 2:nz_+1)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 1), diagsb(:, 1))
    vb(3, 1:nx_, 1:ny_, 2:nz_+1) = vb(3, 1:nx_, 1:ny_, 2:nz_+1) + vxyzb
  END SUBROUTINE GENA_B
!
! Generate A matrix
!
  SUBROUTINE GENA(v, q, annz, arow_index, arow_compressed, acol_index, &
&   avalues)
    IMPLICIT NONE
    INTEGER, DIMENSION(7) :: idiags
    DOUBLE PRECISION, DIMENSION(n_) :: q
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diags
    DOUBLE PRECISION, DIMENSION(n_) :: diag_tmp
! V has an extra length
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
! across each x, y, z
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: vxyz
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
! initialize diags
    diags = 0.0d0
! reshape arrays first
    vxyz = v(3, 1:nx_, 1:ny_, 2:nz_+1)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 1))
! z2
    vxyz = v(2, 1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 2))
! y2
    vxyz = v(1, 2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 3))
! x2
    vxyz = v(1, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 5))
! x1
    vxyz = v(2, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 6))
! y1
    vxyz = v(3, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 7))
! z1
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 1), 0.0d0, diag_tmp)
    diags(:, 1) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 2), 0.0d0, diag_tmp)
    diags(:, 2) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 3), 0.0d0, diag_tmp)
    diags(:, 3) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 5), 0.0d0, diag_tmp)
    diags(:, 5) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 6), 0.0d0, diag_tmp)
    diags(:, 6) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 7), 0.0d0, diag_tmp)
    diags(:, 7) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(q, 0.0d0, diag_tmp)
    diags(:, 4) = diag_tmp - diags(:, 5) - diags(:, 3) - diags(:, 6) - &
&     diags(:, 2) - diags(:, 7) - diags(:, 1)
    CALL SPDIAGS_FVM_CSR(diags, annz, arow_index, arow_compressed, &
&                  acol_index, avalues)
  END SUBROUTINE GENA
!  Differentiation of tpfa in reverse (adjoint) mode:
!   gradient     of useful results: p q v
!   with respect to varying inputs: k p q v
!
! Two point flux approximation.
!
  SUBROUTINE TPFA_B(k, kb, q, qb, p, pb, v, vb)
    IMPLICIT NONE
    INTEGER :: i
    INTEGER, DIMENSION(7) :: idiags
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diags
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diagsb
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qb
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: k
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: kb
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vb
! local variables
    DOUBLE PRECISION :: tx_, ty_, tz_
    DOUBLE PRECISION, DIMENSION(nx_ + 1, ny_, nz_) :: tx
    DOUBLE PRECISION, DIMENSION(nx_+1, ny_, nz_) :: txb
    DOUBLE PRECISION, DIMENSION(nx_, ny_ + 1, nz_) :: ty
    DOUBLE PRECISION, DIMENSION(nx_, ny_+1, nz_) :: tyb
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_ + 1) :: tz
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_+1) :: tzb
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: txyz
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: txyzb
! solution to the linear system
    DOUBLE PRECISION, DIMENSION(n_) :: u
    DOUBLE PRECISION, DIMENSION(n_) :: ub
! point-wise inverse of permeability
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: l
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: lb
! sparse matrix
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesb
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTRINSIC MOD
    INTEGER :: branch
    DOUBLE PRECISION :: temp1(nx_, ny_, nz_-1)
    DOUBLE PRECISION :: temp0(nx_, ny_-1, nz_)
    DOUBLE PRECISION :: tempb4(nx_-1, 10, 2)
    DOUBLE PRECISION :: tempb3(10, ny_-1, 2)
    DOUBLE PRECISION :: tempb2(10, 10, nz_-1)
    DOUBLE PRECISION :: tempb1(nx_-1, ny_, nz_)
    DOUBLE PRECISION :: tempb0(nx_, ny_-1, nz_)
    DOUBLE PRECISION :: tempb(nx_, ny_, nz_-1)
    DOUBLE PRECISION :: temp(nx_-1, ny_, nz_)
! get the point-wise inverse of the permeability matrix
    l = 1.0d0/k
    tx_ = 2.0d0*hy_*hz_/hx_
    ty_ = 2.0d0*hx_*hz_/hy_
    tz_ = 2.0d0*hy_*hx_/hz_
    tx = 0.0d0
    ty = 0.0d0
    tz = 0.0d0
! Compute transmissibilities by averaging harmonically
    tx(2:nx_, 1:ny_, 1:nz_) = tx_/(l(1, 1:nx_-1, 1:ny_, 1:nz_)+l(1, 2:&
&     nx_, 1:ny_, 1:nz_))
    ty(1:nx_, 2:ny_, 1:nz_) = ty_/(l(2, 1:nx_, 1:ny_-1, 1:nz_)+l(2, 1:&
&     nx_, 2:ny_, 1:nz_))
    tz(1:nx_, 1:ny_, 2:nz_) = tz_/(l(3, 1:nx_, 1:ny_, 1:nz_-1)+l(3, 1:&
&     nx_, 1:ny_, 2:nz_))
! initialize diags
    diags = 0.0d0
    txyz = -tx(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 5))
! -x1
    txyz = -ty(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 6))
! -y1
    txyz = -tz(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 7))
! -z1
    txyz = -tx(2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 3))
! -x2
    txyz = -ty(1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 2))
! -y2
    txyz = -tz(1:nx_, 1:ny_, 2:nz_+1)
    CALL MYRESHAPE_3_1(txyz, diags(:, 1))
! -z2
! Assemble discretization matrix
    diags(:, 4) = -(diags(:, 1)+diags(:, 2)+diags(:, 3)+diags(:, 5)+&
&     diags(:, 6)+diags(:, 7))
    CALL SPDIAGS_FVM_CSR(diags, annz, arow_index, arow_compressed, &
&                  acol_index, avalues)
! ! Increment the 1,1 element of A
!     call addx_elem(annz, arow_index, arow_compressed,&
!                     acol_index, avalues, &
!                     PERM(1,1,1,1) + PERM(2,1,1,1) + PERM(3,1,1,1), 1, 1)
! Fix the pressure at the inlets
    DO i=1,annz
      IF (arow_index(i) .LT. nx_*ny_ .AND. MOD(arow_index(i), ny_) .EQ. &
&         1) THEN
        IF (arow_index(i) .EQ. acol_index(i)) THEN
          avalues(i) = 1
          CALL PUSHCONTROL2B(2)
        ELSE
          avalues(i) = 0
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
! solve the linear system
! Pass the rows_index, cols_index, values separately.
    CALL PUSHREAL8ARRAY(u, 200)
    CALL SOLVE(annz, arow_index, arow_compressed, acol_index, avalues, q&
&        , u)
! reshape the solution
    CALL PUSHREAL8ARRAY(p, 10**2*2)
    CALL MYRESHAPE_1_3(u, p)
! V.x
! V.y
! V.z
    tzb = 0.D0
    tempb2 = tz(:, :, 2:nz_)*vb(3, 1:nx_, 1:ny_, 2:nz_)
    pb(:, :, 1:nz_-1) = pb(:, :, 1:nz_-1) + tempb2
    pb(:, :, 2:nz_) = pb(:, :, 2:nz_) - tempb2
    tzb(:, :, 2:nz_) = tzb(:, :, 2:nz_) + (p(:, :, 1:nz_-1)-p(:, :, 2:&
&     nz_))*vb(3, 1:nx_, 1:ny_, 2:nz_)
    vb(3, 1:nx_, 1:ny_, 2:nz_) = 0.D0
    tyb = 0.D0
    tempb3 = ty(:, 2:ny_, :)*vb(2, 1:nx_, 2:ny_, 1:nz_)
    pb(:, 1:ny_-1, :) = pb(:, 1:ny_-1, :) + tempb3
    pb(:, 2:ny_, :) = pb(:, 2:ny_, :) - tempb3
    tyb(:, 2:ny_, :) = tyb(:, 2:ny_, :) + (p(:, 1:ny_-1, :)-p(:, 2:ny_, &
&     :))*vb(2, 1:nx_, 2:ny_, 1:nz_)
    vb(2, 1:nx_, 2:ny_, 1:nz_) = 0.D0
    txb = 0.D0
    tempb4 = tx(2:nx_, :, :)*vb(1, 2:nx_, 1:ny_, 1:nz_)
    pb(1:nx_-1, :, :) = pb(1:nx_-1, :, :) + tempb4
    pb(2:nx_, :, :) = pb(2:nx_, :, :) - tempb4
    txb(2:nx_, :, :) = txb(2:nx_, :, :) + (p(1:nx_-1, :, :)-p(2:nx_, :, &
&     :))*vb(1, 2:nx_, 1:ny_, 1:nz_)
    vb(1, 2:nx_, 1:ny_, 1:nz_) = 0.D0
    CALL POPREAL8ARRAY(p, 10**2*2)
    CALL MYRESHAPE_1_3_B(u, ub, p, pb)
    CALL POPREAL8ARRAY(u, 200)
    avaluesb = 0.D0
    CALL SOLVE_B(annz, arow_index, arow_compressed, acol_index, avalues&
&          , avaluesb, q, qb, u, ub)
    DO i=annz,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          avaluesb(i) = 0.D0
        ELSE
          avaluesb(i) = 0.D0
        END IF
      END IF
    END DO
    CALL SPDIAGS_FVM_CSR_B(diags, diagsb, annz, arow_index, &
&                    arow_compressed, acol_index, avalues, avaluesb)
    diagsb(:, 1) = diagsb(:, 1) - diagsb(:, 4)
    diagsb(:, 2) = diagsb(:, 2) - diagsb(:, 4)
    diagsb(:, 3) = diagsb(:, 3) - diagsb(:, 4)
    diagsb(:, 5) = diagsb(:, 5) - diagsb(:, 4)
    diagsb(:, 6) = diagsb(:, 6) - diagsb(:, 4)
    diagsb(:, 7) = diagsb(:, 7) - diagsb(:, 4)
    diagsb(:, 4) = 0.D0
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 1), diagsb(:, 1))
    tzb(:, :, 2:nz_+1) = tzb(:, :, 2:nz_+1) - txyzb
    txyz = -ty(1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 2), diagsb(:, 2))
    tyb(:, 2:ny_+1, :) = tyb(:, 2:ny_+1, :) - txyzb
    txyz = -tx(2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 3), diagsb(:, 3))
    txb(2:nx_+1, :, :) = txb(2:nx_+1, :, :) - txyzb
    txyz = -tz(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 7), diagsb(:, 7))
    tzb(:, :, 1:nz_) = tzb(:, :, 1:nz_) - txyzb
    txyz = -ty(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 6), diagsb(:, 6))
    tyb(:, 1:ny_, :) = tyb(:, 1:ny_, :) - txyzb
    txyz = -tx(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 5), diagsb(:, 5))
    txb(1:nx_, :, :) = txb(1:nx_, :, :) - txyzb
    lb = 0.D0
    temp1 = l(3, 1:nx_, 1:ny_, 1:nz_-1) + l(3, 1:nx_, 1:ny_, 2:nz_)
    tempb = -(tz_*tzb(1:nx_, 1:ny_, 2:nz_)/temp1**2)
    lb(3, :, :, 1:nz_-1) = lb(3, :, :, 1:nz_-1) + tempb
    lb(3, :, :, 2:nz_) = lb(3, :, :, 2:nz_) + tempb
    temp0 = l(2, 1:nx_, 1:ny_-1, 1:nz_) + l(2, 1:nx_, 2:ny_, 1:nz_)
    tempb0 = -(ty_*tyb(1:nx_, 2:ny_, 1:nz_)/temp0**2)
    lb(2, :, 1:ny_-1, :) = lb(2, :, 1:ny_-1, :) + tempb0
    lb(2, :, 2:ny_, :) = lb(2, :, 2:ny_, :) + tempb0
    temp = l(1, 1:nx_-1, 1:ny_, 1:nz_) + l(1, 2:nx_, 1:ny_, 1:nz_)
    tempb1 = -(tx_*txb(2:nx_, 1:ny_, 1:nz_)/temp**2)
    lb(1, 1:nx_-1, :, :) = lb(1, 1:nx_-1, :, :) + tempb1
    lb(1, 2:nx_, :, :) = lb(1, 2:nx_, :, :) + tempb1
    kb = 0.D0
    kb = -(lb/k**2)
  END SUBROUTINE TPFA_B
!
! Two point flux approximation.
!
  SUBROUTINE TPFA(k, q, p, v)
    IMPLICIT NONE
    INTEGER :: i
    INTEGER, DIMENSION(7) :: idiags
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diags
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: k
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
! local variables
    DOUBLE PRECISION :: tx_, ty_, tz_
    DOUBLE PRECISION, DIMENSION(nx_ + 1, ny_, nz_) :: tx
    DOUBLE PRECISION, DIMENSION(nx_, ny_ + 1, nz_) :: ty
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_ + 1) :: tz
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: txyz
! solution to the linear system
    DOUBLE PRECISION, DIMENSION(n_) :: u
! point-wise inverse of permeability
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: l
! sparse matrix
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTRINSIC MOD
! get the point-wise inverse of the permeability matrix
    l = 1.0d0/k
    tx_ = 2.0d0*hy_*hz_/hx_
    ty_ = 2.0d0*hx_*hz_/hy_
    tz_ = 2.0d0*hy_*hx_/hz_
    tx = 0.0d0
    ty = 0.0d0
    tz = 0.0d0
! Compute transmissibilities by averaging harmonically
    tx(2:nx_, 1:ny_, 1:nz_) = tx_/(l(1, 1:nx_-1, 1:ny_, 1:nz_)+l(1, 2:&
&     nx_, 1:ny_, 1:nz_))
    ty(1:nx_, 2:ny_, 1:nz_) = ty_/(l(2, 1:nx_, 1:ny_-1, 1:nz_)+l(2, 1:&
&     nx_, 2:ny_, 1:nz_))
    tz(1:nx_, 1:ny_, 2:nz_) = tz_/(l(3, 1:nx_, 1:ny_, 1:nz_-1)+l(3, 1:&
&     nx_, 1:ny_, 2:nz_))
! initialize diags
    diags = 0.0d0
    txyz = -tx(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 5))
! -x1
    txyz = -ty(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 6))
! -y1
    txyz = -tz(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 7))
! -z1
    txyz = -tx(2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 3))
! -x2
    txyz = -ty(1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 2))
! -y2
    txyz = -tz(1:nx_, 1:ny_, 2:nz_+1)
    CALL MYRESHAPE_3_1(txyz, diags(:, 1))
! -z2
! Assemble discretization matrix
    diags(:, 4) = -(diags(:, 1)+diags(:, 2)+diags(:, 3)+diags(:, 5)+&
&     diags(:, 6)+diags(:, 7))
    CALL SPDIAGS_FVM_CSR(diags, annz, arow_index, arow_compressed, &
&                  acol_index, avalues)
! ! Increment the 1,1 element of A
!     call addx_elem(annz, arow_index, arow_compressed,&
!                     acol_index, avalues, &
!                     PERM(1,1,1,1) + PERM(2,1,1,1) + PERM(3,1,1,1), 1, 1)
! Fix the pressure at the inlets
    DO i=1,annz
      IF (arow_index(i) .LT. nx_*ny_ .AND. MOD(arow_index(i), ny_) .EQ. &
&         1) THEN
        IF (arow_index(i) .EQ. acol_index(i)) THEN
          avalues(i) = 1
        ELSE
          avalues(i) = 0
        END IF
      END IF
    END DO
! solve the linear system
! Pass the rows_index, cols_index, values separately.
    CALL SOLVE(annz, arow_index, arow_compressed, acol_index, avalues, q&
&        , u)
! reshape the solution
    CALL MYRESHAPE_1_3(u, p)
! V.x
! V.y
! V.z
    v(1, 2:nx_, 1:ny_, 1:nz_) = (p(1:nx_-1, :, :)-p(2:nx_, :, :))*tx(2:&
&     nx_, :, :)
! V.y
    v(2, 1:nx_, 2:ny_, 1:nz_) = (p(:, 1:ny_-1, :)-p(:, 2:ny_, :))*ty(:, &
&     2:ny_, :)
! V.z
    v(3, 1:nx_, 1:ny_, 2:nz_) = (p(:, :, 1:nz_-1)-p(:, :, 2:nz_))*tz(:, &
&     :, 2:nz_)
  END SUBROUTINE TPFA
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
! orow_compressed is not populated.
  SUBROUTINE SPDIAGS_FVM(imatrix, onnz, orow_index, orow_compressed, &
&   ocol_index, ovalues)
    IMPLICIT NONE
    LOGICAL :: done
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, start_row_imatrix, end_row_imatrix, row, col
    DOUBLE PRECISION, DIMENSION(n_, 7) :: imatrix
    INTEGER, DIMENSION(7), PARAMETER :: idiags=(/-(nx_*ny_), -nx_, -1, 0&
&     , 1, nx_, nx_*ny_/)
    INTEGER :: onnz
    INTEGER, DIMENSION(7*n_) :: orow_index
    INTEGER, DIMENSION(7*n_) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ovalues
    INTEGER, DIMENSION(n_ + 1) :: orow_compressed
    onnz = 0
    orow_compressed = 0
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix = idiags(i) + 1
        end_row_imatrix = n_
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix = 1
        end_row_imatrix = n_ + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row, col)
      DO j=start_row_imatrix,end_row_imatrix
        IF (row .EQ. col .OR. imatrix(j, i) .NE. 0) THEN
          onnz = onnz + 1
          orow_index(onnz) = row
          ocol_index(onnz) = col
          ovalues(onnz) = imatrix(j, i)
        END IF
        row = row + 1
        col = col + 1
      END DO
    END DO
  END SUBROUTINE SPDIAGS_FVM
!  Differentiation of spdiags_fvm_csr in reverse (adjoint) mode:
!   gradient     of useful results: ovalues
!   with respect to varying inputs: imatrix
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
!
  SUBROUTINE SPDIAGS_FVM_CSR_B(imatrix, imatrixb, onnz, orow_index, &
&   orow_compressed, ocol_index, ovalues, ovaluesb)
    IMPLICIT NONE
    LOGICAL :: done
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, rownnz
    DOUBLE PRECISION, DIMENSION(n_, 7) :: imatrix
    DOUBLE PRECISION, DIMENSION(n_, 7) :: imatrixb
    INTEGER, DIMENSION(7), PARAMETER :: idiags=(/-(nx_*ny_), -nx_, -1, 0&
&     , 1, nx_, nx_*ny_/)
    INTEGER, DIMENSION(7) :: start_row_imatrix, end_row_imatrix
! row, column along diagonal
    INTEGER, DIMENSION(7) :: row_diag, col_diag
    INTEGER :: onnz
    INTEGER, DIMENSION(7*n_) :: orow_index
    INTEGER, DIMENSION(7*n_) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ovalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: ovaluesb
    INTEGER, DIMENSION(n_ + 1) :: orow_compressed
    INTEGER :: branch
    onnz = 0
! compressed row storage
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix(i) = idiags(i) + 1
        end_row_imatrix(i) = n_
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix(i) = 1
        end_row_imatrix(i) = n_ + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row_diag(i), col_diag(i))
    END DO
! Do for each row in imatrix
    DO i=1,n_
! Do for each column in imatrix
      DO j=1,7
! Need to check if that column has any entry in this row
! checks that you are past the beginning of diagonal, remains fixed
        IF (row_diag(j) .LE. i .AND. start_row_imatrix(j) .LE. &
&           end_row_imatrix(j)) THEN
! checks that you have not exhausted the diagonal
          IF (imatrix(start_row_imatrix(j), j) .NE. 0.0d0) THEN
! checks that the diagonal entry is non zero
            CALL PUSHINTEGER4(onnz)
            onnz = onnz + 1
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHINTEGER4(start_row_imatrix(j))
          start_row_imatrix(j) = start_row_imatrix(j) + 1
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    imatrixb = 0.D0
    DO i=n_,1,-1
      DO j=7,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPINTEGER4(start_row_imatrix(j))
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            imatrixb(start_row_imatrix(j), j) = imatrixb(&
&             start_row_imatrix(j), j) + ovaluesb(onnz)
            ovaluesb(onnz) = 0.D0
            CALL POPINTEGER4(onnz)
          END IF
        END IF
      END DO
    END DO
  END SUBROUTINE SPDIAGS_FVM_CSR_B
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
!
  SUBROUTINE SPDIAGS_FVM_CSR(imatrix, onnz, orow_index, orow_compressed&
&   , ocol_index, ovalues)
    IMPLICIT NONE
    LOGICAL :: done
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, rownnz
    DOUBLE PRECISION, DIMENSION(n_, 7) :: imatrix
    INTEGER, DIMENSION(7), PARAMETER :: idiags=(/-(nx_*ny_), -nx_, -1, 0&
&     , 1, nx_, nx_*ny_/)
    INTEGER, DIMENSION(7) :: start_row_imatrix, end_row_imatrix
! row, column along diagonal
    INTEGER, DIMENSION(7) :: row_diag, col_diag
    INTEGER :: onnz
    INTEGER, DIMENSION(7*n_) :: orow_index
    INTEGER, DIMENSION(7*n_) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ovalues
    INTEGER, DIMENSION(n_ + 1) :: orow_compressed
    onnz = 0
! compressed row storage
    orow_compressed(1) = 1
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix(i) = idiags(i) + 1
        end_row_imatrix(i) = n_
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix(i) = 1
        end_row_imatrix(i) = n_ + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row_diag(i), col_diag(i))
    END DO
! Do for each row in imatrix
    DO i=1,n_
! count the number of nonzeros in row
      rownnz = 0
! Do for each column in imatrix
      DO j=1,7
! Need to check if that column has any entry in this row
! checks that you are past the beginning of diagonal, remains fixed
        IF (row_diag(j) .LE. i .AND. start_row_imatrix(j) .LE. &
&           end_row_imatrix(j)) THEN
! checks that you have not exhausted the diagonal
          IF (imatrix(start_row_imatrix(j), j) .NE. 0.0d0) THEN
! checks that the diagonal entry is non zero
            onnz = onnz + 1
            rownnz = rownnz + 1
            orow_index(onnz) = i
            ocol_index(onnz) = col_diag(j)
            ovalues(onnz) = imatrix(start_row_imatrix(j), j)
          END IF
          start_row_imatrix(j) = start_row_imatrix(j) + 1
          col_diag(j) = col_diag(j) + 1
        END IF
      END DO
      orow_compressed(i+1) = orow_compressed(i) + rownnz
    END DO
  END SUBROUTINE SPDIAGS_FVM_CSR
END MODULE FINITEVOLUME_B

MODULE SIMULATION_B
  USE PARAMETERS_B
  USE MATRIX_B
  USE FINITEVOLUME_B
  IMPLICIT NONE

CONTAINS
!
! This routine opens the permeability and porosity used by
! the MATLAB program and uses it for the simulation.
!
  SUBROUTINE READ_PERMEABILITY_AND_POROSITY(perm, por)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
! Porosities
    DOUBLE PRECISION, DIMENSION(n_), INTENT(OUT) :: por
! Permeabilities
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_), INTENT(OUT) :: perm
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(maxnx*maxny*maxnz) :: pur
    DOUBLE PRECISION, DIMENSION(3*maxnx, maxny*maxnz) :: kur
    DOUBLE PRECISION, DIMENSION(3*maxnx*maxny*maxnz) :: kurl
    INTEGER, DIMENSION(nx_*ny_*nz_) :: pindices
    INTEGER, DIMENSION(3*nx_*ny_*nz_) :: kindices
! initialize porosity and permeability to zero
    perm = 0.0d0
    por = 0.0d0
! read KUr
    OPEN(1, file=permeability_file, status='old') 
    READ(1, *) ((kur(i, j), j=1,maxny*maxnz), i=1,3*maxnx)
    CLOSE(1) 
! reshape 2 dimension to 1 dimension
    CALL MYRESHAPE_2_1(kur, kurl)
! select according to specified dimension
    m = 0
    DO l=1,nz_
      DO k=1,ny_
        DO j=1,nx_
          DO i=1,3
            m = m + 1
            kindices(m) = (l-1)*(maxnx*maxny*3) + (k-1)*(maxnx*3) + 3*(j&
&             -1) + i
          END DO
        END DO
      END DO
    END DO
! then reshape 1 dimension to 4 dimension (hack for time being)
    CALL MYRESHAPE_1_4(kurl(kindices), perm)
! read KUr
    OPEN(1, file=porosity_file, status='old') 
    READ(1, *) (pur(i), i=1,maxnx*maxny*maxnz)
    CLOSE(1) 
    m = 0
    DO k=1,nz_
      DO j=1,ny_
        DO i=1,nx_
          m = m + 1
          pindices(m) = (k-1)*(maxnx*maxny) + (j-1)*maxnx + i
        END DO
      END DO
    END DO
    CALL MYMAX_1_0_DOUBLE(pur(pindices), 1.0d-3, por)
  END SUBROUTINE READ_PERMEABILITY_AND_POROSITY
!  Differentiation of wrapper in reverse (adjoint) mode:
!   gradient     of useful results: oil
!   with respect to varying inputs: sigma oil mu
!   RW status of diff variables: sigma:out oil:in-zero mu:out
  SUBROUTINE WRAPPER_B(mu, mub, sigma, sigmab, q, s, p, v, tt, pc, oil, &
&   oilb)
    IMPLICIT NONE
    DOUBLE PRECISION :: mu, sigma
    DOUBLE PRECISION :: mub, sigmab
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qb
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION :: oil
    DOUBLE PRECISION :: oilb
    CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT(mu, sigma, q)
    CALL SIMULATE_RESERVOIR_B(q, qb, s, p, v, tt, pc, oil, oilb)
    CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT_B(mu, mub, sigma, sigmab, q, qb)
    oilb = 0.D0
  END SUBROUTINE WRAPPER_B
!  Differentiation of init_flw_trnc_norm_xin_pt_out in reverse (adjoint) mode:
!   gradient     of useful results: q
!   with respect to varying inputs: sigma mu
!
! Initialize inflow and outflow.
!
  SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT_B(mu, mub, sigma, sigmab, q, &
&   qb)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: mu, sigma
    DOUBLE PRECISION :: mub, sigmab
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qb
    INTEGER :: i, j
    DOUBLE PRECISION :: x, pi, pdf, mass
    DOUBLE PRECISION :: pdfb, massb
    DOUBLE PRECISION, DIMENSION(nx_) :: idx
    DOUBLE PRECISION, DIMENSION(nx_) :: q_x
    DOUBLE PRECISION, DIMENSION(nx_) :: q_xb
    INTRINSIC SQRT
    INTRINSIC EXP
    DOUBLE PRECISION :: temp1
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb1(nx_)
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: temp
! value of pi
    pi = 3.14159265358979323d0
!initialize the total mass to 0
    mass = 0.0d0
    q_x = 0.0d0
! Note that the portion of the  Standard Normal distribution between
! -3sigma/2 to 3sigma/2 is assumed to fit the 1..Nx where sigma is 1
    DO i=1,nx_
! get the real x coordinate
! Mapping x = [-1.5, 1.5] to Nx_ dimension
      x = -1.5d0 + (i-1)*3.0d0/(nx_-1)
! Now use mu and sigma to find the pdf value at x
      pdf = 1.0d0/(sigma*SQRT(2.0d0*pi))*EXP(-(((x-mu)/sigma)**2.0d0/&
&       2.0d0))
! set the value at the index equal to the pdf value at that point
      q_x(i) = pdf
! increment the mass by the value of the pdf
      mass = mass + pdf
! index to test initialization by plot
    END DO
! now rescale all the entities
! Assign Q_x to Q
    j = 1
    DO i=1,nx_*ny_,ny_
      CALL PUSHINTEGER4(j)
      j = j + 1
    END DO
    qb(n_) = 0.D0
    q_xb = 0.D0
    DO i=nx_*ny_-MOD(nx_*ny_-1, ny_),1,-ny_
      CALL POPINTEGER4(j)
      q_xb(j) = q_xb(j) + qb(i)
      qb(i) = 0.D0
    END DO
    tempb1 = ir*q_xb/mass
    massb = SUM(-(q_x*tempb1/mass))
    q_xb = tempb1
    sigmab = 0.D0
    mub = 0.D0
    DO i=nx_,1,-1
      pdfb = q_xb(i) + massb
      q_xb(i) = 0.D0
      x = -1.5d0 + (i-1)*3.0d0/(nx_-1)
      temp1 = SQRT(2.0d0*pi)
      tempb = pdfb/(temp1*sigma)
      temp = (x-mu)/sigma
      temp0 = -(temp**2.0d0/2.0d0)
      tempb0 = -(temp*EXP(temp0)*tempb/sigma)
      mub = mub - tempb0
      sigmab = sigmab - EXP(temp0)*tempb/sigma - temp*tempb0
    END DO
  END SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT_B
!  Differentiation of simulate_reservoir in reverse (adjoint) mode:
!   gradient     of useful results: oil
!   with respect to varying inputs: q
!
! This subroutine simulates the reservoir
! model.
!
  SUBROUTINE SIMULATE_RESERVOIR_B(q, qb, s, p, v, tt, pc, oil, oilb)
    USE PARAMETERS_B
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qb
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sb
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vb
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(2, nd/st+1) :: pcb
    DOUBLE PRECISION :: oil
    DOUBLE PRECISION :: oilb
    INTEGER :: i, j, k
    DOUBLE PRECISION :: mw, mo, mt, tempoil1, tempoil2
    DOUBLE PRECISION :: mwb, mob, mtb, tempoil1b, tempoil2b
    INTEGER :: branch
! initial saturation
    s = swc_
! initial production
! initial time.
    k = 1
    DO i=1,nd/pt
      DO j=1,pt/st
        CALL PUSHINTEGER4(k)
        k = k + 1
        IF (j .EQ. 1) THEN
          CALL PUSHREAL8(mo)
          CALL PUSHREAL8(mw)
          CALL PUSHREAL8ARRAY(v, 3**2*11**2)
          CALL PUSHREAL8ARRAY(p, 10**2*2)
          CALL PUSHREAL8ARRAY(s, 200)
          CALL STEPFORWARD(.true., q, s, p, v, mw, mo)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(mo)
          CALL PUSHREAL8(mw)
          CALL PUSHREAL8ARRAY(v, 3**2*11**2)
          CALL PUSHREAL8ARRAY(p, 10**2*2)
          CALL PUSHREAL8ARRAY(s, 200)
          CALL STEPFORWARD(.false., q, s, p, v, mw, mo)
          CALL PUSHCONTROL1B(1)
        END IF
! update quantites
        CALL PUSHREAL8(mt)
        mt = mw + mo
      END DO
    END DO
    tempoil2b = oilb
    pb = 0.D0
    qb = 0.D0
    sb = 0.D0
    vb = 0.D0
    pcb = 0.D0
    tempoil1b = 0.D0
    DO i=nd/pt,1,-1
      DO j=pt/st,1,-1
        tempoil2b = tempoil2b + tempoil1b
        CALL UPDATE_OIL_B(pc, pcb, k, st, tempoil1, tempoil1b, tempoil2&
&                   , tempoil2b)
        mob = pcb(2, k)/mt
        mtb = -(mo*pcb(2, k)/mt**2)
        pcb(2, k) = 0.D0
        mtb = mtb - mw*pcb(1, k)/mt**2
        mwb = mtb + pcb(1, k)/mt
        pcb(1, k) = 0.D0
        CALL POPREAL8(mt)
        mob = mob + mtb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(s, 200)
          CALL POPREAL8ARRAY(p, 10**2*2)
          CALL POPREAL8ARRAY(v, 3**2*11**2)
          CALL POPREAL8(mw)
          CALL POPREAL8(mo)
          CALL STEPFORWARD_B(.true., q, qb, s, sb, p, pb, v, vb, mw, mwb&
&                      , mo, mob)
        ELSE
          CALL POPREAL8ARRAY(s, 200)
          CALL POPREAL8ARRAY(p, 10**2*2)
          CALL POPREAL8ARRAY(v, 3**2*11**2)
          CALL POPREAL8(mw)
          CALL POPREAL8(mo)
          CALL STEPFORWARD_B(.false., q, qb, s, sb, p, pb, v, vb, mw, &
&                      mwb, mo, mob)
        END IF
        CALL POPINTEGER4(k)
        tempoil2b = 0.D0
      END DO
    END DO
  END SUBROUTINE SIMULATE_RESERVOIR_B
!  Differentiation of stepforward in reverse (adjoint) mode:
!   gradient     of useful results: p q s v mo mw
!   with respect to varying inputs: p q s v
  SUBROUTINE STEPFORWARD_B(pressure_step, q, qb, s, sb, p, pb, v, vb, mw&
&   , mwb, mo, mob)
    IMPLICIT NONE
! Mobilities in well-block
    LOGICAL :: pressure_step
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qb
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sb
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vb
    DOUBLE PRECISION :: mw, mo
    DOUBLE PRECISION :: mwb, mob
    INTEGER :: branch
    IF (pressure_step .EQ. .true.) THEN
! solve pressure
      CALL PUSHREAL8ARRAY(p, 10**2*2)
      CALL PRES(q, s, p, v)
! Pressure solver
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8ARRAY(s, 200)
    CALL NEWTRAPH(q, v, s)
! Solve for saturation
    CALL RELPERM_B(s(n_), sb(n_), mw, mwb, mo, mob)
    CALL POPREAL8ARRAY(s, 200)
    CALL NEWTRAPH_B(q, qb, v, vb, s, sb)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(p, 10**2*2)
      CALL PRES_B(q, qb, s, sb, p, pb, v, vb)
    END IF
  END SUBROUTINE STEPFORWARD_B
!  Differentiation of update_oil in reverse (adjoint) mode:
!   gradient     of useful results: oilout pc
!   with respect to varying inputs: oilin pc
  SUBROUTINE UPDATE_OIL_B(pc, pcb, k, st, oilin, oilinb, oilout, oiloutb&
& )
    IMPLICIT NONE
    INTEGER :: st, k
    DOUBLE PRECISION :: oilin
    DOUBLE PRECISION :: oilinb
    DOUBLE PRECISION :: oilout
    DOUBLE PRECISION :: oiloutb
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(2, nd/st+1) :: pcb
! Reimann sum
    oilinb = oiloutb
    pcb(2, k) = pcb(2, k) + st*oiloutb
  END SUBROUTINE UPDATE_OIL_B
  SUBROUTINE WRAPPER(mu, sigma, q, s, p, v, tt, pc, oil)
    IMPLICIT NONE
    DOUBLE PRECISION :: mu, sigma
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION :: oil
    CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT(mu, sigma, q)
    CALL SIMULATE_RESERVOIR(q, s, p, v, tt, pc, oil)
  END SUBROUTINE WRAPPER
!
! Initialize inflow and outflow.
!
  SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT(mu, sigma, q)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: mu, sigma
    DOUBLE PRECISION, DIMENSION(n_), INTENT(OUT) :: q
    INTEGER :: i, j
    DOUBLE PRECISION :: x, pi, pdf, mass
    DOUBLE PRECISION, DIMENSION(nx_) :: idx
    DOUBLE PRECISION, DIMENSION(nx_) :: q_x
    INTRINSIC SQRT
    INTRINSIC EXP
! value of pi
    pi = 3.14159265358979323d0
!initialize the total mass to 0
    mass = 0.0d0
    q_x = 0.0d0
! Note that the portion of the  Standard Normal distribution between
! -3sigma/2 to 3sigma/2 is assumed to fit the 1..Nx where sigma is 1
    DO i=1,nx_
! get the real x coordinate
! Mapping x = [-1.5, 1.5] to Nx_ dimension
      x = -1.5d0 + (i-1)*3.0d0/(nx_-1)
! Now use mu and sigma to find the pdf value at x
      pdf = 1.0d0/(sigma*SQRT(2.0d0*pi))*EXP(-(((x-mu)/sigma)**2.0d0/&
&       2.0d0))
! set the value at the index equal to the pdf value at that point
      q_x(i) = pdf
! increment the mass by the value of the pdf
      mass = mass + pdf
! index to test initialization by plot
      idx(i) = i*1.0
    END DO
! now rescale all the entities
! Assign Q_x to Q
    q_x = q_x/mass*ir
! Assign Q_x to Q
    j = 1
    DO i=1,nx_*ny_,ny_
      q(i) = q_x(j)
      j = j + 1
    END DO
! now set the output
    q(n_) = -ir
  END SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT
!
! This subroutine simulates the reservoir
! model.
!
  SUBROUTINE SIMULATE_RESERVOIR(q, s, p, v, tt, pc, oil)
    USE PARAMETERS_B
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION :: oil
    INTEGER :: i, j, k
    DOUBLE PRECISION :: mw, mo, mt, tempoil1, tempoil2
! initial saturation
    s = swc_
! initial production
! initial time.
    pc(1, 1) = 0.0d0
    pc(2, 1) = 1.0d0
! initial time.
    tt(1) = 0.0d0
    tempoil1 = 0.0d0
    tempoil2 = 0.0d0
    k = 1
    DO i=1,nd/pt
      DO j=1,pt/st
        k = k + 1
        IF (j .EQ. 1) THEN
          CALL STEPFORWARD(.true., q, s, p, v, mw, mo)
        ELSE
          CALL STEPFORWARD(.false., q, s, p, v, mw, mo)
        END IF
! update quantites
        mt = mw + mo
        tt(k) = 1.0d0*k*st
        pc(1, k) = mw/mt
        pc(2, k) = mo/mt
        CALL UPDATE_OIL(pc, k, st, tempoil1, tempoil2)
        tempoil1 = tempoil2
      END DO
    END DO
    oil = tempoil2
  END SUBROUTINE SIMULATE_RESERVOIR
  SUBROUTINE STEPFORWARD(pressure_step, q, s, p, v, mw, mo)
    IMPLICIT NONE
! Mobilities in well-block
    LOGICAL :: pressure_step
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION :: mw, mo
    IF (pressure_step .EQV. .true.) CALL PRES(q, s, p, v)
! solve pressure
! Pressure solver
    CALL NEWTRAPH(q, v, s)
! Solve for saturation
    CALL RELPERM(s(n_), mw, mo)
  END SUBROUTINE STEPFORWARD
  SUBROUTINE UPDATE_OIL(pc, k, st, oilin, oilout)
    IMPLICIT NONE
    INTEGER :: st, k
    DOUBLE PRECISION :: oilin
    DOUBLE PRECISION :: oilout
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
! Reimann sum
    oilout = oilin + pc(2, k)*st
  END SUBROUTINE UPDATE_OIL
END MODULE SIMULATION_B

