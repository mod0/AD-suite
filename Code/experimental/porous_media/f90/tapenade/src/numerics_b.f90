!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
MODULE PARAMETERS_B
  IMPLICIT NONE
! FIXED PARAMETERS
! grid parameters 
  INTEGER :: scenario_id
  DOUBLE PRECISION :: hx_, hy_, hz_, v_, ir
! fluid parameters
  DOUBLE PRECISION :: vw_, vo_, swc_, sor_
! PARAMETERS READ FROM FILE
! porosity and permeability parameters
! Porosities
  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: por
! Permeabilities  
  DOUBLE PRECISION, DIMENSION(:, :, :, :), ALLOCATABLE :: perm
! PARAMETERS SET IN DRIVER
! linear solver parameters
  LOGICAL :: verbose
  INTEGER :: solver_inner, solver_outer
END MODULE PARAMETERS_B

MODULE MATHUTIL_B
  IMPLICIT NONE
  PUBLIC dnrm2

CONTAINS
!
! Subroutine computes the 2 norm of the vector
! adapted from the original function version
! of the corresponding blas routine from
! NETLIB
!
  SUBROUTINE DNRM2(v, len_v, n)
    IMPLICIT NONE
    INTEGER :: i, len_v
    DOUBLE PRECISION :: n
    DOUBLE PRECISION, DIMENSION(len_v) :: v
    DOUBLE PRECISION :: scalein, scaleout
    INTRINSIC ABS
    INTRINSIC SQRT
    DOUBLE PRECISION :: abs0
    n = 0.0d0
    scalein = 0.0d0
    scaleout = 0.0d0
    DO i=1,len_v
      IF (v(i) .GE. 0.) THEN
        abs0 = v(i)
      ELSE
        abs0 = -v(i)
      END IF
      CALL SCALAR_MAX(scalein, abs0, scaleout)
      scalein = scaleout
    END DO
    IF (scaleout .EQ. 0.0d0) THEN
      n = 0.0d0
    ELSE
      DO i=1,len_v
        n = n + (v(i)/scaleout)**2
      END DO
      n = scaleout*SQRT(n)
    END IF
  END SUBROUTINE DNRM2
  SUBROUTINE SCALAR_MAX(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .LE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE SCALAR_MAX
END MODULE MATHUTIL_B

MODULE MATRIX_B
  USE PARAMETERS_B
  IMPLICIT NONE
! export module interface
!,disp_spmat
  PUBLIC myreshape, add_x, spmat_multiply, mymin, mymax
  PUBLIC myreshape_b, add_x_b, spmat_multiply_b, mymin_b, mymax_b
  INTERFACE MYRESHAPE
      MODULE PROCEDURE MYRESHAPE_1_2
      MODULE PROCEDURE MYRESHAPE_2_1
      MODULE PROCEDURE MYRESHAPE_1_3
      MODULE PROCEDURE MYRESHAPE_3_1
      MODULE PROCEDURE MYRESHAPE_1_4
      MODULE PROCEDURE MYRESHAPE_4_1
  END INTERFACE MYRESHAPE

  INTERFACE MYRESHAPE_B
      MODULE PROCEDURE MYRESHAPE_1_3_B
      MODULE PROCEDURE MYRESHAPE_3_1_B
      MODULE PROCEDURE MYRESHAPE_1_4_B
  END INTERFACE

  INTERFACE ADD_X
      MODULE PROCEDURE ADDX_ELEM
      MODULE PROCEDURE ADDX_DIAGONAL
  END INTERFACE ADD_X

  INTERFACE ADD_X_B
      MODULE PROCEDURE ADDX_DIAGONAL_B
  END INTERFACE

  INTERFACE SPMAT_MULTIPLY
      MODULE PROCEDURE SPMAT_MULTIPLY_DIAGONAL
      MODULE PROCEDURE SPMAT_MULTIPLY_VECTOR
      MODULE PROCEDURE SCALAR_MULTIPLY_SPMAT
  END INTERFACE SPMAT_MULTIPLY

  INTERFACE SPMAT_MULTIPLY_B
      MODULE PROCEDURE SPMAT_MULTIPLY_DIAGONAL_B
      MODULE PROCEDURE SPMAT_MULTIPLY_VECTOR_B
  END INTERFACE

  INTERFACE MYMIN
      MODULE PROCEDURE MYMIN_0_0_DOUBLE
      MODULE PROCEDURE MYMIN_1_0_DOUBLE
      MODULE PROCEDURE MYMIN_1_1_DOUBLE
  END INTERFACE MYMIN

  INTERFACE MYMIN_B
      MODULE PROCEDURE MYMIN_1_0_DOUBLE_B
  END INTERFACE

  INTERFACE MYMAX
      MODULE PROCEDURE MYMAX_0_0_DOUBLE
      MODULE PROCEDURE MYMAX_1_0_DOUBLE
      MODULE PROCEDURE MYMAX_1_1_DOUBLE
  END INTERFACE MYMAX

  INTERFACE MYMAX_B
      MODULE PROCEDURE MYMAX_1_0_DOUBLE_B
  END INTERFACE


CONTAINS
! !
! ! Display the matrix entries
! !
! subroutine disp_spmat(n, innz, irow_index, irow_compressed, icol_index, ivalues, output)
!     implicit none
!     integer :: k, output
!     integer :: n
!     integer :: innz
!     integer, dimension(7 * n) :: irow_index
!     integer, dimension(7 * n) :: icol_index
!     double precision, dimension(7 * n) :: ivalues
!     integer, dimension(n + 1) :: irow_compressed
!
!     if(output /= 0) then
!         do k = 1, innz
!             write (*, '(a, i7, a, i7, a, a, e23.16)'), "(", irow_index(k), ",", &
!                         icol_index(k), ")", " ", ivalues(k)
!         end do
!         write (*, *) irow_compressed
!     end if
! end subroutine disp_spmat
!
! Subroutine adds x to a particular element.
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix. Further the element may be non-existent. Structure of
! SPMAT has to be changed to allow arbitrary fill-ins.
!
  SUBROUTINE ADDX_ELEM(n, innz, irow_index, irow_compressed, icol_index&
&   , ivalues, x, row, col)
    IMPLICIT NONE
    DOUBLE PRECISION :: x
    INTEGER :: i, row, col
    INTEGER :: n, innz
    INTEGER, DIMENSION(7*n) :: irow_index
    INTEGER, DIMENSION(7*n) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: ivalues
    INTEGER, DIMENSION(n + 1) :: irow_compressed
    DO i=1,innz
      IF (irow_index(i) .EQ. row .AND. icol_index(i) .EQ. col) THEN
        ivalues(i) = ivalues(i) + x
        GOTO 100
      END IF
    END DO
 100 CONTINUE
  END SUBROUTINE ADDX_ELEM
!  Differentiation of addx_diagonal in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: ivalues
!   with respect to varying inputs: ivalues
!
! Subroutine adds x to a particular diagonal
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix
!
  SUBROUTINE ADDX_DIAGONAL_B(n, innz, irow_index, irow_compressed, &
&   icol_index, ivalues, ivaluesb, x, diag)
    IMPLICIT NONE
    INTEGER :: i, diag
    DOUBLE PRECISION :: x
    INTEGER :: n, innz
    INTEGER, DIMENSION(7*n) :: irow_index
    INTEGER, DIMENSION(7*n) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: ivalues
    DOUBLE PRECISION, DIMENSION(7*n) :: ivaluesb
    INTEGER, DIMENSION(n + 1) :: irow_compressed
  END SUBROUTINE ADDX_DIAGONAL_B
!
! Subroutine adds x to a particular diagonal
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix
!
  SUBROUTINE ADDX_DIAGONAL(n, innz, irow_index, irow_compressed, &
&   icol_index, ivalues, x, diag)
    IMPLICIT NONE
    INTEGER :: i, diag
    DOUBLE PRECISION :: x
    INTEGER :: n, innz
    INTEGER, DIMENSION(7*n) :: irow_index
    INTEGER, DIMENSION(7*n) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: ivalues
    INTEGER, DIMENSION(n + 1) :: irow_compressed
    DO i=1,innz
      IF (icol_index(i) - irow_index(i) .EQ. diag) ivalues(i) = ivalues(&
&         i) + x
    END DO
  END SUBROUTINE ADDX_DIAGONAL
!
! Gets the diagonal on which the row, col lie
!
  SUBROUTINE GETDIAG(row, col, diag)
    IMPLICIT NONE
    INTEGER :: diag, row, col
    diag = col - row
  END SUBROUTINE GETDIAG
!
! Gets the number of elements on the diagonal for a given output
! matrix size.
!
  SUBROUTINE NOELEMS(diag, orows, ocols, n)
    IMPLICIT NONE
    INTEGER :: diag, orows, ocols, row, col, n
    INTRINSIC MIN
! first element along diagonal
    CALL FIRSTELM(diag, row, col)
    IF (diag .LT. 0) THEN
! subdiagonal read from top
! number of elements along diagonal
      n = orows - row + 1
    ELSE IF (diag .EQ. 0) THEN
      IF (orows .GT. ocols) THEN
        n = ocols
      ELSE
        n = orows
      END IF
    ELSE
! super diagonal read from bottom (possible middle)
! number of elements along diagonal
      n = ocols - col + 1
    END IF
  END SUBROUTINE NOELEMS
!
! Gets the indices of the first element on
! diagonal
!
  SUBROUTINE FIRSTELM(diag, row, col)
    IMPLICIT NONE
    INTEGER :: diag, row, col
    IF (diag .LT. 0) THEN
      row = 1 - diag
      col = 1
    ELSE IF (diag .EQ. 0) THEN
      row = 1
      col = 1
    ELSE
      row = 1
      col = 1 + diag
    END IF
  END SUBROUTINE FIRSTELM
!
! Reshape a 2d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_2_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k
    DOUBLE PRECISION, DIMENSION(:, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    k = 0
    DO j=1,SIZE(amatrix, 2)
      DO i=1,SIZE(amatrix, 1)
        k = k + 1
        bmatrix(k) = amatrix(i, j)
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_2_1
!
! Reshape a 1d matrix to a 2D array
!
  SUBROUTINE MYRESHAPE_1_2(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :) :: bmatrix
    INTRINSIC SIZE
    k = 0
    DO j=1,SIZE(bmatrix, 2)
      DO i=1,SIZE(bmatrix, 1)
        k = k + 1
        bmatrix(i, j) = amatrix(k)
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_2
!  Differentiation of myreshape_3_1 in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: bmatrix
!   with respect to varying inputs: bmatrix amatrix
!
! Reshape a 3d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_3_1_B(amatrix, amatrixb, bmatrix, bmatrixb)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrixb
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrixb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    l = 0
    DO k=1,SIZE(amatrix, 3)
      DO j=1,SIZE(amatrix, 2)
        DO i=1,SIZE(amatrix, 1)
          CALL PUSHINTEGER4(l)
          l = l + 1
        END DO
        CALL PUSHINTEGER4(i - 1)
      END DO
      CALL PUSHINTEGER4(j - 1)
    END DO
    ad_to1 = k - 1
    amatrixb = 0.D0
    DO k=ad_to1,1,-1
      CALL POPINTEGER4(ad_to0)
      DO j=ad_to0,1,-1
        CALL POPINTEGER4(ad_to)
        DO i=ad_to,1,-1
          amatrixb(i, j, k) = amatrixb(i, j, k) + bmatrixb(l)
          bmatrixb(l) = 0.D0
          CALL POPINTEGER4(l)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_3_1_B
!
! Reshape a 3d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_3_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    l = 0
    DO k=1,SIZE(amatrix, 3)
      DO j=1,SIZE(amatrix, 2)
        DO i=1,SIZE(amatrix, 1)
          l = l + 1
          bmatrix(l) = amatrix(i, j, k)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_3_1
!  Differentiation of myreshape_1_3 in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: bmatrix
!   with respect to varying inputs: bmatrix amatrix
!
! Reshape a 1d matrix to a 3D array
!
  SUBROUTINE MYRESHAPE_1_3_B(amatrix, amatrixb, bmatrix, bmatrixb)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: amatrixb
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrixb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    l = 0
    DO k=1,SIZE(bmatrix, 3)
      DO j=1,SIZE(bmatrix, 2)
        DO i=1,SIZE(bmatrix, 1)
          CALL PUSHINTEGER4(l)
          l = l + 1
          bmatrix(i, j, k) = amatrix(l)
        END DO
        CALL PUSHINTEGER4(i - 1)
      END DO
      CALL PUSHINTEGER4(j - 1)
    END DO
    ad_to1 = k - 1
    amatrixb = 0.D0
    DO k=ad_to1,1,-1
      CALL POPINTEGER4(ad_to0)
      DO j=ad_to0,1,-1
        CALL POPINTEGER4(ad_to)
        DO i=ad_to,1,-1
          amatrixb(l) = amatrixb(l) + bmatrixb(i, j, k)
          bmatrixb(i, j, k) = 0.D0
          CALL POPINTEGER4(l)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_3_B
!
! Reshape a 1d matrix to a 3D array
!
  SUBROUTINE MYRESHAPE_1_3(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrix
    INTRINSIC SIZE
    l = 0
    DO k=1,SIZE(bmatrix, 3)
      DO j=1,SIZE(bmatrix, 2)
        DO i=1,SIZE(bmatrix, 1)
          l = l + 1
          bmatrix(i, j, k) = amatrix(l)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_3
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_4_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    m = 0
    DO l=1,SIZE(amatrix, 4)
      DO k=1,SIZE(amatrix, 3)
        DO j=1,SIZE(amatrix, 2)
          DO i=1,SIZE(amatrix, 1)
            m = m + 1
            bmatrix(m) = amatrix(i, j, k, l)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_4_1
!  Differentiation of myreshape_1_4 in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: bmatrix
!   with respect to varying inputs: amatrix
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_1_4_B(amatrix, amatrixb, bmatrix, bmatrixb)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: amatrixb
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrixb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    INTEGER :: ad_to2
    m = 0
    DO l=1,SIZE(bmatrix, 4)
      DO k=1,SIZE(bmatrix, 3)
        DO j=1,SIZE(bmatrix, 2)
          DO i=1,SIZE(bmatrix, 1)
            CALL PUSHINTEGER4(m)
            m = m + 1
            bmatrix(i, j, k, l) = amatrix(m)
          END DO
          CALL PUSHINTEGER4(i - 1)
        END DO
        CALL PUSHINTEGER4(j - 1)
      END DO
      CALL PUSHINTEGER4(k - 1)
    END DO
    ad_to2 = l - 1
    amatrixb = 0.D0
    DO l=ad_to2,1,-1
      CALL POPINTEGER4(ad_to1)
      DO k=ad_to1,1,-1
        CALL POPINTEGER4(ad_to0)
        DO j=ad_to0,1,-1
          CALL POPINTEGER4(ad_to)
          DO i=ad_to,1,-1
            amatrixb(m) = amatrixb(m) + bmatrixb(i, j, k, l)
            bmatrixb(i, j, k, l) = 0.D0
            CALL POPINTEGER4(m)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_4_B
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_1_4(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrix
    INTRINSIC SIZE
    m = 0
    DO l=1,SIZE(bmatrix, 4)
      DO k=1,SIZE(bmatrix, 3)
        DO j=1,SIZE(bmatrix, 2)
          DO i=1,SIZE(bmatrix, 1)
            m = m + 1
            bmatrix(i, j, k, l) = amatrix(m)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_4
!  Differentiation of spmat_multiply_diagonal in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: avalues rvalues
!   with respect to varying inputs: avalues dmatrix rvalues
!
! This routine pre-multiplies a diagonal matrix by a sparse matrix
!
  SUBROUTINE SPMAT_MULTIPLY_DIAGONAL_B(n, annz, arow_index, &
&   arow_compressed, acol_index, avalues, avaluesb, dmatrix, dmatrixb, &
&   rnnz, rrow_index, rrow_compressed, rcol_index, rvalues, rvaluesb, &
&   order)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    CHARACTER(len=3) :: order
    INTEGER :: n
    INTEGER :: annz
    INTEGER, DIMENSION(7*n) :: arow_index
    INTEGER, DIMENSION(7*n) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n) :: avaluesb
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n) :: rrow_index
    INTEGER, DIMENSION(7*n) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: rvalues
    DOUBLE PRECISION, DIMENSION(7*n) :: rvaluesb
    INTEGER, DIMENSION(n + 1) :: rrow_compressed
    DOUBLE PRECISION, DIMENSION(n) :: dmatrix
    DOUBLE PRECISION, DIMENSION(n) :: dmatrixb
    IF (order .EQ. 'PRE') THEN
      dmatrixb = 0.D0
      DO i=annz,1,-1
        avaluesb(i) = avaluesb(i) + dmatrix(acol_index(i))*rvaluesb(i)
        dmatrixb(acol_index(i)) = dmatrixb(acol_index(i)) + avalues(i)*&
&         rvaluesb(i)
        rvaluesb(i) = 0.D0
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      dmatrixb = 0.D0
      DO i=annz,1,-1
        avaluesb(i) = avaluesb(i) + dmatrix(arow_index(i))*rvaluesb(i)
        dmatrixb(arow_index(i)) = dmatrixb(arow_index(i)) + avalues(i)*&
&         rvaluesb(i)
        rvaluesb(i) = 0.D0
      END DO
    ELSE
      dmatrixb = 0.D0
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_DIAGONAL_B
!
! This routine pre-multiplies a diagonal matrix by a sparse matrix
!
  SUBROUTINE SPMAT_MULTIPLY_DIAGONAL(n, annz, arow_index, &
&   arow_compressed, acol_index, avalues, dmatrix, rnnz, rrow_index, &
&   rrow_compressed, rcol_index, rvalues, order)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    CHARACTER(len=3) :: order
    INTEGER :: n
    INTEGER :: annz
    INTEGER, DIMENSION(7*n) :: arow_index
    INTEGER, DIMENSION(7*n) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: avalues
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n) :: rrow_index
    INTEGER, DIMENSION(7*n) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: rvalues
    INTEGER, DIMENSION(n + 1) :: rrow_compressed
    DOUBLE PRECISION, DIMENSION(n) :: dmatrix
    rnnz = annz
    rrow_compressed = arow_compressed
    IF (order .EQ. 'PRE') THEN
      DO i=1,annz
        rrow_index(i) = arow_index(i)
        rcol_index(i) = acol_index(i)
! take combination of columns of amatrix
        rvalues(i) = avalues(i)*dmatrix(acol_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      DO i=1,annz
        rrow_index(i) = arow_index(i)
        rcol_index(i) = acol_index(i)
! take combination of rows of amatrix
        rvalues(i) = avalues(i)*dmatrix(arow_index(i))
      END DO
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_DIAGONAL
!  Differentiation of spmat_multiply_vector in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: avalues cvector
!   with respect to varying inputs: bvector avalues
!
! The routine multiplies a vector by a sparse matrix (PRE/POST)
!
  SUBROUTINE SPMAT_MULTIPLY_VECTOR_B(n, annz, arow_index, &
&   arow_compressed, acol_index, avalues, avaluesb, bvector, bvectorb, &
&   cvector, cvectorb, order)
    IMPLICIT NONE
    INTEGER :: i
    CHARACTER(len=3) :: order
    INTEGER :: n
    INTEGER :: annz
    INTEGER, DIMENSION(7*n) :: arow_index
    INTEGER, DIMENSION(7*n) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n) :: avaluesb
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n) :: bvector
    DOUBLE PRECISION, DIMENSION(n) :: bvectorb
    DOUBLE PRECISION, DIMENSION(n) :: cvector
    DOUBLE PRECISION, DIMENSION(n) :: cvectorb
    IF (order .EQ. 'PRE') THEN
      bvectorb = 0.D0
      DO i=annz,1,-1
        avaluesb(i) = avaluesb(i) + bvector(acol_index(i))*cvectorb(&
&         arow_index(i))
        bvectorb(acol_index(i)) = bvectorb(acol_index(i)) + avalues(i)*&
&         cvectorb(arow_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      bvectorb = 0.D0
      DO i=annz,1,-1
        avaluesb(i) = avaluesb(i) + bvector(arow_index(i))*cvectorb(&
&         acol_index(i))
        bvectorb(arow_index(i)) = bvectorb(arow_index(i)) + avalues(i)*&
&         cvectorb(acol_index(i))
      END DO
    ELSE
      bvectorb = 0.D0
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_VECTOR_B
!
! The routine multiplies a vector by a sparse matrix (PRE/POST)
!
  SUBROUTINE SPMAT_MULTIPLY_VECTOR(n, annz, arow_index, arow_compressed&
&   , acol_index, avalues, bvector, cvector, order)
    IMPLICIT NONE
    INTEGER :: i
    CHARACTER(len=3) :: order
    INTEGER :: n
    INTEGER :: annz
    INTEGER, DIMENSION(7*n) :: arow_index
    INTEGER, DIMENSION(7*n) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: avalues
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n) :: bvector
    DOUBLE PRECISION, DIMENSION(n) :: cvector
    cvector = 0.0d0
    IF (order .EQ. 'PRE') THEN
      DO i=1,annz
! Combination of the columns of amatrix
        cvector(arow_index(i)) = cvector(arow_index(i)) + avalues(i)*&
&         bvector(acol_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      DO i=1,annz
! Combination of the rows of amatrix
        cvector(acol_index(i)) = cvector(acol_index(i)) + avalues(i)*&
&         bvector(arow_index(i))
      END DO
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_VECTOR
!
! This routine multiplies each element of the SPMAT
! by a scalar.
! Allows amatrix to be the same as rmatrix
!
  SUBROUTINE SCALAR_MULTIPLY_SPMAT(n, annz, arow_index, arow_compressed&
&   , acol_index, avalues, scalar, rnnz, rrow_index, rrow_compressed, &
&   rcol_index, rvalues)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    DOUBLE PRECISION :: scalar
    INTEGER :: n
    INTEGER :: annz
    INTEGER, DIMENSION(7*n) :: arow_index
    INTEGER, DIMENSION(7*n) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: avalues
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n) :: rrow_index
    INTEGER, DIMENSION(7*n) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: rvalues
    INTEGER, DIMENSION(n + 1) :: rrow_compressed
    rnnz = annz
    rrow_compressed = arow_compressed
    DO i=1,annz
      rrow_index(i) = arow_index(i)
      rcol_index(i) = acol_index(i)
      rvalues(i) = scalar*avalues(i)
    END DO
  END SUBROUTINE SCALAR_MULTIPLY_SPMAT
  SUBROUTINE MYMIN_0_0_DOUBLE(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .GE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE MYMIN_0_0_DOUBLE
!  Differentiation of mymin_1_0_double in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: vectorout vectorin
!   with respect to varying inputs: vectorin
  SUBROUTINE MYMIN_1_0_DOUBLE_B(vectorin, vectorinb, scalarin, vectorout&
&   , vectoroutb)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    DOUBLE PRECISION, DIMENSION(:) :: vectorinb, vectoroutb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .GE. scalarin) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to = i - 1
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        vectorinb(i) = vectorinb(i) + vectoroutb(i)
        vectoroutb(i) = 0.D0
      ELSE
        vectoroutb(i) = 0.D0
      END IF
    END DO
  END SUBROUTINE MYMIN_1_0_DOUBLE_B
  SUBROUTINE MYMIN_1_0_DOUBLE(vectorin, scalarin, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .GE. scalarin) THEN
        vectorout(i) = scalarin
      ELSE
        vectorout(i) = vectorin(i)
      END IF
    END DO
  END SUBROUTINE MYMIN_1_0_DOUBLE
  SUBROUTINE MYMIN_1_1_DOUBLE(vectorin1, vectorin2, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(:) :: vectorin1, vectorin2, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin1, 1)
      IF (vectorin1(i) .GE. vectorin2(i)) THEN
        vectorout(i) = vectorin2(i)
      ELSE
        vectorout(i) = vectorin1(i)
      END IF
    END DO
  END SUBROUTINE MYMIN_1_1_DOUBLE
  SUBROUTINE MYMAX_0_0_DOUBLE(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .LE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE MYMAX_0_0_DOUBLE
!  Differentiation of mymax_1_0_double in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: vectorout vectorin
!   with respect to varying inputs: vectorout vectorin
  SUBROUTINE MYMAX_1_0_DOUBLE_B(vectorin, vectorinb, scalarin, vectorout&
&   , vectoroutb)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    DOUBLE PRECISION, DIMENSION(:) :: vectorinb, vectoroutb
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .LE. scalarin) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to = i - 1
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        vectorinb(i) = vectorinb(i) + vectoroutb(i)
        vectoroutb(i) = 0.D0
      ELSE
        vectoroutb(i) = 0.D0
      END IF
    END DO
  END SUBROUTINE MYMAX_1_0_DOUBLE_B
  SUBROUTINE MYMAX_1_0_DOUBLE(vectorin, scalarin, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .LE. scalarin) THEN
        vectorout(i) = scalarin
      ELSE
        vectorout(i) = vectorin(i)
      END IF
    END DO
  END SUBROUTINE MYMAX_1_0_DOUBLE
  SUBROUTINE MYMAX_1_1_DOUBLE(vectorin1, vectorin2, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(:) :: vectorin1, vectorin2, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin1, 1)
      IF (vectorin1(i) .LE. vectorin2(i)) THEN
        vectorout(i) = vectorin2(i)
      ELSE
        vectorout(i) = vectorin1(i)
      END IF
    END DO
  END SUBROUTINE MYMAX_1_1_DOUBLE
END MODULE MATRIX_B

MODULE LINSOLVE_B
  USE PARAMETERS_B
  USE MATHUTIL_B
  USE MATRIX_B
  IMPLICIT NONE
! export solve
  PUBLIC solve
  PUBLIC solve_b
  INTERFACE SOLVE
      MODULE PROCEDURE SPARSE_SOLVE
  END INTERFACE SOLVE

  INTERFACE SOLVE_B
      MODULE PROCEDURE SPARSE_SOLVE_B
  END INTERFACE


CONTAINS
!  Differentiation of sparse_solve in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: avalues x b
!   with respect to varying inputs: avalues x b
!
! Calls a specific solver - here the jacobi method
!
  SUBROUTINE SPARSE_SOLVE_B(n, annz, arow_index, arow_compressed, &
&   acol_index, avalues, avaluesb, b, bb, x, xb)
    IMPLICIT NONE
    INTEGER :: annz
    INTEGER :: n
    INTEGER, DIMENSION(7*n) :: arow_index
    INTEGER, DIMENSION(7*n) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n) :: avaluesb
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n) :: b
    DOUBLE PRECISION, DIMENSION(n) :: bb
    DOUBLE PRECISION, DIMENSION(n) :: x
    DOUBLE PRECISION, DIMENSION(n) :: xb
    EXTERNAL SPARSE_PMGMRES_METHOD
    EXTERNAL SPARSE_PMGMRES_METHOD_B
    INTEGER :: arg1
    arg1 = 7*n
    CALL SPARSE_PMGMRES_METHOD_B(n, annz, arg1, arow_index, &
&                          arow_compressed, acol_index, avalues, &
&                          avaluesb, b, bb, x, xb, solver_inner, &
&                          solver_outer, verbose)
  END SUBROUTINE SPARSE_SOLVE_B
!
! Calls a specific solver - here the jacobi method
!
  SUBROUTINE SPARSE_SOLVE(n, annz, arow_index, arow_compressed, &
&   acol_index, avalues, b, x)
    IMPLICIT NONE
    INTEGER :: annz
    INTEGER :: n
    INTEGER, DIMENSION(7*n) :: arow_index
    INTEGER, DIMENSION(7*n) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n) :: avalues
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n) :: b
    DOUBLE PRECISION, DIMENSION(n) :: x
    EXTERNAL SPARSE_PMGMRES_METHOD
    INTEGER :: arg1
    arg1 = 7*n
    CALL SPARSE_PMGMRES_METHOD(n, annz, arg1, arow_index, &
&                        arow_compressed, acol_index, avalues, b, x, &
&                        solver_inner, solver_outer, verbose)
  END SUBROUTINE SPARSE_SOLVE
END MODULE LINSOLVE_B

MODULE FINITEVOLUME_B
  USE PARAMETERS_B
  USE MATHUTIL_B
  USE MATRIX_B
  USE LINSOLVE_B
  IMPLICIT NONE
  INTERFACE RELPERM
      MODULE PROCEDURE RELPERM_SCALAR
      MODULE PROCEDURE RELPERM_VECTOR
  END INTERFACE RELPERM

  INTERFACE RELPERM_B
      MODULE PROCEDURE RELPERM_SCALAR_B
      MODULE PROCEDURE RELPERM_VECTOR_B
  END INTERFACE


CONTAINS
!  Differentiation of newtraph in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: q s v
!   with respect to varying inputs: q s v
!
! Performs Newton Raphson to solve for saturations
!
  SUBROUTINE NEWTRAPH_B(nx, ny, nz, nd, pt, st, q, qb, v, vb, s, sb)
    IMPLICIT NONE
    INTEGER :: i, j, it
    LOGICAL :: converged
    DOUBLE PRECISION :: dt, dsn
    INTEGER :: nx, ny, nz
    INTEGER :: nd, pt, st
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: sb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: qb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_copy
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_copyb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_iter_copy
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_iter_copyb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dtx
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dtxb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: fi
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: fib
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: fw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: fwb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mwb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mo
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mob
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dmw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dmwb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dmo
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dmob
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: df
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dfb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: g
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: gb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: ds
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dsb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: bfw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: bfwb
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx+1, ny+1, nz+1) :: vb
    INTEGER :: annz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: arow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avalues
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avaluesb
    INTEGER, DIMENSION(nx*ny*nz + 1) :: arow_compressed
    INTEGER :: bnnz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: brow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: bcol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: bvalues
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: bvaluesb
    INTEGER, DIMENSION(nx*ny*nz + 1) :: brow_compressed
    INTEGER :: dgnnz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: dgrow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: dgcol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: dgvalues
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: dgvaluesb
    INTEGER, DIMENSION(nx*ny*nz + 1) :: dgrow_compressed
    INTEGER :: arg1
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: ad_count0
    INTEGER :: i1
    INTEGER :: branch
    INTEGER :: ad_count1
    INTEGER :: i2
    DOUBLE PRECISION :: tempb4(nx*ny*nz)
    DOUBLE PRECISION :: tempb3(nx*ny*nz)
    DOUBLE PRECISION :: tempb2(nx*ny*nz)
    DOUBLE PRECISION :: tempb1(nx*ny*nz)
    DOUBLE PRECISION :: tempb0(nx*ny*nz)
    DOUBLE PRECISION :: tempb(nx*ny*nz)
! not yet converged
    converged = .false.
! Assemble system matrix
    CALL GENA(nx, ny, nz, v, q, annz, arow_index, arow_compressed, &
&       acol_index, avalues)
! copy S over
    s_copy = s
! set scaling factor
    it = 0
    ad_count1 = 0
    DO WHILE (.NOT.converged)
      dt = 1.0d0*st/2**it
      dtx = dt/(v_*por)
      CALL MYMAX_1_0_DOUBLE(q, 0.0d0, fi)
      fi = fi*dtx
! Matrix-diagonal matrix product
      CALL PUSHREAL8ARRAY(bvalues, 7*nx*ny*nz)
      CALL PUSHINTEGER4ARRAY(bcol_index, 7*nx*ny*nz)
      CALL PUSHINTEGER4ARRAY(brow_index, 7*nx*ny*nz)
      CALL PUSHINTEGER4(bnnz)
      CALL SPMAT_MULTIPLY_DIAGONAL(arg1, annz, arow_index, &
&                            arow_compressed, acol_index, avalues, dtx, &
&                            bnnz, brow_index, brow_compressed, &
&                            bcol_index, bvalues, 'POS')
      i = 0
      ad_count0 = 0
      DO WHILE (i .LT. 2**it)
        j = 0
        i = i + 1
        dsn = 1.0d0
        s_iter_copy = s
        ad_count = 0
        DO WHILE (dsn .GT. 1.0d-3 .AND. j .LT. 10)
          CALL PUSHREAL8ARRAY(dmo, nx*ny*nz)
          CALL PUSHREAL8ARRAY(dmw, nx*ny*nz)
          CALL PUSHREAL8ARRAY(mo, nx*ny*nz)
          CALL PUSHREAL8ARRAY(mw, nx*ny*nz)
          CALL RELPERM(nx, ny, nz, s, mw, mo, dmw, dmo)
          df = dmw/(mw+mo) - mw/(mw+mo)**2*(dmw+dmo)
! Matrix-diagonal matrix product
          CALL SPMAT_MULTIPLY_DIAGONAL(arg1, bnnz, brow_index, &
&                                brow_compressed, bcol_index, bvalues, &
&                                df, dgnnz, dgrow_index, &
&                                dgrow_compressed, dgcol_index, dgvalues&
&                                , 'PRE')
          CALL ADDX_DIAGONAL(arg1, dgnnz, dgrow_index, dgrow_compressed&
&                      , dgcol_index, dgvalues, -1.0d0, 0)
          fw = mw/(mw+mo)
! Matrix-vector matrix product
          CALL SPMAT_MULTIPLY_VECTOR(arg1, bnnz, brow_index, &
&                              brow_compressed, bcol_index, bvalues, fw&
&                              , bfw, 'PRE')
          g = s - s_iter_copy - bfw - fi
          arg1 = nx*ny*nz
          CALL PUSHBOOLEAN(verbose)
          CALL PUSHINTEGER4(solver_outer)
          CALL PUSHINTEGER4(solver_inner)
          CALL PUSHREAL8ARRAY(ds, nx*ny*nz)
          CALL PUSHREAL8ARRAY(g, nx*ny*nz)
          CALL PUSHREAL8ARRAY(dgvalues, 7*nx*ny*nz)
          CALL PUSHINTEGER4ARRAY(dgcol_index, 7*nx*ny*nz)
          CALL PUSHINTEGER4ARRAY(dgrow_compressed, nx*ny*nz + 1)
          CALL PUSHINTEGER4ARRAY(dgrow_index, 7*nx*ny*nz)
          CALL PUSHINTEGER4(dgnnz)
          CALL PUSHINTEGER4(arg1)
          CALL SOLVE(arg1, dgnnz, dgrow_index, dgrow_compressed, &
&              dgcol_index, dgvalues, g, ds)
          CALL PUSHREAL8ARRAY(s, nx*ny*nz)
          s = s + ds
          arg1 = nx*ny*nz
          CALL DNRM2(ds, arg1, dsn)
          j = j + 1
          ad_count = ad_count + 1
        END DO
        CALL PUSHINTEGER4(ad_count)
        IF (dsn .GT. 1.0d-3) THEN
! Breaks out of while loop.
          i = 2**it
          CALL PUSHREAL8ARRAY(s, nx*ny*nz)
          s = s_copy
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        ad_count0 = ad_count0 + 1
      END DO
      CALL PUSHINTEGER4(ad_count0)
      IF (dsn .LT. 1.0d-3) THEN
        CALL PUSHCONTROL1B(1)
        converged = .true.
      ELSE
        CALL PUSHINTEGER4(it)
        it = it + 1
        CALL PUSHCONTROL1B(0)
      END IF
      ad_count1 = ad_count1 + 1
    END DO
    avaluesb = 0.D0
    dsb = 0.D0
    s_copyb = 0.D0
    dgvaluesb = 0.D0
    fib = 0.D0
    bvaluesb = 0.D0
    dmob = 0.D0
    dmwb = 0.D0
    DO i2=1,ad_count1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) CALL POPINTEGER4(it)
      CALL POPINTEGER4(ad_count0)
      DO i1=1,ad_count0
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPREAL8ARRAY(s, nx*ny*nz)
          s_copyb = s_copyb + sb
          sb = 0.D0
        END IF
        s_iter_copyb = 0.D0
        CALL POPINTEGER4(ad_count)
        DO i0=1,ad_count
          CALL POPREAL8ARRAY(s, nx*ny*nz)
          dsb = dsb + sb
          CALL POPINTEGER4(arg1)
          CALL POPINTEGER4(dgnnz)
          CALL POPINTEGER4ARRAY(dgrow_index, 7*nx*ny*nz)
          CALL POPINTEGER4ARRAY(dgrow_compressed, nx*ny*nz + 1)
          CALL POPINTEGER4ARRAY(dgcol_index, 7*nx*ny*nz)
          CALL POPREAL8ARRAY(dgvalues, 7*nx*ny*nz)
          CALL POPREAL8ARRAY(g, nx*ny*nz)
          CALL POPREAL8ARRAY(ds, nx*ny*nz)
          CALL POPINTEGER4(solver_inner)
          CALL POPINTEGER4(solver_outer)
          CALL POPBOOLEAN(verbose)
          gb = 0.D0
          CALL SOLVE_B(arg1, dgnnz, dgrow_index, dgrow_compressed, &
&                dgcol_index, dgvalues, dgvaluesb, g, gb, ds, dsb)
          bfwb = 0.D0
          sb = sb + gb
          s_iter_copyb = s_iter_copyb - gb
          bfwb = -gb
          fib = fib - gb
          fw = mw/(mw+mo)
          CALL SPMAT_MULTIPLY_VECTOR_B(arg1, bnnz, brow_index, &
&                                brow_compressed, bcol_index, bvalues, &
&                                bvaluesb, fw, fwb, bfw, bfwb, 'PRE')
          mob = 0.D0
          mwb = 0.D0
          tempb = fwb/(mw+mo)
          tempb0 = -(mw*tempb/(mw+mo))
          CALL ADDX_DIAGONAL_B(arg1, dgnnz, dgrow_index, &
&                        dgrow_compressed, dgcol_index, dgvalues, &
&                        dgvaluesb, -1.0d0, 0)
          df = dmw/(mw+mo) - mw/(mw+mo)**2*(dmw+dmo)
          CALL SPMAT_MULTIPLY_DIAGONAL_B(arg1, bnnz, brow_index, &
&                                  brow_compressed, bcol_index, bvalues&
&                                  , bvaluesb, df, dfb, dgnnz, &
&                                  dgrow_index, dgrow_compressed, &
&                                  dgcol_index, dgvalues, dgvaluesb, &
&                                  'PRE')
          tempb4 = dfb/(mw+mo)
          tempb1 = -(dmw*tempb4/(mw+mo))
          tempb2 = -(dfb/(mw+mo)**2)
          tempb3 = -(2*mw*(dmw+dmo)*tempb2/(mw+mo))
          mwb = tempb1 + (dmw+dmo)*tempb2 + tempb3 + tempb0 + tempb
          mob = tempb1 + tempb3 + tempb0
          dmwb = dmwb + mw*tempb2 + tempb4
          dmob = dmob + mw*tempb2
          CALL POPREAL8ARRAY(mw, nx*ny*nz)
          CALL POPREAL8ARRAY(mo, nx*ny*nz)
          CALL POPREAL8ARRAY(dmw, nx*ny*nz)
          CALL POPREAL8ARRAY(dmo, nx*ny*nz)
          CALL RELPERM_B(nx, ny, nz, s, sb, mw, mwb, mo, mob, dmw, dmwb&
&                  , dmo, dmob)
        END DO
        sb = sb + s_iter_copyb
      END DO
      dt = 1.0d0*st/2**it
      dtx = dt/(v_*por)
      CALL POPINTEGER4(bnnz)
      CALL POPINTEGER4ARRAY(brow_index, 7*nx*ny*nz)
      CALL POPINTEGER4ARRAY(bcol_index, 7*nx*ny*nz)
      CALL POPREAL8ARRAY(bvalues, 7*nx*ny*nz)
      CALL SPMAT_MULTIPLY_DIAGONAL_B(arg1, annz, arow_index, &
&                              arow_compressed, acol_index, avalues, &
&                              avaluesb, dtx, dtxb, bnnz, brow_index, &
&                              brow_compressed, bcol_index, bvalues, &
&                              bvaluesb, 'POS')
      fib = dtx*fib
      CALL MYMAX_1_0_DOUBLE_B(q, qb, 0.0d0, fi, fib)
    END DO
    sb = sb + s_copyb
    CALL GENA_B(nx, ny, nz, v, vb, q, qb, annz, arow_index, &
&         arow_compressed, acol_index, avalues, avaluesb)
  END SUBROUTINE NEWTRAPH_B
!
! Performs Newton Raphson to solve for saturations
!
  SUBROUTINE NEWTRAPH(nx, ny, nz, nd, pt, st, q, v, s)
    IMPLICIT NONE
    INTEGER :: i, j, it
    LOGICAL :: converged
    DOUBLE PRECISION :: dt, dsn
    INTEGER :: nx, ny, nz
    INTEGER :: nd, pt, st
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_copy
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_iter_copy
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dtx
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: fi
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: fw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mo
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dmw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: dmo
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: df
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: g
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: ds
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: bfw
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    INTEGER :: annz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: arow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avalues
    INTEGER, DIMENSION(nx*ny*nz + 1) :: arow_compressed
    INTEGER :: bnnz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: brow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: bcol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: bvalues
    INTEGER, DIMENSION(nx*ny*nz + 1) :: brow_compressed
    INTEGER :: dgnnz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: dgrow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: dgcol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: dgvalues
    INTEGER, DIMENSION(nx*ny*nz + 1) :: dgrow_compressed
    INTEGER :: arg1
! not yet converged
    converged = .false.
! Assemble system matrix
    CALL GENA(nx, ny, nz, v, q, annz, arow_index, arow_compressed, &
&       acol_index, avalues)
! copy S over
    s_copy = s
! set scaling factor
    it = 0
    DO WHILE (.NOT.converged)
      dt = 1.0d0*st/2**it
      dtx = dt/(v_*por)
      CALL MYMAX_1_0_DOUBLE(q, 0.0d0, fi)
      fi = fi*dtx
! Matrix-diagonal matrix product
      arg1 = nx*ny*nz
      CALL SPMAT_MULTIPLY_DIAGONAL(arg1, annz, arow_index, &
&                            arow_compressed, acol_index, avalues, dtx, &
&                            bnnz, brow_index, brow_compressed, &
&                            bcol_index, bvalues, 'POS')
      i = 0
      DO WHILE (i .LT. 2**it)
        j = 0
        i = i + 1
        dsn = 1.0d0
        s_iter_copy = s
        DO WHILE (dsn .GT. 1.0d-3 .AND. j .LT. 10)
          CALL RELPERM(nx, ny, nz, s, mw, mo, dmw, dmo)
          df = dmw/(mw+mo) - mw/(mw+mo)**2*(dmw+dmo)
! Matrix-diagonal matrix product
          arg1 = nx*ny*nz
          CALL SPMAT_MULTIPLY_DIAGONAL(arg1, bnnz, brow_index, &
&                                brow_compressed, bcol_index, bvalues, &
&                                df, dgnnz, dgrow_index, &
&                                dgrow_compressed, dgcol_index, dgvalues&
&                                , 'PRE')
          arg1 = nx*ny*nz
          CALL ADDX_DIAGONAL(arg1, dgnnz, dgrow_index, dgrow_compressed&
&                      , dgcol_index, dgvalues, -1.0d0, 0)
          fw = mw/(mw+mo)
! Matrix-vector matrix product
          arg1 = nx*ny*nz
          CALL SPMAT_MULTIPLY_VECTOR(arg1, bnnz, brow_index, &
&                              brow_compressed, bcol_index, bvalues, fw&
&                              , bfw, 'PRE')
          g = s - s_iter_copy - bfw - fi
          arg1 = nx*ny*nz
          CALL SOLVE(arg1, dgnnz, dgrow_index, dgrow_compressed, &
&              dgcol_index, dgvalues, g, ds)
          s = s + ds
          arg1 = nx*ny*nz
          CALL DNRM2(ds, arg1, dsn)
          j = j + 1
        END DO
        IF (dsn .GT. 1.0d-3) THEN
! Breaks out of while loop.
          i = 2**it
          s = s_copy
        END IF
      END DO
      IF (dsn .LT. 1.0d-3) THEN
        converged = .true.
      ELSE
        it = it + 1
      END IF
    END DO
  END SUBROUTINE NEWTRAPH
!  Differentiation of pres in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: p q s v
!   with respect to varying inputs: p q s v
!
! Pressure Solver
!
  SUBROUTINE PRES_B(nx, ny, nz, q, qb, s, sb, p, pb, v, vb)
    IMPLICIT NONE
    INTEGER :: i
    INTEGER :: nx, ny, nz
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: sb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: qb
    DOUBLE PRECISION, DIMENSION(3*(nx*ny*nz)) :: m
    DOUBLE PRECISION, DIMENSION(3*(nx*ny*nz)) :: mb
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: km
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: kmb
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx+1, ny+1, nz+1) :: vb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mwb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mo
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mob
    CALL RELPERM(nx, ny, nz, s, mw, mo)
    DO i=1,nx*ny*nz
      m(1+(i-1)*3) = mw(i) + mo(i)
      m(2+(i-1)*3) = m(1+(i-1)*3)
      m(3+(i-1)*3) = m(1+(i-1)*3)
    END DO
    CALL PUSHREAL8ARRAY(km, 3*nx*ny*nz)
    CALL MYRESHAPE_1_4(m, km)
! point-wise multiply
    km = km*perm
    CALL TPFA_B(nx, ny, nz, km, kmb, q, qb, p, pb, v, vb)
    kmb = perm*kmb
    CALL POPREAL8ARRAY(km, 3*nx*ny*nz)
    CALL MYRESHAPE_1_4_B(m, mb, km, kmb)
    mob = 0.D0
    mwb = 0.D0
    DO i=nx*ny*nz,1,-1
      mb(1+(i-1)*3) = mb(1+(i-1)*3) + mb(3+(i-1)*3)
      mb(3+(i-1)*3) = 0.D0
      mb(1+(i-1)*3) = mb(1+(i-1)*3) + mb(2+(i-1)*3)
      mb(2+(i-1)*3) = 0.D0
      mwb(i) = mwb(i) + mb(1+(i-1)*3)
      mob(i) = mob(i) + mb(1+(i-1)*3)
      mb(1+(i-1)*3) = 0.D0
    END DO
    CALL RELPERM_B(nx, ny, nz, s, sb, mw, mwb, mo, mob)
  END SUBROUTINE PRES_B
!
! Pressure Solver
!
  SUBROUTINE PRES(nx, ny, nz, q, s, p, v)
    IMPLICIT NONE
    INTEGER :: i
    INTEGER :: nx, ny, nz
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(3*(nx*ny*nz)) :: m
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: km
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mo
    CALL RELPERM(nx, ny, nz, s, mw, mo)
    DO i=1,nx*ny*nz
      m(1+(i-1)*3) = mw(i) + mo(i)
      m(2+(i-1)*3) = m(1+(i-1)*3)
      m(3+(i-1)*3) = m(1+(i-1)*3)
    END DO
    CALL MYRESHAPE_1_4(m, km)
! point-wise multiply
    km = km*perm
    CALL TPFA(nx, ny, nz, km, q, p, v)
  END SUBROUTINE PRES
!  Differentiation of relperm_vector in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: s dmo mo dmw mw
!   with respect to varying inputs: s dmo dmw
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_VECTOR_B(nx, ny, nz, s, sb, mw, mwb, mo, mob, dmw, &
&   dmwb, dmo, dmob)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: sb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mwb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mo
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mob
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_temp
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_tempb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz), OPTIONAL :: dmw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz), OPTIONAL :: dmwb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz), OPTIONAL :: dmo
    DOUBLE PRECISION, DIMENSION(nx*ny*nz), OPTIONAL :: dmob
    INTRINSIC PRESENT
! rescale saturation
    s_temp = (s-swc_)/(1.0d0-swc_-sor_)
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      s_tempb = 0.D0
      s_tempb = 2*dmwb/(vw_*(1-sor_-swc_)) + 2*dmob/(vo_*(1-sor_-swc_))
      dmob = 0.D0
      dmwb = 0.D0
    ELSE
      s_tempb = 0.D0
    END IF
    s_tempb = s_tempb + 2*s_temp*mwb/vw_ - 2*(1-s_temp)*mob/vo_
    sb = sb + s_tempb/(1.0d0-sor_-swc_)
  END SUBROUTINE RELPERM_VECTOR_B
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_VECTOR(nx, ny, nz, s, mw, mo, dmw, dmo)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: mo
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s_temp
    DOUBLE PRECISION, DIMENSION(nx*ny*nz), OPTIONAL :: dmw
    DOUBLE PRECISION, DIMENSION(nx*ny*nz), OPTIONAL :: dmo
    INTRINSIC PRESENT
! rescale saturation
    s_temp = (s-swc_)/(1.0d0-swc_-sor_)
    mw = s_temp**2/vw_
    mo = (1-s_temp)**2/vo_
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      dmw = 2*s_temp/vw_/(1-swc_-sor_)
      dmo = -(2*(1-s_temp)/vo_/(1-swc_-sor_))
    END IF
  END SUBROUTINE RELPERM_VECTOR
!  Differentiation of relperm_scalar in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: s mo mw
!   with respect to varying inputs: s
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_SCALAR_B(s, sb, mw, mwb, mo, mob, dmw, dmo)
    IMPLICIT NONE
    DOUBLE PRECISION :: s, mw, mo, s_temp
    DOUBLE PRECISION :: sb, mwb, mob, s_tempb
    DOUBLE PRECISION, OPTIONAL :: dmw, dmo
    INTRINSIC PRESENT
! rescale saturation
    s_temp = (s-swc_)/(1.0d0-swc_-sor_)
    s_tempb = 2*s_temp*mwb/vw_ - 2*(1-s_temp)*mob/vo_
    sb = sb + s_tempb/(1.0d0-sor_-swc_)
  END SUBROUTINE RELPERM_SCALAR_B
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_SCALAR(s, mw, mo, dmw, dmo)
    IMPLICIT NONE
    DOUBLE PRECISION :: s, mw, mo, s_temp
    DOUBLE PRECISION, OPTIONAL :: dmw, dmo
    INTRINSIC PRESENT
! rescale saturation
    s_temp = (s-swc_)/(1.0d0-swc_-sor_)
    mw = s_temp**2/vw_
    mo = (1-s_temp)**2/vo_
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      dmw = 2*s_temp/vw_/(1-swc_-sor_)
      dmo = -(2*(1-s_temp)/vo_/(1-swc_-sor_))
    END IF
  END SUBROUTINE RELPERM_SCALAR
!  Differentiation of gena in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: avalues q v
!   with respect to varying inputs: q v
!
! Generate A matrix
!
  SUBROUTINE GENA_B(nx, ny, nz, v, vb, q, qb, annz, arow_index, &
&   arow_compressed, acol_index, avalues, avaluesb)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    INTEGER, DIMENSION(7) :: idiags
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: qb
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: diags
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: diagsb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: diag_tmp
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: diag_tmpb
! V has an extra length
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx+1, ny+1, nz+1) :: vb
! across each x, y, z
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: vxyz
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: vxyzb
    INTEGER :: annz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: arow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avalues
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avaluesb
    INTEGER, DIMENSION(nx*ny*nz + 1) :: arow_compressed
! initialize diags
    diags = 0.0d0
! reshape arrays first
    vxyz = v(3, 1:nx, 1:ny, 2:nz+1)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 1))
! z2
    vxyz = v(2, 1:nx, 2:ny+1, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 2))
! y2
    vxyz = v(1, 2:nx+1, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 3))
! x2
    vxyz = v(1, 1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 5))
! x1
    vxyz = v(2, 1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 6))
! y1
    vxyz = v(3, 1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 7))
! z1
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 1), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 1), nx*ny*nz)
    diags(:, 1) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 2), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 2), nx*ny*nz)
    diags(:, 2) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 3), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 3), nx*ny*nz)
    diags(:, 3) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 5), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 5), nx*ny*nz)
    diags(:, 5) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 6), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 6), nx*ny*nz)
    diags(:, 6) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 7), 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 7), nx*ny*nz)
    diags(:, 7) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(q, 0.0d0, diag_tmp)
    CALL PUSHREAL8ARRAY(diags(:, 4), nx*ny*nz)
    diags(:, 4) = diag_tmp - diags(:, 5) - diags(:, 3) - diags(:, 6) - &
&     diags(:, 2) - diags(:, 7) - diags(:, 1)
    CALL SPDIAGS_FVM_CSR_B(nx, ny, nz, diags, diagsb, annz, arow_index, &
&                    arow_compressed, acol_index, avalues, avaluesb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 4), nx*ny*nz)
    diag_tmpb = diagsb(:, 4)
    diagsb(:, 5) = diagsb(:, 5) - diagsb(:, 4)
    diagsb(:, 3) = diagsb(:, 3) - diagsb(:, 4)
    diagsb(:, 6) = diagsb(:, 6) - diagsb(:, 4)
    diagsb(:, 2) = diagsb(:, 2) - diagsb(:, 4)
    diagsb(:, 7) = diagsb(:, 7) - diagsb(:, 4)
    diagsb(:, 1) = diagsb(:, 1) - diagsb(:, 4)
    diagsb(:, 4) = 0.D0
    CALL MYMIN_1_0_DOUBLE_B(q, qb, 0.0d0, diag_tmp, diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 7), nx*ny*nz)
    diag_tmpb = -diagsb(:, 7)
    diagsb(:, 7) = 0.D0
    CALL MYMIN_1_0_DOUBLE_B(diags(:, 7), diagsb(:, 7), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 6), nx*ny*nz)
    diag_tmpb = -diagsb(:, 6)
    diagsb(:, 6) = 0.D0
    CALL MYMIN_1_0_DOUBLE_B(diags(:, 6), diagsb(:, 6), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 5), nx*ny*nz)
    diag_tmpb = -diagsb(:, 5)
    diagsb(:, 5) = 0.D0
    CALL MYMIN_1_0_DOUBLE_B(diags(:, 5), diagsb(:, 5), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 3), nx*ny*nz)
    diag_tmpb = diagsb(:, 3)
    diagsb(:, 3) = 0.D0
    CALL MYMAX_1_0_DOUBLE_B(diags(:, 3), diagsb(:, 3), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 2), nx*ny*nz)
    diag_tmpb = diagsb(:, 2)
    diagsb(:, 2) = 0.D0
    CALL MYMAX_1_0_DOUBLE_B(diags(:, 2), diagsb(:, 2), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    diag_tmpb = 0.D0
    CALL POPREAL8ARRAY(diags(:, 1), nx*ny*nz)
    diag_tmpb = diagsb(:, 1)
    diagsb(:, 1) = 0.D0
    CALL MYMAX_1_0_DOUBLE_B(diags(:, 1), diagsb(:, 1), 0.0d0, diag_tmp, &
&                     diag_tmpb)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 7), diagsb(:, 7))
    vb(3, 1:nx, 1:ny, 1:nz) = vb(3, 1:nx, 1:ny, 1:nz) + vxyzb
    vxyz = v(2, 1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 6), diagsb(:, 6))
    vb(2, 1:nx, 1:ny, 1:nz) = vb(2, 1:nx, 1:ny, 1:nz) + vxyzb
    vxyz = v(1, 1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 5), diagsb(:, 5))
    vb(1, 1:nx, 1:ny, 1:nz) = vb(1, 1:nx, 1:ny, 1:nz) + vxyzb
    vxyz = v(1, 2:nx+1, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 3), diagsb(:, 3))
    vb(1, 2:nx+1, 1:ny, 1:nz) = vb(1, 2:nx+1, 1:ny, 1:nz) + vxyzb
    vxyz = v(2, 1:nx, 2:ny+1, 1:nz)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 2), diagsb(:, 2))
    vb(2, 1:nx, 2:ny+1, 1:nz) = vb(2, 1:nx, 2:ny+1, 1:nz) + vxyzb
    vxyz = v(3, 1:nx, 1:ny, 2:nz+1)
    CALL MYRESHAPE_3_1_B(vxyz, vxyzb, diags(:, 1), diagsb(:, 1))
    vb(3, 1:nx, 1:ny, 2:nz+1) = vb(3, 1:nx, 1:ny, 2:nz+1) + vxyzb
  END SUBROUTINE GENA_B
!
! Generate A matrix
!
  SUBROUTINE GENA(nx, ny, nz, v, q, annz, arow_index, arow_compressed, &
&   acol_index, avalues)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    INTEGER, DIMENSION(7) :: idiags
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: diags
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: diag_tmp
! V has an extra length
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
! across each x, y, z
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: vxyz
    INTEGER :: annz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: arow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avalues
    INTEGER, DIMENSION(nx*ny*nz + 1) :: arow_compressed
! initialize diags
    diags = 0.0d0
! reshape arrays first
    vxyz = v(3, 1:nx, 1:ny, 2:nz+1)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 1))
! z2
    vxyz = v(2, 1:nx, 2:ny+1, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 2))
! y2
    vxyz = v(1, 2:nx+1, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 3))
! x2
    vxyz = v(1, 1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 5))
! x1
    vxyz = v(2, 1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 6))
! y1
    vxyz = v(3, 1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 7))
! z1
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 1), 0.0d0, diag_tmp)
    diags(:, 1) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 2), 0.0d0, diag_tmp)
    diags(:, 2) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 3), 0.0d0, diag_tmp)
    diags(:, 3) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 5), 0.0d0, diag_tmp)
    diags(:, 5) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 6), 0.0d0, diag_tmp)
    diags(:, 6) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 7), 0.0d0, diag_tmp)
    diags(:, 7) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(q, 0.0d0, diag_tmp)
    diags(:, 4) = diag_tmp - diags(:, 5) - diags(:, 3) - diags(:, 6) - &
&     diags(:, 2) - diags(:, 7) - diags(:, 1)
    CALL SPDIAGS_FVM_CSR(nx, ny, nz, diags, annz, arow_index, &
&                  arow_compressed, acol_index, avalues)
  END SUBROUTINE GENA
!  Differentiation of tpfa in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: p q v
!   with respect to varying inputs: k p q v
!
! Two point flux approximation.
!
  SUBROUTINE TPFA_B(nx, ny, nz, k, kb, q, qb, p, pb, v, vb)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    INTEGER :: i
    INTEGER, DIMENSION(7) :: idiags
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: diags
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: diagsb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: qb
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: k
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: kb
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx+1, ny+1, nz+1) :: vb
! local variables
    DOUBLE PRECISION :: tx_, ty_, tz_
    DOUBLE PRECISION, DIMENSION(nx + 1, ny, nz) :: tx
    DOUBLE PRECISION, DIMENSION(nx+1, ny, nz) :: txb
    DOUBLE PRECISION, DIMENSION(nx, ny + 1, nz) :: ty
    DOUBLE PRECISION, DIMENSION(nx, ny+1, nz) :: tyb
    DOUBLE PRECISION, DIMENSION(nx, ny, nz + 1) :: tz
    DOUBLE PRECISION, DIMENSION(nx, ny, nz+1) :: tzb
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: txyz
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: txyzb
! solution to the linear system
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: u
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: ub
! point-wise inverse of permeability
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: l
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: lb
! sparse matrix
    INTEGER :: annz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: arow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avalues
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avaluesb
    INTEGER, DIMENSION(nx*ny*nz + 1) :: arow_compressed
    INTRINSIC MOD
    INTEGER :: arg1
    INTEGER :: ad_to
    INTEGER :: branch
    DOUBLE PRECISION :: temp1(nx, ny, nz-1)
    DOUBLE PRECISION :: temp0(nx, ny-1, nz)
    DOUBLE PRECISION :: tempb4(nx-1, ny, nz)
    DOUBLE PRECISION :: tempb3(nx, ny-1, nz)
    DOUBLE PRECISION :: tempb2(nx, ny, nz-1)
    DOUBLE PRECISION :: tempb1(nx-1, ny, nz)
    DOUBLE PRECISION :: tempb0(nx, ny-1, nz)
    DOUBLE PRECISION :: tempb(nx, ny, nz-1)
    DOUBLE PRECISION :: temp(nx-1, ny, nz)
! get the point-wise inverse of the permeability matrix
    l = 1.0d0/k
    tx_ = 2.0d0*hy_*hz_/hx_
    ty_ = 2.0d0*hx_*hz_/hy_
    tz_ = 2.0d0*hy_*hx_/hz_
    tx = 0.0d0
    ty = 0.0d0
    tz = 0.0d0
! Compute transmissibilities by averaging harmonically
    tx(2:nx, 1:ny, 1:nz) = tx_/(l(1, 1:nx-1, 1:ny, 1:nz)+l(1, 2:nx, 1:ny&
&     , 1:nz))
    ty(1:nx, 2:ny, 1:nz) = ty_/(l(2, 1:nx, 1:ny-1, 1:nz)+l(2, 1:nx, 2:ny&
&     , 1:nz))
    tz(1:nx, 1:ny, 2:nz) = tz_/(l(3, 1:nx, 1:ny, 1:nz-1)+l(3, 1:nx, 1:ny&
&     , 2:nz))
! initialize diags
    diags = 0.0d0
    txyz = -tx(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 5))
! -x1
    txyz = -ty(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 6))
! -y1
    txyz = -tz(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 7))
! -z1
    txyz = -tx(2:nx+1, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 3))
! -x2
    txyz = -ty(1:nx, 2:ny+1, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 2))
! -y2
    txyz = -tz(1:nx, 1:ny, 2:nz+1)
    CALL MYRESHAPE_3_1(txyz, diags(:, 1))
! -z2
! Assemble discretization matrix
    diags(:, 4) = -(diags(:, 1)+diags(:, 2)+diags(:, 3)+diags(:, 5)+&
&     diags(:, 6)+diags(:, 7))
    CALL SPDIAGS_FVM_CSR(nx, ny, nz, diags, annz, arow_index, &
&                  arow_compressed, acol_index, avalues)
! ! Increment the 1,1 element of A
!     call addx_elem(annz, arow_index, arow_compressed,&
!                     acol_index, avalues, &
!                     PERM(1,1,1,1) + PERM(2,1,1,1) + PERM(3,1,1,1), 1, 1)
! Fix the pressure at the inlets
    DO i=1,annz
      IF (arow_index(i) .LT. nx*ny .AND. MOD(arow_index(i), ny) .EQ. 1) &
&     THEN
        IF (arow_index(i) .EQ. acol_index(i)) THEN
          avalues(i) = 1
          CALL PUSHCONTROL2B(2)
        ELSE
          avalues(i) = 0
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
! solve the linear system
! Pass the rows_index, cols_index, values separately.
    arg1 = nx*ny*nz
    CALL PUSHBOOLEAN(verbose)
    CALL PUSHINTEGER4(solver_outer)
    CALL PUSHINTEGER4(solver_inner)
    CALL PUSHREAL8ARRAY(u, nx*ny*nz)
    CALL PUSHREAL8ARRAY(q, nx*ny*nz)
    CALL PUSHREAL8ARRAY(avalues, 7*nx*ny*nz)
    CALL PUSHINTEGER4ARRAY(acol_index, 7*nx*ny*nz)
    CALL PUSHINTEGER4ARRAY(arow_compressed, nx*ny*nz + 1)
    CALL PUSHINTEGER4ARRAY(arow_index, 7*nx*ny*nz)
    CALL PUSHINTEGER4(annz)
    CALL PUSHINTEGER4(arg1)
    CALL SOLVE(arg1, annz, arow_index, arow_compressed, acol_index, &
&        avalues, q, u)
! reshape the solution
    CALL PUSHREAL8ARRAY(p, nx*ny*nz)
    CALL MYRESHAPE_1_3(u, p)
! V.x
! V.y
! V.z
    tzb = 0.D0
    tempb2 = tz(:, :, 2:nz)*vb(3, 1:nx, 1:ny, 2:nz)
    pb(:, :, 1:nz-1) = pb(:, :, 1:nz-1) + tempb2
    pb(:, :, 2:nz) = pb(:, :, 2:nz) - tempb2
    tzb(:, :, 2:nz) = tzb(:, :, 2:nz) + (p(:, :, 1:nz-1)-p(:, :, 2:nz))*&
&     vb(3, 1:nx, 1:ny, 2:nz)
    vb(3, 1:nx, 1:ny, 2:nz) = 0.D0
    tyb = 0.D0
    tempb3 = ty(:, 2:ny, :)*vb(2, 1:nx, 2:ny, 1:nz)
    pb(:, 1:ny-1, :) = pb(:, 1:ny-1, :) + tempb3
    pb(:, 2:ny, :) = pb(:, 2:ny, :) - tempb3
    tyb(:, 2:ny, :) = tyb(:, 2:ny, :) + (p(:, 1:ny-1, :)-p(:, 2:ny, :))*&
&     vb(2, 1:nx, 2:ny, 1:nz)
    vb(2, 1:nx, 2:ny, 1:nz) = 0.D0
    txb = 0.D0
    tempb4 = tx(2:nx, :, :)*vb(1, 2:nx, 1:ny, 1:nz)
    pb(1:nx-1, :, :) = pb(1:nx-1, :, :) + tempb4
    pb(2:nx, :, :) = pb(2:nx, :, :) - tempb4
    txb(2:nx, :, :) = txb(2:nx, :, :) + (p(1:nx-1, :, :)-p(2:nx, :, :))*&
&     vb(1, 2:nx, 1:ny, 1:nz)
    vb(1, 2:nx, 1:ny, 1:nz) = 0.D0
    CALL POPREAL8ARRAY(p, nx*ny*nz)
    CALL MYRESHAPE_1_3_B(u, ub, p, pb)
    CALL POPINTEGER4(arg1)
    CALL POPINTEGER4(annz)
    CALL POPINTEGER4ARRAY(arow_index, 7*nx*ny*nz)
    CALL POPINTEGER4ARRAY(arow_compressed, nx*ny*nz + 1)
    CALL POPINTEGER4ARRAY(acol_index, 7*nx*ny*nz)
    CALL POPREAL8ARRAY(avalues, 7*nx*ny*nz)
    CALL POPREAL8ARRAY(q, nx*ny*nz)
    CALL POPREAL8ARRAY(u, nx*ny*nz)
    CALL POPINTEGER4(solver_inner)
    CALL POPINTEGER4(solver_outer)
    CALL POPBOOLEAN(verbose)
    avaluesb = 0.D0
    CALL SOLVE_B(arg1, annz, arow_index, arow_compressed, acol_index, &
&          avalues, avaluesb, q, qb, u, ub)
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          avaluesb(i) = 0.D0
        ELSE
          avaluesb(i) = 0.D0
        END IF
      END IF
    END DO
    CALL SPDIAGS_FVM_CSR_B(nx, ny, nz, diags, diagsb, annz, arow_index, &
&                    arow_compressed, acol_index, avalues, avaluesb)
    diagsb(:, 1) = diagsb(:, 1) - diagsb(:, 4)
    diagsb(:, 2) = diagsb(:, 2) - diagsb(:, 4)
    diagsb(:, 3) = diagsb(:, 3) - diagsb(:, 4)
    diagsb(:, 5) = diagsb(:, 5) - diagsb(:, 4)
    diagsb(:, 6) = diagsb(:, 6) - diagsb(:, 4)
    diagsb(:, 7) = diagsb(:, 7) - diagsb(:, 4)
    diagsb(:, 4) = 0.D0
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 1), diagsb(:, 1))
    tzb(:, :, 2:nz+1) = tzb(:, :, 2:nz+1) - txyzb
    txyz = -ty(1:nx, 2:ny+1, 1:nz)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 2), diagsb(:, 2))
    tyb(:, 2:ny+1, :) = tyb(:, 2:ny+1, :) - txyzb
    txyz = -tx(2:nx+1, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 3), diagsb(:, 3))
    txb(2:nx+1, :, :) = txb(2:nx+1, :, :) - txyzb
    txyz = -tz(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 7), diagsb(:, 7))
    tzb(:, :, 1:nz) = tzb(:, :, 1:nz) - txyzb
    txyz = -ty(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 6), diagsb(:, 6))
    tyb(:, 1:ny, :) = tyb(:, 1:ny, :) - txyzb
    txyz = -tx(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1_B(txyz, txyzb, diags(:, 5), diagsb(:, 5))
    txb(1:nx, :, :) = txb(1:nx, :, :) - txyzb
    lb = 0.D0
    temp1 = l(3, 1:nx, 1:ny, 1:nz-1) + l(3, 1:nx, 1:ny, 2:nz)
    tempb = -(tz_*tzb(1:nx, 1:ny, 2:nz)/temp1**2)
    lb(3, :, :, 1:nz-1) = lb(3, :, :, 1:nz-1) + tempb
    lb(3, :, :, 2:nz) = lb(3, :, :, 2:nz) + tempb
    temp0 = l(2, 1:nx, 1:ny-1, 1:nz) + l(2, 1:nx, 2:ny, 1:nz)
    tempb0 = -(ty_*tyb(1:nx, 2:ny, 1:nz)/temp0**2)
    lb(2, :, 1:ny-1, :) = lb(2, :, 1:ny-1, :) + tempb0
    lb(2, :, 2:ny, :) = lb(2, :, 2:ny, :) + tempb0
    temp = l(1, 1:nx-1, 1:ny, 1:nz) + l(1, 2:nx, 1:ny, 1:nz)
    tempb1 = -(tx_*txb(2:nx, 1:ny, 1:nz)/temp**2)
    lb(1, 1:nx-1, :, :) = lb(1, 1:nx-1, :, :) + tempb1
    lb(1, 2:nx, :, :) = lb(1, 2:nx, :, :) + tempb1
    kb = 0.D0
    kb = -(lb/k**2)
  END SUBROUTINE TPFA_B
!
! Two point flux approximation.
!
  SUBROUTINE TPFA(nx, ny, nz, k, q, p, v)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    INTEGER :: i
    INTEGER, DIMENSION(7) :: idiags
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: diags
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: k
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
! local variables
    DOUBLE PRECISION :: tx_, ty_, tz_
    DOUBLE PRECISION, DIMENSION(nx + 1, ny, nz) :: tx
    DOUBLE PRECISION, DIMENSION(nx, ny + 1, nz) :: ty
    DOUBLE PRECISION, DIMENSION(nx, ny, nz + 1) :: tz
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: txyz
! solution to the linear system
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: u
! point-wise inverse of permeability
    DOUBLE PRECISION, DIMENSION(3, nx, ny, nz) :: l
! sparse matrix
    INTEGER :: annz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: arow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: avalues
    INTEGER, DIMENSION(nx*ny*nz + 1) :: arow_compressed
    INTRINSIC MOD
    INTEGER :: arg1
! get the point-wise inverse of the permeability matrix
    l = 1.0d0/k
    tx_ = 2.0d0*hy_*hz_/hx_
    ty_ = 2.0d0*hx_*hz_/hy_
    tz_ = 2.0d0*hy_*hx_/hz_
    tx = 0.0d0
    ty = 0.0d0
    tz = 0.0d0
! Compute transmissibilities by averaging harmonically
    tx(2:nx, 1:ny, 1:nz) = tx_/(l(1, 1:nx-1, 1:ny, 1:nz)+l(1, 2:nx, 1:ny&
&     , 1:nz))
    ty(1:nx, 2:ny, 1:nz) = ty_/(l(2, 1:nx, 1:ny-1, 1:nz)+l(2, 1:nx, 2:ny&
&     , 1:nz))
    tz(1:nx, 1:ny, 2:nz) = tz_/(l(3, 1:nx, 1:ny, 1:nz-1)+l(3, 1:nx, 1:ny&
&     , 2:nz))
! initialize diags
    diags = 0.0d0
    txyz = -tx(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 5))
! -x1
    txyz = -ty(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 6))
! -y1
    txyz = -tz(1:nx, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 7))
! -z1
    txyz = -tx(2:nx+1, 1:ny, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 3))
! -x2
    txyz = -ty(1:nx, 2:ny+1, 1:nz)
    CALL MYRESHAPE_3_1(txyz, diags(:, 2))
! -y2
    txyz = -tz(1:nx, 1:ny, 2:nz+1)
    CALL MYRESHAPE_3_1(txyz, diags(:, 1))
! -z2
! Assemble discretization matrix
    diags(:, 4) = -(diags(:, 1)+diags(:, 2)+diags(:, 3)+diags(:, 5)+&
&     diags(:, 6)+diags(:, 7))
    CALL SPDIAGS_FVM_CSR(nx, ny, nz, diags, annz, arow_index, &
&                  arow_compressed, acol_index, avalues)
! ! Increment the 1,1 element of A
!     call addx_elem(annz, arow_index, arow_compressed,&
!                     acol_index, avalues, &
!                     PERM(1,1,1,1) + PERM(2,1,1,1) + PERM(3,1,1,1), 1, 1)
! Fix the pressure at the inlets
    DO i=1,annz
      IF (arow_index(i) .LT. nx*ny .AND. MOD(arow_index(i), ny) .EQ. 1) &
&     THEN
        IF (arow_index(i) .EQ. acol_index(i)) THEN
          avalues(i) = 1
        ELSE
          avalues(i) = 0
        END IF
      END IF
    END DO
! solve the linear system
! Pass the rows_index, cols_index, values separately.
    arg1 = nx*ny*nz
    CALL SOLVE(arg1, annz, arow_index, arow_compressed, acol_index, &
&        avalues, q, u)
! reshape the solution
    CALL MYRESHAPE_1_3(u, p)
! V.x
! V.y
! V.z
    v(1, 2:nx, 1:ny, 1:nz) = (p(1:nx-1, :, :)-p(2:nx, :, :))*tx(2:nx, :&
&     , :)
! V.y
    v(2, 1:nx, 2:ny, 1:nz) = (p(:, 1:ny-1, :)-p(:, 2:ny, :))*ty(:, 2:ny&
&     , :)
! V.z
    v(3, 1:nx, 1:ny, 2:nz) = (p(:, :, 1:nz-1)-p(:, :, 2:nz))*tz(:, :, 2:&
&     nz)
  END SUBROUTINE TPFA
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
! orow_compressed is not populated.
  SUBROUTINE SPDIAGS_FVM(nx, ny, nz, imatrix, onnz, orow_index, &
&   orow_compressed, ocol_index, ovalues)
    IMPLICIT NONE
    LOGICAL :: done
    INTEGER :: nx, ny, nz
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, start_row_imatrix, end_row_imatrix, row, col
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: imatrix
    INTEGER, DIMENSION(7) :: idiags
    INTEGER :: onnz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: orow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: ovalues
    INTEGER, DIMENSION(nx*ny*nz + 1) :: orow_compressed
    idiags(1) = -(nx*ny)
    idiags(2) = -nx
    idiags(3) = -1
    idiags(4) = 0
    idiags(5) = 1
    idiags(6) = nx
    idiags(7) = nx*ny
    onnz = 0
    orow_compressed = 0
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix = idiags(i) + 1
        end_row_imatrix = nx*ny*nz
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix = 1
        end_row_imatrix = nx*ny*nz + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row, col)
      DO j=start_row_imatrix,end_row_imatrix
        IF (row .EQ. col .OR. imatrix(j, i) .NE. 0) THEN
          onnz = onnz + 1
          orow_index(onnz) = row
          ocol_index(onnz) = col
          ovalues(onnz) = imatrix(j, i)
        END IF
        row = row + 1
        col = col + 1
      END DO
    END DO
  END SUBROUTINE SPDIAGS_FVM
!  Differentiation of spdiags_fvm_csr in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: ovalues
!   with respect to varying inputs: imatrix
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
!
  SUBROUTINE SPDIAGS_FVM_CSR_B(nx, ny, nz, imatrix, imatrixb, onnz, &
&   orow_index, orow_compressed, ocol_index, ovalues, ovaluesb)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    LOGICAL :: done
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, rownnz
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: imatrix
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: imatrixb
    INTEGER, DIMENSION(7) :: idiags
    INTEGER, DIMENSION(7) :: start_row_imatrix, end_row_imatrix
! row, column along diagonal
    INTEGER, DIMENSION(7) :: row_diag, col_diag
    INTEGER :: onnz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: orow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: ovalues
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: ovaluesb
    INTEGER, DIMENSION(nx*ny*nz + 1) :: orow_compressed
    INTEGER :: branch
    idiags(1) = -(nx*ny)
    idiags(2) = -nx
    idiags(3) = -1
    idiags(4) = 0
    idiags(5) = 1
    idiags(6) = nx
    idiags(7) = nx*ny
    onnz = 0
! compressed row storage
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix(i) = idiags(i) + 1
        end_row_imatrix(i) = nx*ny*nz
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix(i) = 1
        end_row_imatrix(i) = nx*ny*nz + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row_diag(i), col_diag(i))
    END DO
! Do for each row in imatrix
    DO i=1,nx*ny*nz
! Do for each column in imatrix
      DO j=1,7
! Need to check if that column has any entry in this row
! checks that you are past the beginning of diagonal, remains fixed
        IF (row_diag(j) .LE. i .AND. start_row_imatrix(j) .LE. &
&           end_row_imatrix(j)) THEN
! checks that you have not exhausted the diagonal
          IF (imatrix(start_row_imatrix(j), j) .NE. 0.0d0 .OR. idiags(j)&
&             .EQ. 0) THEN
! checks that the diagonal entry is non zero or is the main diagonal
            CALL PUSHINTEGER4(onnz)
            onnz = onnz + 1
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHINTEGER4(start_row_imatrix(j))
          start_row_imatrix(j) = start_row_imatrix(j) + 1
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    imatrixb = 0.D0
    DO i=nx*ny*nz,1,-1
      DO j=7,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPINTEGER4(start_row_imatrix(j))
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            imatrixb(start_row_imatrix(j), j) = imatrixb(&
&             start_row_imatrix(j), j) + ovaluesb(onnz)
            ovaluesb(onnz) = 0.D0
            CALL POPINTEGER4(onnz)
          END IF
        END IF
      END DO
    END DO
  END SUBROUTINE SPDIAGS_FVM_CSR_B
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
!
  SUBROUTINE SPDIAGS_FVM_CSR(nx, ny, nz, imatrix, onnz, orow_index, &
&   orow_compressed, ocol_index, ovalues)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    LOGICAL :: done
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, rownnz
    DOUBLE PRECISION, DIMENSION(nx*ny*nz, 7) :: imatrix
    INTEGER, DIMENSION(7) :: idiags
    INTEGER, DIMENSION(7) :: start_row_imatrix, end_row_imatrix
! row, column along diagonal
    INTEGER, DIMENSION(7) :: row_diag, col_diag
    INTEGER :: onnz
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: orow_index
    INTEGER, DIMENSION(7*(nx*ny*nz)) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*(nx*ny*nz)) :: ovalues
    INTEGER, DIMENSION(nx*ny*nz + 1) :: orow_compressed
    idiags(1) = -(nx*ny)
    idiags(2) = -nx
    idiags(3) = -1
    idiags(4) = 0
    idiags(5) = 1
    idiags(6) = nx
    idiags(7) = nx*ny
    onnz = 0
! compressed row storage
    orow_compressed(1) = 1
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix(i) = idiags(i) + 1
        end_row_imatrix(i) = nx*ny*nz
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix(i) = 1
        end_row_imatrix(i) = nx*ny*nz + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row_diag(i), col_diag(i))
    END DO
! Do for each row in imatrix
    DO i=1,nx*ny*nz
! count the number of nonzeros in row
      rownnz = 0
! Do for each column in imatrix
      DO j=1,7
! Need to check if that column has any entry in this row
! checks that you are past the beginning of diagonal, remains fixed
        IF (row_diag(j) .LE. i .AND. start_row_imatrix(j) .LE. &
&           end_row_imatrix(j)) THEN
! checks that you have not exhausted the diagonal
          IF (imatrix(start_row_imatrix(j), j) .NE. 0.0d0 .OR. idiags(j)&
&             .EQ. 0) THEN
! checks that the diagonal entry is non zero or is the main diagonal
            onnz = onnz + 1
            rownnz = rownnz + 1
            orow_index(onnz) = i
            ocol_index(onnz) = col_diag(j)
            ovalues(onnz) = imatrix(start_row_imatrix(j), j)
          END IF
          start_row_imatrix(j) = start_row_imatrix(j) + 1
          col_diag(j) = col_diag(j) + 1
        END IF
      END DO
      orow_compressed(i+1) = orow_compressed(i) + rownnz
    END DO
  END SUBROUTINE SPDIAGS_FVM_CSR
END MODULE FINITEVOLUME_B

MODULE SIMULATION_B
  USE PARAMETERS_B
  USE MATRIX_B
  USE FINITEVOLUME_B
  IMPLICIT NONE

CONTAINS
!  Differentiation of wrapper in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: oil
!   with respect to varying inputs: sigma oil mu
!   RW status of diff variables: p:(loc) q:(loc) s:(loc) v:(loc)
!                sigma:out oil:in-zero pc:(loc) mu:out
  SUBROUTINE WRAPPER_B(nx, ny, nz, nd, pt, st, mu, mub, sigma, sigmab, q&
&   , qb, s, sb, p, pb, v, vb, tt, pc, pcb, oil, oilb)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    INTEGER :: nd, pt, st
    DOUBLE PRECISION :: mu, sigma
    DOUBLE PRECISION :: mub, sigmab
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: qb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: sb
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx+1, ny+1, nz+1) :: vb
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(2, nd/st+1) :: pcb
    DOUBLE PRECISION :: oil
    DOUBLE PRECISION :: oilb
    CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT(nx, ny, nz, mu, sigma, q)
    CALL SIMULATE_RESERVOIR_B(nx, ny, nz, nd, pt, st, q, qb, s, sb, p, &
&                       pb, v, vb, tt, pc, pcb, oil, oilb)
    CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT_B(nx, ny, nz, mu, mub, sigma, &
&                                  sigmab, q, qb)
    oilb = 0.D0
  END SUBROUTINE WRAPPER_B
!  Differentiation of init_flw_trnc_norm_xin_pt_out in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: q
!   with respect to varying inputs: sigma mu
!
! Initialize inflow and outflow.
!
  SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT_B(nx, ny, nz, mu, mub, sigma&
&   , sigmab, q, qb)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    DOUBLE PRECISION :: mu, sigma
    DOUBLE PRECISION :: mub, sigmab
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: qb
    INTEGER :: i, j
    DOUBLE PRECISION :: x, pi, pdf, mass
    DOUBLE PRECISION :: pdfb, massb
    DOUBLE PRECISION, DIMENSION(nx) :: idx
    DOUBLE PRECISION, DIMENSION(nx) :: q_x
    DOUBLE PRECISION, DIMENSION(nx) :: q_xb
    INTRINSIC SQRT
    INTRINSIC EXP
    DOUBLE PRECISION :: temp1
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb1(nx)
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: temp
! value of pi
    pi = 3.14159265358979323d0
!initialize the total mass to 0
    mass = 0.0d0
    q_x = 0.0d0
! Note that the portion of the  Standard Normal distribution between
! -3sigma/2 to 3sigma/2 is assumed to fit the 1..Nx where sigma is 1
    DO i=1,nx
! get the real x coordinate
! Mapping x = [-1.5, 1.5] to nx dimension
      x = -1.5d0 + (i-1)*3.0d0/(nx-1)
! Now use mu and sigma to find the pdf value at x
      pdf = 1.0d0/(sigma*SQRT(2.0d0*pi))*EXP(-(((x-mu)/sigma)**2.0d0/&
&       2.0d0))
! set the value at the index equal to the pdf value at that point
      q_x(i) = pdf
! increment the mass by the value of the pdf
      mass = mass + pdf
! index to test initialization by plot
    END DO
! now rescale all the entities
! Assign Q_x to Q
    j = 1
    DO i=1,nx*ny,ny
      CALL PUSHINTEGER4(j)
      j = j + 1
    END DO
    qb(nx*ny*nz) = 0.D0
    q_xb = 0.D0
    DO i=nx*ny-MOD(nx*ny-1, ny),1,-ny
      CALL POPINTEGER4(j)
      q_xb(j) = q_xb(j) + qb(i)
      qb(i) = 0.D0
    END DO
    tempb1 = ir*q_xb/mass
    massb = SUM(-(q_x*tempb1/mass))
    q_xb = tempb1
    sigmab = 0.D0
    mub = 0.D0
    DO i=nx,1,-1
      pdfb = q_xb(i) + massb
      q_xb(i) = 0.D0
      x = -1.5d0 + (i-1)*3.0d0/(nx-1)
      temp1 = SQRT(2.0d0*pi)
      tempb = pdfb/(temp1*sigma)
      temp = (x-mu)/sigma
      temp0 = -(temp**2.0d0/2.0d0)
      tempb0 = -(temp*EXP(temp0)*tempb/sigma)
      mub = mub - tempb0
      sigmab = sigmab - EXP(temp0)*tempb/sigma - temp*tempb0
    END DO
  END SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT_B
!  Differentiation of simulate_reservoir in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: oil
!   with respect to varying inputs: q
!
! This subroutine simulates the reservoir
! model.
!
  SUBROUTINE SIMULATE_RESERVOIR_B(nx, ny, nz, nd, pt, st, q, qb, s, sb, &
&   p, pb, v, vb, tt, pc, pcb, oil, oilb)
    USE PARAMETERS_B
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    INTEGER :: nd, pt, st
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: qb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: sb
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx+1, ny+1, nz+1) :: vb
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(2, nd/st+1) :: pcb
    DOUBLE PRECISION :: oil
    DOUBLE PRECISION :: oilb
    INTEGER :: i, j, k
    DOUBLE PRECISION :: mw, mo, mt, tempoil1, tempoil2
    DOUBLE PRECISION :: mwb, mob, mtb, tempoil1b, tempoil2b
    INTEGER :: branch
! initial saturation
    s = swc_
! initial production
! initial time.
    k = 1
    DO i=1,nd/pt
      DO j=1,pt/st
        CALL PUSHINTEGER4(k)
        k = k + 1
        IF (j .EQ. 1) THEN
          CALL PUSHBOOLEAN(verbose)
          CALL PUSHINTEGER4(solver_outer)
          CALL PUSHINTEGER4(solver_inner)
          CALL PUSHREAL8(mo)
          CALL PUSHREAL8(mw)
          CALL PUSHREAL8ARRAY(v, 3*(nx+1)*(ny+1)*(nz+1))
          CALL PUSHREAL8ARRAY(p, nx*ny*nz)
          CALL PUSHREAL8ARRAY(s, nx*ny*nz)
          CALL PUSHREAL8ARRAY(q, nx*ny*nz)
          CALL STEPFORWARD(nx, ny, nz, nd, pt, st, 1, q, s, p, v, mw, mo&
&                   )
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHBOOLEAN(verbose)
          CALL PUSHINTEGER4(solver_outer)
          CALL PUSHINTEGER4(solver_inner)
          CALL PUSHREAL8(mo)
          CALL PUSHREAL8(mw)
          CALL PUSHREAL8ARRAY(v, 3*(nx+1)*(ny+1)*(nz+1))
          CALL PUSHREAL8ARRAY(p, nx*ny*nz)
          CALL PUSHREAL8ARRAY(s, nx*ny*nz)
          CALL PUSHREAL8ARRAY(q, nx*ny*nz)
          CALL STEPFORWARD(nx, ny, nz, nd, pt, st, 0, q, s, p, v, mw, mo&
&                   )
          CALL PUSHCONTROL1B(1)
        END IF
! update quantites
        CALL PUSHREAL8(mt)
        mt = mw + mo
      END DO
    END DO
    tempoil2b = oilb
    pb = 0.D0
    qb = 0.D0
    sb = 0.D0
    vb = 0.D0
    pcb = 0.D0
    tempoil1b = 0.D0
    DO i=nd/pt,1,-1
      DO j=pt/st,1,-1
        tempoil2b = tempoil2b + tempoil1b
        CALL UPDATE_OIL_B(nd, pt, st, pc, pcb, k, tempoil1, tempoil1b, &
&                   tempoil2, tempoil2b)
        mob = pcb(2, k)/mt
        mtb = -(mo*pcb(2, k)/mt**2)
        pcb(2, k) = 0.D0
        mtb = mtb - mw*pcb(1, k)/mt**2
        mwb = mtb + pcb(1, k)/mt
        pcb(1, k) = 0.D0
        CALL POPREAL8(mt)
        mob = mob + mtb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(q, nx*ny*nz)
          CALL POPREAL8ARRAY(s, nx*ny*nz)
          CALL POPREAL8ARRAY(p, nx*ny*nz)
          CALL POPREAL8ARRAY(v, 3*(nx+1)*(ny+1)*(nz+1))
          CALL POPREAL8(mw)
          CALL POPREAL8(mo)
          CALL POPINTEGER4(solver_inner)
          CALL POPINTEGER4(solver_outer)
          CALL POPBOOLEAN(verbose)
          CALL STEPFORWARD_B(nx, ny, nz, nd, pt, st, 1, q, qb, s, sb, p&
&                      , pb, v, vb, mw, mwb, mo, mob)
        ELSE
          CALL POPREAL8ARRAY(q, nx*ny*nz)
          CALL POPREAL8ARRAY(s, nx*ny*nz)
          CALL POPREAL8ARRAY(p, nx*ny*nz)
          CALL POPREAL8ARRAY(v, 3*(nx+1)*(ny+1)*(nz+1))
          CALL POPREAL8(mw)
          CALL POPREAL8(mo)
          CALL POPINTEGER4(solver_inner)
          CALL POPINTEGER4(solver_outer)
          CALL POPBOOLEAN(verbose)
          CALL STEPFORWARD_B(nx, ny, nz, nd, pt, st, 0, q, qb, s, sb, p&
&                      , pb, v, vb, mw, mwb, mo, mob)
        END IF
        CALL POPINTEGER4(k)
        tempoil2b = 0.D0
      END DO
    END DO
  END SUBROUTINE SIMULATE_RESERVOIR_B
!  Differentiation of stepforward in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: p q s v mo mw
!   with respect to varying inputs: p q s v
  SUBROUTINE STEPFORWARD_B(nx, ny, nz, nd, pt, st, pressure_step, q, qb&
&   , s, sb, p, pb, v, vb, mw, mwb, mo, mob)
    IMPLICIT NONE
! Mobilities in well-block
    INTEGER :: nx, ny, nz
    INTEGER :: nd, pt, st
    INTEGER :: pressure_step
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: qb
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: sb
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: pb
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx+1, ny+1, nz+1) :: vb
    DOUBLE PRECISION :: mw, mo
    DOUBLE PRECISION :: mwb, mob
    INTEGER :: branch
    IF (pressure_step .EQ. 1) THEN
! solve pressure
      CALL PUSHBOOLEAN(verbose)
      CALL PUSHINTEGER4(solver_outer)
      CALL PUSHINTEGER4(solver_inner)
      CALL PUSHREAL8ARRAY(p, nx*ny*nz)
      CALL PUSHREAL8ARRAY(q, nx*ny*nz)
      CALL PRES(nx, ny, nz, q, s, p, v)
! Pressure solver
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHBOOLEAN(verbose)
    CALL PUSHINTEGER4(solver_outer)
    CALL PUSHINTEGER4(solver_inner)
    CALL PUSHREAL8ARRAY(s, nx*ny*nz)
    CALL NEWTRAPH(nx, ny, nz, nd, pt, st, q, v, s)
! Solve for saturation
    CALL RELPERM_B(s(nx*ny*nz), sb(nx*ny*nz), mw, mwb, mo, mob)
    CALL POPREAL8ARRAY(s, nx*ny*nz)
    CALL POPINTEGER4(solver_inner)
    CALL POPINTEGER4(solver_outer)
    CALL POPBOOLEAN(verbose)
    CALL NEWTRAPH_B(nx, ny, nz, nd, pt, st, q, qb, v, vb, s, sb)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(q, nx*ny*nz)
      CALL POPREAL8ARRAY(p, nx*ny*nz)
      CALL POPINTEGER4(solver_inner)
      CALL POPINTEGER4(solver_outer)
      CALL POPBOOLEAN(verbose)
      CALL PRES_B(nx, ny, nz, q, qb, s, sb, p, pb, v, vb)
    END IF
  END SUBROUTINE STEPFORWARD_B
!  Differentiation of update_oil in reverse (adjoint) mode (with options noISIZE):
!   gradient     of useful results: oilout pc
!   with respect to varying inputs: oilin pc
  SUBROUTINE UPDATE_OIL_B(nd, pt, st, pc, pcb, k, oilin, oilinb, oilout&
&   , oiloutb)
    IMPLICIT NONE
    INTEGER :: k
    INTEGER :: nd, pt, st
    DOUBLE PRECISION :: oilin
    DOUBLE PRECISION :: oilinb
    DOUBLE PRECISION :: oilout
    DOUBLE PRECISION :: oiloutb
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(2, nd/st+1) :: pcb
! Reimann sum
    oilinb = oiloutb
    pcb(2, k) = pcb(2, k) + st*oiloutb
  END SUBROUTINE UPDATE_OIL_B
  SUBROUTINE WRAPPER(nx, ny, nz, nd, pt, st, mu, sigma, q, s, p, v, tt, &
&   pc, oil)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    INTEGER :: nd, pt, st
    DOUBLE PRECISION :: mu, sigma
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION :: oil
    CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT(nx, ny, nz, mu, sigma, q)
    CALL SIMULATE_RESERVOIR(nx, ny, nz, nd, pt, st, q, s, p, v, tt, pc, &
&                     oil)
  END SUBROUTINE WRAPPER
!
! Initialize inflow and outflow.
!
  SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT(nx, ny, nz, mu, sigma, q)
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    DOUBLE PRECISION :: mu, sigma
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    INTEGER :: i, j
    DOUBLE PRECISION :: x, pi, pdf, mass
    DOUBLE PRECISION, DIMENSION(nx) :: idx
    DOUBLE PRECISION, DIMENSION(nx) :: q_x
    INTRINSIC SQRT
    INTRINSIC EXP
! value of pi
    pi = 3.14159265358979323d0
!initialize the total mass to 0
    mass = 0.0d0
    q_x = 0.0d0
! Note that the portion of the  Standard Normal distribution between
! -3sigma/2 to 3sigma/2 is assumed to fit the 1..Nx where sigma is 1
    DO i=1,nx
! get the real x coordinate
! Mapping x = [-1.5, 1.5] to nx dimension
      x = -1.5d0 + (i-1)*3.0d0/(nx-1)
! Now use mu and sigma to find the pdf value at x
      pdf = 1.0d0/(sigma*SQRT(2.0d0*pi))*EXP(-(((x-mu)/sigma)**2.0d0/&
&       2.0d0))
! set the value at the index equal to the pdf value at that point
      q_x(i) = pdf
! increment the mass by the value of the pdf
      mass = mass + pdf
! index to test initialization by plot
      idx(i) = i*1.0
    END DO
! now rescale all the entities
! Assign Q_x to Q
    q_x = q_x/mass*ir
! Assign Q_x to Q
    j = 1
    DO i=1,nx*ny,ny
      q(i) = q_x(j)
      j = j + 1
    END DO
! now set the output
    q(nx*ny*nz) = -ir
  END SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT
!
! This subroutine simulates the reservoir
! model.
!
  SUBROUTINE SIMULATE_RESERVOIR(nx, ny, nz, nd, pt, st, q, s, p, v, tt, &
&   pc, oil)
    USE PARAMETERS_B
    IMPLICIT NONE
    INTEGER :: nx, ny, nz
    INTEGER :: nd, pt, st
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION :: oil
    INTEGER :: i, j, k
    DOUBLE PRECISION :: mw, mo, mt, tempoil1, tempoil2
! initial saturation
    s = swc_
! initial production
! initial time.
    pc(1, 1) = 0.0d0
    pc(2, 1) = 1.0d0
! initial time.
    tt(1) = 0.0d0
    tempoil1 = 0.0d0
    tempoil2 = 0.0d0
    k = 1
    DO i=1,nd/pt
      DO j=1,pt/st
        k = k + 1
        IF (j .EQ. 1) THEN
          CALL STEPFORWARD(nx, ny, nz, nd, pt, st, 1, q, s, p, v, mw, mo&
&                   )
        ELSE
          CALL STEPFORWARD(nx, ny, nz, nd, pt, st, 0, q, s, p, v, mw, mo&
&                   )
        END IF
! update quantites
        mt = mw + mo
        tt(k) = 1.0d0*k*st
        pc(1, k) = mw/mt
        pc(2, k) = mo/mt
        CALL UPDATE_OIL(nd, pt, st, pc, k, tempoil1, tempoil2)
        tempoil1 = tempoil2
      END DO
    END DO
    oil = tempoil2
  END SUBROUTINE SIMULATE_RESERVOIR
  SUBROUTINE STEPFORWARD(nx, ny, nz, nd, pt, st, pressure_step, q, s, p&
&   , v, mw, mo)
    IMPLICIT NONE
! Mobilities in well-block
    INTEGER :: nx, ny, nz
    INTEGER :: nd, pt, st
    INTEGER :: pressure_step
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: q
    DOUBLE PRECISION, DIMENSION(nx*ny*nz) :: s
    DOUBLE PRECISION, DIMENSION(nx, ny, nz) :: p
    DOUBLE PRECISION, DIMENSION(3, nx + 1, ny + 1, nz + 1) :: v
    DOUBLE PRECISION :: mw, mo
    IF (pressure_step .EQ. 1) CALL PRES(nx, ny, nz, q, s, p, v)
! solve pressure
! Pressure solver
    CALL NEWTRAPH(nx, ny, nz, nd, pt, st, q, v, s)
! Solve for saturation
    CALL RELPERM(s(nx*ny*nz), mw, mo)
  END SUBROUTINE STEPFORWARD
  SUBROUTINE UPDATE_OIL(nd, pt, st, pc, k, oilin, oilout)
    IMPLICIT NONE
    INTEGER :: k
    INTEGER :: nd, pt, st
    DOUBLE PRECISION :: oilin
    DOUBLE PRECISION :: oilout
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
! Reimann sum
    oilout = oilin + pc(2, k)*st
  END SUBROUTINE UPDATE_OIL
END MODULE SIMULATION_B

