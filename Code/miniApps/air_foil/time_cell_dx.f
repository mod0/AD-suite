C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
C
C  Differentiation of time_cell in forward (tangent) mode:
C   variations   of useful results: adt
C   with respect to varying inputs: q x1 x2 x3 x4
C   RW status of diff variables: q:in adt:out x1:in x2:in x3:in
C                x4:in
C
C
Ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C                                                                   c
C      Nonlinear routines used in airfoil calculations              c
C                                                                   c
C      linear/adjoint versions are created on-the-fly by Tapenade   c
C      complex version is generated using compiler flag -DCOMPLEX   c
C                                                                   c
C      Copyright Devendra Ghate and Mike Giles, 2005                c
C      but can be freely used with due acknowledgement              c
C                                                                   c
C      Tapenade developed by Laurent Hascoet and others at INRIA    c
C                                                                   c
Ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C
C
C
C
      SUBROUTINE TIME_CELL_DX(x1, x1d, x2, x2d, x3, x3d, x4, x4d, q, qd, 
     +                       adt, adtd)
      IMPLICIT NONE
      REAL*8 gam, gm1, cfl, eps, mach, alpha
C
      COMMON /constants/ gam, gm1, cfl, eps, mach, alpha
C
C
      INTEGER i
C
      REAL*8 x1(2), x2(2), x3(2), x4(2), q(4), adt, dx(4), dy(4), ri, u
     +       , v, p, c
      REAL*8 x1d(2), x2d(2), x3d(2), x4d(2), qd(4), adtd, dxd(4), dyd(4)
     +       , rid, ud, vd, pd, cd
      INTRINSIC SQRT
      INTRINSIC ABS
      REAL*8 arg1
      REAL*8 arg1d
      REAL*8 result1
      REAL*8 result1d
      REAL*8 abs0d
      REAL*8 abs0
      INTEGER ii1
C
C
C
C
C
C
C
      DO ii1=1,4
        dxd(ii1) = 0.0
      ENDDO
      dxd(1) = x2d(1) - x1d(1)
      dx(1) = x2(1) - x1(1)
      dxd(2) = x3d(1) - x2d(1)
      dx(2) = x3(1) - x2(1)
      dxd(3) = x4d(1) - x3d(1)
      dx(3) = x4(1) - x3(1)
      dxd(4) = x1d(1) - x4d(1)
      dx(4) = x1(1) - x4(1)
C
      DO ii1=1,4
        dyd(ii1) = 0.0
      ENDDO
      dyd(1) = x2d(2) - x1d(2)
      dy(1) = x2(2) - x1(2)
      dyd(2) = x3d(2) - x2d(2)
      dy(2) = x3(2) - x2(2)
      dyd(3) = x4d(2) - x3d(2)
      dy(3) = x4(2) - x3(2)
      dyd(4) = x1d(2) - x4d(2)
      dy(4) = x1(2) - x4(2)
C
      rid = -(qd(1)/q(1)**2)
      ri = 1.d0/q(1)
      ud = rid*q(2) + ri*qd(2)
      u = ri*q(2)
      vd = rid*q(3) + ri*qd(3)
      v = ri*q(3)
      pd = gm1*(qd(4)-0.5d0*(rid*(q(2)**2+q(3)**2)+ri*(2*q(2)*qd(2)+2*q(
     +  3)*qd(3))))
      p = gm1*(q(4)-0.5d0*ri*(q(2)**2+q(3)**2))
      arg1d = gam*(rid*p+ri*pd)
      arg1 = gam*ri*p
      IF (arg1 .EQ. 0.0) THEN
        cd = 0.D0
      ELSE
        cd = arg1d/(2.0*SQRT(arg1))
      END IF
      c = SQRT(arg1)
C
      adt = 0
      adtd = 0.0
C
      DO i=1,4
        IF (u*dy(i) - v*dx(i) .GE. 0.) THEN
          abs0d = ud*dy(i) + u*dyd(i) - vd*dx(i) - v*dxd(i)
          abs0 = u*dy(i) - v*dx(i)
        ELSE
          abs0d = -(ud*dy(i)+u*dyd(i)-vd*dx(i)-v*dxd(i))
          abs0 = -(u*dy(i)-v*dx(i))
        END IF
        arg1d = 2*dx(i)*dxd(i) + 2*dy(i)*dyd(i)
        arg1 = dx(i)**2 + dy(i)**2
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.D0
        ELSE
          result1d = arg1d/(2.0*SQRT(arg1))
        END IF
        result1 = SQRT(arg1)
        adtd = adtd + abs0d + cd*result1 + c*result1d
        adt = adt + abs0 + c*result1
      ENDDO
C
      adtd = adtd/cfl
      adt = adt/cfl
C
      RETURN
      END
