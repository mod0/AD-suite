C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
C
C  Differentiation of time_cell in reverse (adjoint) mode:
C   gradient     of useful results: q adt
C   with respect to varying inputs: q adt
C   RW status of diff variables: q:incr adt:in-zero
C
C
Ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C                                                                   c
C      Nonlinear routines used in airfoil calculations              c
C                                                                   c
C      linear/adjoint versions are created on-the-fly by Tapenade   c
C      complex version is generated using compiler flag -DCOMPLEX   c
C                                                                   c
C      Copyright Devendra Ghate and Mike Giles, 2005                c
C      but can be freely used with due acknowledgement              c
C                                                                   c
C      Tapenade developed by Laurent Hascoet and others at INRIA    c
C                                                                   c
Ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C
C
C
C
      SUBROUTINE TIME_CELL_B(x1, x2, x3, x4, q, qb, adt, adtb)
      IMPLICIT NONE
      REAL*8 gam, gm1, cfl, eps, mach, alpha
C
      COMMON /constants/ gam, gm1, cfl, eps, mach, alpha
C
C
      INTEGER i
C
      REAL*8 x1(2), x2(2), x3(2), x4(2), q(4), adt, dx(4), dy(4), ri, u
     +       , v, p, c
      REAL*8 qb(4), adtb, rib, ub, vb, pb, cb
      INTRINSIC SQRT
      INTRINSIC ABS
      INTEGER branch
      REAL*8 tempb0
      REAL*8 abs0b
      REAL*8 tempb
      REAL*8 abs0
C
C
C
C
C
C
C
      dx(1) = x2(1) - x1(1)
      dx(2) = x3(1) - x2(1)
      dx(3) = x4(1) - x3(1)
      dx(4) = x1(1) - x4(1)
C
      dy(1) = x2(2) - x1(2)
      dy(2) = x3(2) - x2(2)
      dy(3) = x4(2) - x3(2)
      dy(4) = x1(2) - x4(2)
C
      ri = 1.d0/q(1)
      u = ri*q(2)
      v = ri*q(3)
      p = gm1*(q(4)-0.5d0*ri*(q(2)**2+q(3)**2))
C
C
      DO i=1,4
        IF (u*dy(i) - v*dx(i) .GE. 0.) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      ENDDO
      adtb = adtb/cfl
      ub = 0.0
      vb = 0.0
      cb = 0.0
      DO i=4,1,-1
        abs0b = adtb
        cb = cb + SQRT(dx(i)**2+dy(i)**2)*adtb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          ub = ub + dy(i)*abs0b
          vb = vb - dx(i)*abs0b
        ELSE
          vb = vb + dx(i)*abs0b
          ub = ub - dy(i)*abs0b
        END IF
      ENDDO
      IF (gam*(ri*p) .EQ. 0.0) THEN
        tempb = 0.0
      ELSE
        tempb = gam*cb/(2.0*SQRT(gam*(ri*p)))
      END IF
      pb = ri*tempb
      tempb0 = -(gm1*0.5d0*pb)
      rib = (q(2)**2+q(3)**2)*tempb0 + q(2)*ub + q(3)*vb + p*tempb
      qb(4) = qb(4) + gm1*pb
      qb(2) = qb(2) + ri*2*q(2)*tempb0
      qb(3) = qb(3) + ri*vb + ri*2*q(3)*tempb0
      qb(2) = qb(2) + ri*ub
      qb(1) = qb(1) - rib/q(1)**2
      adtb = 0.0
      END
