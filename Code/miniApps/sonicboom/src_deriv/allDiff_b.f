C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.11 (r6097M) - 24 Jun 2016 18:51
C
C  Differentiation of psiroe in reverse (adjoint) mode:
C   gradient     of useful results: ce
C   with respect to varying inputs: ua ce
C   RW status of diff variables: ua:out ce:in-out
      SUBROUTINE PSIROE_B(ctrl, ctrlno)
      IMPLICIT NONE
C     -----------------------------------------------------------------
C     Degres de liberte
      INTEGER nequation
      PARAMETER (nequation=5)
C
C     Maximum number of vertices 
      INTEGER nsmax
      PARAMETER (nsmax=12966)
C     Maximum number of tetraedra
      INTEGER ntmax
      PARAMETER (ntmax=65421)
C     Maximum number of boundary faces
      INTEGER nfcmax
      PARAMETER (nfcmax=7350)
C     Maximum number of edges 
      INTEGER nsgmax
      PARAMETER (nsgmax=82056)
C     Maximum number of edges attached to a mesh vertex
      INTEGER ndmax
      PARAMETER (ndmax=150)
C     Maximum number of tetraedra attached to a mesh vertex
      INTEGER nvmax
      PARAMETER (nvmax=49)
C     Allowable values for boundary vertices logical reference
      INTEGER klogmin, klogmax
      PARAMETER (klogmin=1, klogmax=30)
C     Maximum numbers of colors for the tetraedra and edges 
      INTEGER nctmax, ncamax
      PARAMETER (nctmax=710, ncamax=710)
C     Characteristic length for vectorisation
      INTEGER lvect
      PARAMETER (lvect=128)
C     Maximum length of arrays for vector operations
      INTEGER lvmax
      PARAMETER (lvmax=128)
C     -----------------------------------------------------------------
C     Maximum number of timers
      INTEGER icpmax
      PARAMETER (icpmax=21)
C     Timers definition
      REAL*8 time(icpmax)
C     Mflop rates
      REAL*8 flop(icpmax)
C
      COMMON /rtimrs/ time, flop
C
C     -----------------------------------------------------------------
C     Effective numbers of tetraedra and edges colors 
      INTEGER nca, nct
C     Data structures for the tetraedra and edges colors
      INTEGER icolt(0:nctmax), icola(0:ncamax)
      INTEGER mark(nsgmax)
C
      COMMON /icolor/ nca, nct, icolt, icola, mark
C
C     -----------------------------------------------------------------
C     Effective numbers of vertices, tetraedra, edges and 
C     boundary faces
      INTEGER ns, nt, nseg, nfac
C     Tetraedra connectivity table
      INTEGER nu(4, ntmax)
C     Boundary faces connectivity table
      INTEGER nsfac(3, nfcmax)
C     Boundary faces logical reference table
      INTEGER logfac(nfcmax), log1fac(nfcmax)
C     Boundary vertices logical reference table
      INTEGER logfr(nsmax)
C     Auxiliary table for boundary vertices logical reference 
      INTEGER fv(nsmax)
C     Boundary faces index table
      INTEGER noe1(nfcmax)
C     Effective numbers of faces for each allowable value of
C     boundary face logical reference
      INTEGER nblog(klogmin:klogmax)
C     Edges connectivity table
      INTEGER nubo(2, nsgmax)
C     Effective number of edges attached to a mesh vertex
      INTEGER ndeg(nsmax), inew(nsmax)
C     Identification of the set of edges attached to 
C     a mesh vertex
      INTEGER jaret(nsmax, ndmax)
C     Effective number of tetraedra attached to a mesh vertex
      INTEGER nbvoi(nsmax)
C     Identification of the set of tetraedra attached to 
C     a mesh vertex
      INTEGER ivoi(nsmax, nvmax)
C     Identification of the upstream and downstream tetraedra 
C     associated to an edge
      INTEGER jta(2, nsgmax)
C     Effective number of faces with a given boundary logical 
C     reference 
      INTEGER nf1, nf2, nf3, nf11
C   
      COMMON /igeom0/ ns, nt, nseg, nfac
      COMMON /igeom1/ nu, nsfac, logfac, nubo, logfr, log1fac
      COMMON /igeom2/ noe1, nblog, fv
      COMMON /igeom3/ nf1, nf2, nf3, nf11
      COMMON /igeom4/ ndeg, inew, jaret, nbvoi, ivoi, jta
C
C     Initial and instantaneous coordinates of the mesh vertices
      REAL*8 coor(3, nsmax), coco(3, nsmax)
C     Initial mesh coordinates (zz)
      REAL*8 coin(3, nsmax)
C     Control volume and tetraedra volumes
      REAL*8 vols(nsmax), volt(ntmax)
C     Control volume boundary normal components
      REAL*8 vnocl(3, nsgmax)
C     Boundary faces normal components
      REAL*8 vnfac(3, nfcmax)
C     Mean values of the normal to tetradra faces
      REAL*8 tvno(ntmax, 4, 3)
C 
      COMMON /rgeom1/ coor, coco, coin
      COMMON /rgeom2/ vols, volt, vnocl, vnfac
      COMMON /rgeom3/ tvno
C
C     -----------------------------------------------------------------
C     Physical solution
      REAL*8 ua(5, nsmax), un(5, nsmax)
      REAL*8 uab(5, nsmax)
C     Nodal fluxes (gathered convective and diffusive fluxes)
      REAL*8 ce(5, nsmax)
      REAL*8 ceb(5, nsmax)
C     Nodal gradients
      REAL*8 dx(5, nsmax), dy(5, nsmax), dz(5, nsmax)
      REAL*8 dxb(5, nsmax), dyb(5, nsmax), dzb(5, nsmax)
C     Local time steps
      REAL*8 dtl(nsmax)
C     Mesh vertices velocities
      REAL*8 xw1(nsmax), xw2(nsmax), xw3(nsmax)
C     Mean value of mesh edges and boundary faces velocities
      REAL*8 sigma(nsgmax), vnsig(nfcmax)
C     Auxiliary array used during mesh vertices based operations
      REAL*8 ce1(nsmax)
C
      COMMON /rsol1/ ua, un, ce, dx, dy, dz
      COMMON /rsol2/ dtl
      COMMON /rsol3/ xw1, xw2, xw3
      COMMON /rsol4/ sigma, vnsig
      COMMON /rsol5/ ce1
C
C     -----------------------------------------------------------------
C     Reinitialisation flag 
      INTEGER ncont
C     Local time-step strategy flag
      INTEGER iloc
C     Courant number law parameters
      REAL*8 cfl, xcfl, ycfl, zcfl, cflmax
C     Convective flux solver identifier
      INTEGER iflux
C     Spatial approximation precision order
      INTEGER nordre
C     Predictor-corrector time integration scheme flag
      INTEGER ipred
C     Maximum, initial and effective number of time steps
      INTEGER ktmax, kt0, kt
C     Flag for a viscous computation
      INTEGER ivis
C     Flag for a moving mesh computation
      INTEGER idefor
C     Flag used when deforming the mesh
      INTEGER imcas
C     Flag for explicit/implicit time integration 
C     Maximum and effective number of relaxations in the 
C     implicit phase
C     Relaxations pour l'etat-adjoint
      INTEGER nexp, nbrel, nit, nbrelpi
C     Linear system solver identifier
      INTEGER irlax
C     Flag for the type of storage used for the extra-diagonal 
C     blocks 
      INTEGER istok
C     Residual tolerance for the linear iteration (implicit phase)
      REAL*8 err
C     Maximal, initial and effective  physical time 
      REAL*8 tmax, t0, t
C     Global and maximal allowable time step
      REAL*8 dt, ddtmax
C     Residual tolerance for the non-linear iteration
      REAL*8 resf
C     Flow characteristic quantities
      REAL*8 rhoref, pref, lref, vref
C     Free stream Mach number
      REAL*8 xmach
C     Free stream quantities used to define the free stream 
C     physical states
      REAL*8 roin, uxin, uyin, uzin, pin
      REAL*8 roout, uxout, uyout, uzout, pout
C     Free stream physical states
      REAL*8 ub2(5, nfcmax), ub3(5, nfcmax)
C     Real gaz physical quantities
      REAL*8 gam, gam1
C     Reynolds and Prandtl numbers, viscosisty and temperature 
C     on the body
      REAL*8 rey, pr, xmu, tbrd
C
      INTEGER oneshot
      COMMON /ressimul/ oneshot
C
C     Nombre d'iterations de jacobi pour resoudre l'etat et l'etat-adjoint
C     en one-shot
      INTEGER nbrelos
C
      COMMON /icmflg/ ncont, iloc, ivis, idefor, ipred
      COMMON /icmflx/ iflux
      COMMON /icmgrd/ imcas
      COMMON /icmimp/ nexp, nbrel, nit, irlax, istok, nbrelos, nbrelpi
      COMMON /icmord/ nordre
C
C     Nombre d'iterations maximales pour l'etat en one-shot
      INTEGER ktmaxos
      COMMON /icmstp/ ktmax, kt0, kt, ktmaxos
C
C     Residu a atteindre pour resoudre l'etat-adjoint
      REAL*8 errjacpi
C
      COMMON /rcmstp/ tmax, t0, t, resf
      COMMON /rcmdtg/ dt, ddtmax
      COMMON /rcmimp/ err, errjacpi
      COMMON /comcfl/ cfl, xcfl, ycfl, zcfl, cflmax
      COMMON /comref/ rhoref, pref, lref, vref
      COMMON /frsmch/ xmach
      COMMON /frstr1/ roin, uxin, uyin, uzin, pin, roout, uxout, uyout, 
     +uzout, pout
      COMMON /frstr2/ ub2, ub3
      COMMON /comgam/ gam, gam1
      COMMON /comvis/ rey, pr, xmu, tbrd
C
C     -----------------------------------------------------------------
C     Frequency parameters used when printing and saving the physical 
C     solution
      INTEGER ifre, ifre1, impre, ifrel
C
      COMMON /icmedt/ ifre, ifre1, impre, ifrel
C
C     -----------------------------------------------------------------
C     Selected problem identifier
      INTEGER coefm1
C     Variables related to the piston engine geometry
      REAL*8 cadmax, cads
      REAL*8 thet0, ca, squish, rps, stroke, conrod
      REAL*8 wpist, wspa, wspe
      REAL*8 vpist(3), vspa(3), vspe(3)
      REAL*8 aoa, aoe, rfa, rfe, lma, lme
      REAL*8 hpist, hspa, hspe, hplan, href
C
      COMMON /icmpst/ coefm1
C
      COMMON /cmpst0/ cadmax, cads
      COMMON /cmpst1/ thet0, ca, squish, rps, stroke, conrod
      COMMON /cmpst2/ wpist, wspa, wspe, vpist, vspa, vspe
      COMMON /cmpst3/ aoa, aoe, rfa, rfe, lma, lme
      COMMON /cmpst4/ hpist, hspa, hspe, hplan, href
C
C     -----------------------------------------------------------------
C     Parameters and data structures related to the implicit time 
C     integration scheme
      INTEGER nsegs
      PARAMETER (nsegs=50*nsgmax)
C     Storage of the diagonal blocks
      REAL*8 diag(nsmax, 5, 5), adh1(nsmax)
C     Storage of the extra diagonal blocks
      REAL*8 stmat(nsegs)
C     Stockage des termes extra-diagonaux de la matrice
      REAL*8 zm(5, 5, 2, nsgmax)
C
      COMMON /comimp/ diag, stmat, adh1, zm
C 
C     -----------------------------------------------------------------
C     Auxiliary variables used when computing the convective fluxes
      INTEGER ient, icoef
      REAL*8 epsiim, epsiex
C
      COMMON /icmfx1/ ient, icoef
      COMMON /rcmfx1/ epsiim, epsiex
C
C     -----------------------------------------------------------------
C     Auxiliary  variables related to the moving mesh feature
C     Maximum and effective number of relaxations in the 
C     moving mesh phase
      INTEGER maxjac, kjac
C     Residual tolerance and effective residual for the linear 
C     iteration in the moving mesh phase phase
      REAL*8 rsjacf, rsjac
C     Elastic center coordinates
      REAL*8 xce, yce, zce
C     Instantaneous angle of attack
      REAL*8 tetat
C     Original coordinates of the mesh vertices
      REAL*8 xt0(nsmax), yt0(nsmax), zt0(nsmax)
C     Displacements of the mesh vertices
      REAL*8 deltx(2, nsmax), delty(2, nsmax), deltz(2, nsmax)
C     Predicted displacements of the mesh vertices
      REAL*8 deltxp(nsmax), deltyp(nsmax), deltzp(nsmax)
C
      COMMON /imomsh/ maxjac, kjac
      COMMON /mvmsh0/ rsjacf, rsjac
      COMMON /mvmsh1/ xce, yce, zce, tetat
      COMMON /mvmsh2/ xt0, yt0, zt0
      COMMON /mvmsh3/ deltx, delty, deltz, deltxp, deltyp, deltzp
C
      REAL*8 som1, dro1, som, dro
      COMMON /residus/ som1, dro1, som, dro
C
      REAL*8 omega
      COMMON /newton/ omega
C
      INTEGER diric, bound
      COMMON /boundaries/ diric, bound
C
C     NODE3D2D :Tab. de correspondance entre maillage et coque sur les noeuds
C     FACE3D2D :  "            "         "      "          "           faces
C
      INTEGER node3d2d(nsmax), face3d2d(nfcmax)
      COMMON /corres3d2d/ node3d2d, face3d2d
C
      REAL*8 pdesp(nsmax), djdw(5, nsmax), piadj(5, nsmax)
      COMMON /pression/ pdesp
      COMMON /opti/ djdw, piadj
C
      INTEGER validpsi, newton, testder, testadj, testgrad, testderw
      COMMON /verif/ validpsi, newton, testder, testadj, testgrad, 
     +testderw
C
      INTEGER itmax, itopt, ncf, npres, ncontopt, contr, defortuy
      COMMON /optimis/ itmax, itopt, ncf, npres, ncontopt, contr, 
     +defortuy
C
      INTEGER niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
      COMMON /hiera/ niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
C
      REAL*8 erreur, roopt, roinit, roos
      COMMON /resopti/ erreur, roopt, roinit, roos
C
      REAL*8 coeftrainee, teta, cltarget, cdinit, cdtarget, tetacdcl
      REAL*8 coefpres
      REAL*8 tetaxy, tetaxz, tetazy
      INTEGER*4 igicc
      COMMON /iangles/ igicc
      COMMON /calctrainchoc/ coeftrainee, cltarget, cdinit, cdtarget
      COMMON /anglesincid/ teta, tetacdcl, coefpres, tetaxy, tetaxz, 
     +tetazy
C
C     ZZ PARAMETERS:
C     ===============
C
      INTEGER intzz(30)
      COMMON /integerzz/ intzz
C     CPU time evaluation (all real*4)
      REAL*8 pmnew, pmold
      COMMON /mxmi/ pmnew, pmold
      INCLUDE 'Paramopt3D.h'
C---------------------------------------------------------------------
C
      INTEGER*4 is, ia
      REAL*8 ctrlno, ctrl(nnsp)
      INTEGER branch
      INTEGER ii2
      INTEGER ii1
      COMMON /rsol1_b/ uab, ceb, dxb, dyb, dzb
C
C
      DO is=1,ns
        DO ia=1,5
          dx(ia, is) = 0.0
          dy(ia, is) = 0.0
          dz(ia, is) = 0.0
        ENDDO
      ENDDO
C
C...  Compute the hermitian nodal gradients
      CALL PUSHREAL8ARRAY(dz, 5*nsmax)
      CALL PUSHREAL8ARRAY(dy, 5*nsmax)
      CALL PUSHREAL8ARRAY(dx, 5*nsmax)
      CALL GRADNOD()
C
C...  Compute the convective fluxes
C
C...  Compute the boundary conditions
C
      IF (itrans .EQ. 1 .AND. ctrlno .GT. 1.0d-10) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL CONDDIRFLUX_B()
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL TRANSPIRATION_B(ce, ceb, ctrl)
      ELSE
        DO ii1=1,nsmax
          DO ii2=1,5
            uab(ii2, ii1) = 0.0
          ENDDO
        ENDDO
      END IF
      CALL VCURVM_B(ctrlno)
      CALL FLUROE_B()
      CALL POPREAL8ARRAY(dx, 5*nsmax)
      CALL POPREAL8ARRAY(dy, 5*nsmax)
      CALL POPREAL8ARRAY(dz, 5*nsmax)
      CALL GRADNOD_B()
      DO is=nsmax,1,-1
        ceb(5, is) = 0.D0
        ceb(4, is) = 0.D0
        ceb(3, is) = 0.D0
        ceb(2, is) = 0.D0
        ceb(1, is) = 0.D0
      ENDDO
      END

C  Differentiation of conddirflux in reverse (adjoint) mode:
C   gradient     of useful results: ce
C   with respect to varying inputs: ce
      SUBROUTINE CONDDIRFLUX_B()
      IMPLICIT NONE
C
C     -----------------------------------------------------------------
C     Degres de liberte
      INTEGER nequation
      PARAMETER (nequation=5)
C
C     Maximum number of vertices 
      INTEGER nsmax
      PARAMETER (nsmax=12966)
C     Maximum number of tetraedra
      INTEGER ntmax
      PARAMETER (ntmax=65421)
C     Maximum number of boundary faces
      INTEGER nfcmax
      PARAMETER (nfcmax=7350)
C     Maximum number of edges 
      INTEGER nsgmax
      PARAMETER (nsgmax=82056)
C     Maximum number of edges attached to a mesh vertex
      INTEGER ndmax
      PARAMETER (ndmax=150)
C     Maximum number of tetraedra attached to a mesh vertex
      INTEGER nvmax
      PARAMETER (nvmax=49)
C     Allowable values for boundary vertices logical reference
      INTEGER klogmin, klogmax
      PARAMETER (klogmin=1, klogmax=30)
C     Maximum numbers of colors for the tetraedra and edges 
      INTEGER nctmax, ncamax
      PARAMETER (nctmax=710, ncamax=710)
C     Characteristic length for vectorisation
      INTEGER lvect
      PARAMETER (lvect=128)
C     Maximum length of arrays for vector operations
      INTEGER lvmax
      PARAMETER (lvmax=128)
C     -----------------------------------------------------------------
C     Maximum number of timers
      INTEGER icpmax
      PARAMETER (icpmax=21)
C     Timers definition
      REAL*8 time(icpmax)
C     Mflop rates
      REAL*8 flop(icpmax)
C
      COMMON /rtimrs/ time, flop
C
C     -----------------------------------------------------------------
C     Effective numbers of tetraedra and edges colors 
      INTEGER nca, nct
C     Data structures for the tetraedra and edges colors
      INTEGER icolt(0:nctmax), icola(0:ncamax)
      INTEGER mark(nsgmax)
C
      COMMON /icolor/ nca, nct, icolt, icola, mark
C
C     -----------------------------------------------------------------
C     Effective numbers of vertices, tetraedra, edges and 
C     boundary faces
      INTEGER ns, nt, nseg, nfac
C     Tetraedra connectivity table
      INTEGER nu(4, ntmax)
C     Boundary faces connectivity table
      INTEGER nsfac(3, nfcmax)
C     Boundary faces logical reference table
      INTEGER logfac(nfcmax), log1fac(nfcmax)
C     Boundary vertices logical reference table
      INTEGER logfr(nsmax)
C     Auxiliary table for boundary vertices logical reference 
      INTEGER fv(nsmax)
C     Boundary faces index table
      INTEGER noe1(nfcmax)
C     Effective numbers of faces for each allowable value of
C     boundary face logical reference
      INTEGER nblog(klogmin:klogmax)
C     Edges connectivity table
      INTEGER nubo(2, nsgmax)
C     Effective number of edges attached to a mesh vertex
      INTEGER ndeg(nsmax), inew(nsmax)
C     Identification of the set of edges attached to 
C     a mesh vertex
      INTEGER jaret(nsmax, ndmax)
C     Effective number of tetraedra attached to a mesh vertex
      INTEGER nbvoi(nsmax)
C     Identification of the set of tetraedra attached to 
C     a mesh vertex
      INTEGER ivoi(nsmax, nvmax)
C     Identification of the upstream and downstream tetraedra 
C     associated to an edge
      INTEGER jta(2, nsgmax)
C     Effective number of faces with a given boundary logical 
C     reference 
      INTEGER nf1, nf2, nf3, nf11
C   
      COMMON /igeom0/ ns, nt, nseg, nfac
      COMMON /igeom1/ nu, nsfac, logfac, nubo, logfr, log1fac
      COMMON /igeom2/ noe1, nblog, fv
      COMMON /igeom3/ nf1, nf2, nf3, nf11
      COMMON /igeom4/ ndeg, inew, jaret, nbvoi, ivoi, jta
C
C     Initial and instantaneous coordinates of the mesh vertices
      REAL*8 coor(3, nsmax), coco(3, nsmax)
C     Initial mesh coordinates (zz)
      REAL*8 coin(3, nsmax)
C     Control volume and tetraedra volumes
      REAL*8 vols(nsmax), volt(ntmax)
C     Control volume boundary normal components
      REAL*8 vnocl(3, nsgmax)
C     Boundary faces normal components
      REAL*8 vnfac(3, nfcmax)
C     Mean values of the normal to tetradra faces
      REAL*8 tvno(ntmax, 4, 3)
C 
      COMMON /rgeom1/ coor, coco, coin
      COMMON /rgeom2/ vols, volt, vnocl, vnfac
      COMMON /rgeom3/ tvno
C
C     -----------------------------------------------------------------
C     Physical solution
      REAL*8 ua(5, nsmax), un(5, nsmax)
      REAL*8 uab(5, nsmax)
C     Nodal fluxes (gathered convective and diffusive fluxes)
      REAL*8 ce(5, nsmax)
      REAL*8 ceb(5, nsmax)
C     Nodal gradients
      REAL*8 dx(5, nsmax), dy(5, nsmax), dz(5, nsmax)
      REAL*8 dxb(5, nsmax), dyb(5, nsmax), dzb(5, nsmax)
C     Local time steps
      REAL*8 dtl(nsmax)
C     Mesh vertices velocities
      REAL*8 xw1(nsmax), xw2(nsmax), xw3(nsmax)
C     Mean value of mesh edges and boundary faces velocities
      REAL*8 sigma(nsgmax), vnsig(nfcmax)
C     Auxiliary array used during mesh vertices based operations
      REAL*8 ce1(nsmax)
C
      COMMON /rsol1/ ua, un, ce, dx, dy, dz
      COMMON /rsol2/ dtl
      COMMON /rsol3/ xw1, xw2, xw3
      COMMON /rsol4/ sigma, vnsig
      COMMON /rsol5/ ce1
C
C     -----------------------------------------------------------------
C     Reinitialisation flag 
      INTEGER ncont
C     Local time-step strategy flag
      INTEGER iloc
C     Courant number law parameters
      REAL*8 cfl, xcfl, ycfl, zcfl, cflmax
C     Convective flux solver identifier
      INTEGER iflux
C     Spatial approximation precision order
      INTEGER nordre
C     Predictor-corrector time integration scheme flag
      INTEGER ipred
C     Maximum, initial and effective number of time steps
      INTEGER ktmax, kt0, kt
C     Flag for a viscous computation
      INTEGER ivis
C     Flag for a moving mesh computation
      INTEGER idefor
C     Flag used when deforming the mesh
      INTEGER imcas
C     Flag for explicit/implicit time integration 
C     Maximum and effective number of relaxations in the 
C     implicit phase
C     Relaxations pour l'etat-adjoint
      INTEGER nexp, nbrel, nit, nbrelpi
C     Linear system solver identifier
      INTEGER irlax
C     Flag for the type of storage used for the extra-diagonal 
C     blocks 
      INTEGER istok
C     Residual tolerance for the linear iteration (implicit phase)
      REAL*8 err
C     Maximal, initial and effective  physical time 
      REAL*8 tmax, t0, t
C     Global and maximal allowable time step
      REAL*8 dt, ddtmax
C     Residual tolerance for the non-linear iteration
      REAL*8 resf
C     Flow characteristic quantities
      REAL*8 rhoref, pref, lref, vref
C     Free stream Mach number
      REAL*8 xmach
C     Free stream quantities used to define the free stream 
C     physical states
      REAL*8 roin, uxin, uyin, uzin, pin
      REAL*8 roout, uxout, uyout, uzout, pout
C     Free stream physical states
      REAL*8 ub2(5, nfcmax), ub3(5, nfcmax)
C     Real gaz physical quantities
      REAL*8 gam, gam1
C     Reynolds and Prandtl numbers, viscosisty and temperature 
C     on the body
      REAL*8 rey, pr, xmu, tbrd
C
      INTEGER oneshot
      COMMON /ressimul/ oneshot
C
C     Nombre d'iterations de jacobi pour resoudre l'etat et l'etat-adjoint
C     en one-shot
      INTEGER nbrelos
C
      COMMON /icmflg/ ncont, iloc, ivis, idefor, ipred
      COMMON /icmflx/ iflux
      COMMON /icmgrd/ imcas
      COMMON /icmimp/ nexp, nbrel, nit, irlax, istok, nbrelos, nbrelpi
      COMMON /icmord/ nordre
C
C     Nombre d'iterations maximales pour l'etat en one-shot
      INTEGER ktmaxos
      COMMON /icmstp/ ktmax, kt0, kt, ktmaxos
C
C     Residu a atteindre pour resoudre l'etat-adjoint
      REAL*8 errjacpi
C
      COMMON /rcmstp/ tmax, t0, t, resf
      COMMON /rcmdtg/ dt, ddtmax
      COMMON /rcmimp/ err, errjacpi
      COMMON /comcfl/ cfl, xcfl, ycfl, zcfl, cflmax
      COMMON /comref/ rhoref, pref, lref, vref
      COMMON /frsmch/ xmach
      COMMON /frstr1/ roin, uxin, uyin, uzin, pin, roout, uxout, uyout, 
     +uzout, pout
      COMMON /frstr2/ ub2, ub3
      COMMON /comgam/ gam, gam1
      COMMON /comvis/ rey, pr, xmu, tbrd
C
C     -----------------------------------------------------------------
C     Frequency parameters used when printing and saving the physical 
C     solution
      INTEGER ifre, ifre1, impre, ifrel
C
      COMMON /icmedt/ ifre, ifre1, impre, ifrel
C
C     -----------------------------------------------------------------
C     Selected problem identifier
      INTEGER coefm1
C     Variables related to the piston engine geometry
      REAL*8 cadmax, cads
      REAL*8 thet0, ca, squish, rps, stroke, conrod
      REAL*8 wpist, wspa, wspe
      REAL*8 vpist(3), vspa(3), vspe(3)
      REAL*8 aoa, aoe, rfa, rfe, lma, lme
      REAL*8 hpist, hspa, hspe, hplan, href
C
      COMMON /icmpst/ coefm1
C
      COMMON /cmpst0/ cadmax, cads
      COMMON /cmpst1/ thet0, ca, squish, rps, stroke, conrod
      COMMON /cmpst2/ wpist, wspa, wspe, vpist, vspa, vspe
      COMMON /cmpst3/ aoa, aoe, rfa, rfe, lma, lme
      COMMON /cmpst4/ hpist, hspa, hspe, hplan, href
C
C     -----------------------------------------------------------------
C     Parameters and data structures related to the implicit time 
C     integration scheme
      INTEGER nsegs
      PARAMETER (nsegs=50*nsgmax)
C     Storage of the diagonal blocks
      REAL*8 diag(nsmax, 5, 5), adh1(nsmax)
C     Storage of the extra diagonal blocks
      REAL*8 stmat(nsegs)
C     Stockage des termes extra-diagonaux de la matrice
      REAL*8 zm(5, 5, 2, nsgmax)
C
      COMMON /comimp/ diag, stmat, adh1, zm
C 
C     -----------------------------------------------------------------
C     Auxiliary variables used when computing the convective fluxes
      INTEGER ient, icoef
      REAL*8 epsiim, epsiex
C
      COMMON /icmfx1/ ient, icoef
      COMMON /rcmfx1/ epsiim, epsiex
C
C     -----------------------------------------------------------------
C     Auxiliary  variables related to the moving mesh feature
C     Maximum and effective number of relaxations in the 
C     moving mesh phase
      INTEGER maxjac, kjac
C     Residual tolerance and effective residual for the linear 
C     iteration in the moving mesh phase phase
      REAL*8 rsjacf, rsjac
C     Elastic center coordinates
      REAL*8 xce, yce, zce
C     Instantaneous angle of attack
      REAL*8 tetat
C     Original coordinates of the mesh vertices
      REAL*8 xt0(nsmax), yt0(nsmax), zt0(nsmax)
C     Displacements of the mesh vertices
      REAL*8 deltx(2, nsmax), delty(2, nsmax), deltz(2, nsmax)
C     Predicted displacements of the mesh vertices
      REAL*8 deltxp(nsmax), deltyp(nsmax), deltzp(nsmax)
C
      COMMON /imomsh/ maxjac, kjac
      COMMON /mvmsh0/ rsjacf, rsjac
      COMMON /mvmsh1/ xce, yce, zce, tetat
      COMMON /mvmsh2/ xt0, yt0, zt0
      COMMON /mvmsh3/ deltx, delty, deltz, deltxp, deltyp, deltzp
C
      REAL*8 som1, dro1, som, dro
      COMMON /residus/ som1, dro1, som, dro
C
      REAL*8 omega
      COMMON /newton/ omega
C
      INTEGER diric, bound
      COMMON /boundaries/ diric, bound
C
C     NODE3D2D :Tab. de correspondance entre maillage et coque sur les noeuds
C     FACE3D2D :  "            "         "      "          "           faces
C
      INTEGER node3d2d(nsmax), face3d2d(nfcmax)
      COMMON /corres3d2d/ node3d2d, face3d2d
C
      REAL*8 pdesp(nsmax), djdw(5, nsmax), piadj(5, nsmax)
      COMMON /pression/ pdesp
      COMMON /opti/ djdw, piadj
C
      INTEGER validpsi, newton, testder, testadj, testgrad, testderw
      COMMON /verif/ validpsi, newton, testder, testadj, testgrad, 
     +testderw
C
      INTEGER itmax, itopt, ncf, npres, ncontopt, contr, defortuy
      COMMON /optimis/ itmax, itopt, ncf, npres, ncontopt, contr, 
     +defortuy
C
      INTEGER niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
      COMMON /hiera/ niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
C
      REAL*8 erreur, roopt, roinit, roos
      COMMON /resopti/ erreur, roopt, roinit, roos
C
      REAL*8 coeftrainee, teta, cltarget, cdinit, cdtarget, tetacdcl
      REAL*8 coefpres
      REAL*8 tetaxy, tetaxz, tetazy
      INTEGER*4 igicc
      COMMON /iangles/ igicc
      COMMON /calctrainchoc/ coeftrainee, cltarget, cdinit, cdtarget
      COMMON /anglesincid/ teta, tetacdcl, coefpres, tetaxy, tetaxz, 
     +tetazy
C
C     ZZ PARAMETERS:
C     ===============
C
      INTEGER intzz(30)
      COMMON /integerzz/ intzz
C     CPU time evaluation (all real*4)
      REAL*8 pmnew, pmold
      COMMON /mxmi/ pmnew, pmold
C
      INTEGER is, i
      COMMON /rsol1_b/ uab, ceb, dxb, dyb, dzb
      DO is=1,ns
        IF (logfr(is) .EQ. 1 .OR. logfr(is) .EQ. 5) THEN
          DO i=5,1,-1
            ceb(i, is) = 0.D0
          ENDDO
        END IF
      ENDDO
      END

C  Differentiation of fluroe in reverse (adjoint) mode:
C   gradient     of useful results: ua ce
C   with respect to varying inputs: ua ce dx dy dz
      SUBROUTINE FLUROE_B()
      IMPLICIT NONE
C     -----------------------------------------------------------------
C     Degres de liberte
      INTEGER nequation
      PARAMETER (nequation=5)
C
C     Maximum number of vertices 
      INTEGER nsmax
      PARAMETER (nsmax=12966)
C     Maximum number of tetraedra
      INTEGER ntmax
      PARAMETER (ntmax=65421)
C     Maximum number of boundary faces
      INTEGER nfcmax
      PARAMETER (nfcmax=7350)
C     Maximum number of edges 
      INTEGER nsgmax
      PARAMETER (nsgmax=82056)
C     Maximum number of edges attached to a mesh vertex
      INTEGER ndmax
      PARAMETER (ndmax=150)
C     Maximum number of tetraedra attached to a mesh vertex
      INTEGER nvmax
      PARAMETER (nvmax=49)
C     Allowable values for boundary vertices logical reference
      INTEGER klogmin, klogmax
      PARAMETER (klogmin=1, klogmax=30)
C     Maximum numbers of colors for the tetraedra and edges 
      INTEGER nctmax, ncamax
      PARAMETER (nctmax=710, ncamax=710)
C     Characteristic length for vectorisation
      INTEGER lvect
      PARAMETER (lvect=128)
C     Maximum length of arrays for vector operations
      INTEGER lvmax
      PARAMETER (lvmax=128)
C     -----------------------------------------------------------------
C     Maximum number of timers
      INTEGER icpmax
      PARAMETER (icpmax=21)
C     Timers definition
      REAL*8 time(icpmax)
C     Mflop rates
      REAL*8 flop(icpmax)
C
      COMMON /rtimrs/ time, flop
C
C     -----------------------------------------------------------------
C     Effective numbers of tetraedra and edges colors 
      INTEGER nca, nct
C     Data structures for the tetraedra and edges colors
      INTEGER icolt(0:nctmax), icola(0:ncamax)
      INTEGER mark(nsgmax)
C
      COMMON /icolor/ nca, nct, icolt, icola, mark
C
C     -----------------------------------------------------------------
C     Effective numbers of vertices, tetraedra, edges and 
C     boundary faces
      INTEGER ns, nt, nseg, nfac
C     Tetraedra connectivity table
      INTEGER nu(4, ntmax)
C     Boundary faces connectivity table
      INTEGER nsfac(3, nfcmax)
C     Boundary faces logical reference table
      INTEGER logfac(nfcmax), log1fac(nfcmax)
C     Boundary vertices logical reference table
      INTEGER logfr(nsmax)
C     Auxiliary table for boundary vertices logical reference 
      INTEGER fv(nsmax)
C     Boundary faces index table
      INTEGER noe1(nfcmax)
C     Effective numbers of faces for each allowable value of
C     boundary face logical reference
      INTEGER nblog(klogmin:klogmax)
C     Edges connectivity table
      INTEGER nubo(2, nsgmax)
C     Effective number of edges attached to a mesh vertex
      INTEGER ndeg(nsmax), inew(nsmax)
C     Identification of the set of edges attached to 
C     a mesh vertex
      INTEGER jaret(nsmax, ndmax)
C     Effective number of tetraedra attached to a mesh vertex
      INTEGER nbvoi(nsmax)
C     Identification of the set of tetraedra attached to 
C     a mesh vertex
      INTEGER ivoi(nsmax, nvmax)
C     Identification of the upstream and downstream tetraedra 
C     associated to an edge
      INTEGER jta(2, nsgmax)
C     Effective number of faces with a given boundary logical 
C     reference 
      INTEGER nf1, nf2, nf3, nf11
C   
      COMMON /igeom0/ ns, nt, nseg, nfac
      COMMON /igeom1/ nu, nsfac, logfac, nubo, logfr, log1fac
      COMMON /igeom2/ noe1, nblog, fv
      COMMON /igeom3/ nf1, nf2, nf3, nf11
      COMMON /igeom4/ ndeg, inew, jaret, nbvoi, ivoi, jta
C
C     Initial and instantaneous coordinates of the mesh vertices
      REAL*8 coor(3, nsmax), coco(3, nsmax)
C     Initial mesh coordinates (zz)
      REAL*8 coin(3, nsmax)
C     Control volume and tetraedra volumes
      REAL*8 vols(nsmax), volt(ntmax)
C     Control volume boundary normal components
      REAL*8 vnocl(3, nsgmax)
C     Boundary faces normal components
      REAL*8 vnfac(3, nfcmax)
C     Mean values of the normal to tetradra faces
      REAL*8 tvno(ntmax, 4, 3)
C 
      COMMON /rgeom1/ coor, coco, coin
      COMMON /rgeom2/ vols, volt, vnocl, vnfac
      COMMON /rgeom3/ tvno
C
C     -----------------------------------------------------------------
C     Physical solution
      REAL*8 ua(5, nsmax), un(5, nsmax)
      REAL*8 uab(5, nsmax), unb(5, nsmax)
C     Nodal fluxes (gathered convective and diffusive fluxes)
      REAL*8 ce(5, nsmax)
      REAL*8 ceb(5, nsmax)
C     Nodal gradients
      REAL*8 dx(5, nsmax), dy(5, nsmax), dz(5, nsmax)
      REAL*8 dxb(5, nsmax), dyb(5, nsmax), dzb(5, nsmax)
C     Local time steps
      REAL*8 dtl(nsmax)
C     Mesh vertices velocities
      REAL*8 xw1(nsmax), xw2(nsmax), xw3(nsmax)
C     Mean value of mesh edges and boundary faces velocities
      REAL*8 sigma(nsgmax), vnsig(nfcmax)
C     Auxiliary array used during mesh vertices based operations
      REAL*8 ce1(nsmax)
C
      COMMON /rsol1/ ua, un, ce, dx, dy, dz
      COMMON /rsol2/ dtl
      COMMON /rsol3/ xw1, xw2, xw3
      COMMON /rsol4/ sigma, vnsig
      COMMON /rsol5/ ce1
C
C     -----------------------------------------------------------------
C     Reinitialisation flag 
      INTEGER ncont
C     Local time-step strategy flag
      INTEGER iloc
C     Courant number law parameters
      REAL*8 cfl, xcfl, ycfl, zcfl, cflmax
C     Convective flux solver identifier
      INTEGER iflux
C     Spatial approximation precision order
      INTEGER nordre
C     Predictor-corrector time integration scheme flag
      INTEGER ipred
C     Maximum, initial and effective number of time steps
      INTEGER ktmax, kt0, kt
C     Flag for a viscous computation
      INTEGER ivis
C     Flag for a moving mesh computation
      INTEGER idefor
C     Flag used when deforming the mesh
      INTEGER imcas
C     Flag for explicit/implicit time integration 
C     Maximum and effective number of relaxations in the 
C     implicit phase
C     Relaxations pour l'etat-adjoint
      INTEGER nexp, nbrel, nit, nbrelpi
C     Linear system solver identifier
      INTEGER irlax
C     Flag for the type of storage used for the extra-diagonal 
C     blocks 
      INTEGER istok
C     Residual tolerance for the linear iteration (implicit phase)
      REAL*8 err
C     Maximal, initial and effective  physical time 
      REAL*8 tmax, t0, t
C     Global and maximal allowable time step
      REAL*8 dt, ddtmax
C     Residual tolerance for the non-linear iteration
      REAL*8 resf
C     Flow characteristic quantities
      REAL*8 rhoref, pref, lref, vref
C     Free stream Mach number
      REAL*8 xmach
C     Free stream quantities used to define the free stream 
C     physical states
      REAL*8 roin, uxin, uyin, uzin, pin
      REAL*8 roout, uxout, uyout, uzout, pout
C     Free stream physical states
      REAL*8 ub2(5, nfcmax), ub3(5, nfcmax)
C     Real gaz physical quantities
      REAL*8 gam, gam1
C     Reynolds and Prandtl numbers, viscosisty and temperature 
C     on the body
      REAL*8 rey, pr, xmu, tbrd
C
      INTEGER oneshot
      COMMON /ressimul/ oneshot
C
C     Nombre d'iterations de jacobi pour resoudre l'etat et l'etat-adjoint
C     en one-shot
      INTEGER nbrelos
C
      COMMON /icmflg/ ncont, iloc, ivis, idefor, ipred
      COMMON /icmflx/ iflux
      COMMON /icmgrd/ imcas
      COMMON /icmimp/ nexp, nbrel, nit, irlax, istok, nbrelos, nbrelpi
      COMMON /icmord/ nordre
C
C     Nombre d'iterations maximales pour l'etat en one-shot
      INTEGER ktmaxos
      COMMON /icmstp/ ktmax, kt0, kt, ktmaxos
C
C     Residu a atteindre pour resoudre l'etat-adjoint
      REAL*8 errjacpi
C
      COMMON /rcmstp/ tmax, t0, t, resf
      COMMON /rcmdtg/ dt, ddtmax
      COMMON /rcmimp/ err, errjacpi
      COMMON /comcfl/ cfl, xcfl, ycfl, zcfl, cflmax
      COMMON /comref/ rhoref, pref, lref, vref
      COMMON /frsmch/ xmach
      COMMON /frstr1/ roin, uxin, uyin, uzin, pin, roout, uxout, uyout, 
     +uzout, pout
      COMMON /frstr2/ ub2, ub3
      COMMON /comgam/ gam, gam1
      COMMON /comvis/ rey, pr, xmu, tbrd
C
C     -----------------------------------------------------------------
C     Frequency parameters used when printing and saving the physical 
C     solution
      INTEGER ifre, ifre1, impre, ifrel
C
      COMMON /icmedt/ ifre, ifre1, impre, ifrel
C
C     -----------------------------------------------------------------
C     Selected problem identifier
      INTEGER coefm1
C     Variables related to the piston engine geometry
      REAL*8 cadmax, cads
      REAL*8 thet0, ca, squish, rps, stroke, conrod
      REAL*8 wpist, wspa, wspe
      REAL*8 vpist(3), vspa(3), vspe(3)
      REAL*8 aoa, aoe, rfa, rfe, lma, lme
      REAL*8 hpist, hspa, hspe, hplan, href
C
      COMMON /icmpst/ coefm1
C
      COMMON /cmpst0/ cadmax, cads
      COMMON /cmpst1/ thet0, ca, squish, rps, stroke, conrod
      COMMON /cmpst2/ wpist, wspa, wspe, vpist, vspa, vspe
      COMMON /cmpst3/ aoa, aoe, rfa, rfe, lma, lme
      COMMON /cmpst4/ hpist, hspa, hspe, hplan, href
C
C     -----------------------------------------------------------------
C     Parameters and data structures related to the implicit time 
C     integration scheme
      INTEGER nsegs
      PARAMETER (nsegs=50*nsgmax)
C     Storage of the diagonal blocks
      REAL*8 diag(nsmax, 5, 5), adh1(nsmax)
C     Storage of the extra diagonal blocks
      REAL*8 stmat(nsegs)
C     Stockage des termes extra-diagonaux de la matrice
      REAL*8 zm(5, 5, 2, nsgmax)
C
      COMMON /comimp/ diag, stmat, adh1, zm
C 
C     -----------------------------------------------------------------
C     Auxiliary variables used when computing the convective fluxes
      INTEGER ient, icoef
      REAL*8 epsiim, epsiex
C
      COMMON /icmfx1/ ient, icoef
      COMMON /rcmfx1/ epsiim, epsiex
C
C     -----------------------------------------------------------------
C     Auxiliary  variables related to the moving mesh feature
C     Maximum and effective number of relaxations in the 
C     moving mesh phase
      INTEGER maxjac, kjac
C     Residual tolerance and effective residual for the linear 
C     iteration in the moving mesh phase phase
      REAL*8 rsjacf, rsjac
C     Elastic center coordinates
      REAL*8 xce, yce, zce
C     Instantaneous angle of attack
      REAL*8 tetat
C     Original coordinates of the mesh vertices
      REAL*8 xt0(nsmax), yt0(nsmax), zt0(nsmax)
C     Displacements of the mesh vertices
      REAL*8 deltx(2, nsmax), delty(2, nsmax), deltz(2, nsmax)
C     Predicted displacements of the mesh vertices
      REAL*8 deltxp(nsmax), deltyp(nsmax), deltzp(nsmax)
C
      COMMON /imomsh/ maxjac, kjac
      COMMON /mvmsh0/ rsjacf, rsjac
      COMMON /mvmsh1/ xce, yce, zce, tetat
      COMMON /mvmsh2/ xt0, yt0, zt0
      COMMON /mvmsh3/ deltx, delty, deltz, deltxp, deltyp, deltzp
C
      REAL*8 som1, dro1, som, dro
      COMMON /residus/ som1, dro1, som, dro
C
      REAL*8 omega
      COMMON /newton/ omega
C
      INTEGER diric, bound
      COMMON /boundaries/ diric, bound
C
C     NODE3D2D :Tab. de correspondance entre maillage et coque sur les noeuds
C     FACE3D2D :  "            "         "      "          "           faces
C
      INTEGER node3d2d(nsmax), face3d2d(nfcmax)
      COMMON /corres3d2d/ node3d2d, face3d2d
C
      REAL*8 pdesp(nsmax), djdw(5, nsmax), piadj(5, nsmax)
      COMMON /pression/ pdesp
      COMMON /opti/ djdw, piadj
C
      INTEGER validpsi, newton, testder, testadj, testgrad, testderw
      COMMON /verif/ validpsi, newton, testder, testadj, testgrad, 
     +testderw
C
      INTEGER itmax, itopt, ncf, npres, ncontopt, contr, defortuy
      COMMON /optimis/ itmax, itopt, ncf, npres, ncontopt, contr, 
     +defortuy
C
      INTEGER niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
      COMMON /hiera/ niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
C
      REAL*8 erreur, roopt, roinit, roos
      COMMON /resopti/ erreur, roopt, roinit, roos
C
      REAL*8 coeftrainee, teta, cltarget, cdinit, cdtarget, tetacdcl
      REAL*8 coefpres
      REAL*8 tetaxy, tetaxz, tetazy
      INTEGER*4 igicc
      COMMON /iangles/ igicc
      COMMON /calctrainchoc/ coeftrainee, cltarget, cdinit, cdtarget
      COMMON /anglesincid/ teta, tetacdcl, coefpres, tetaxy, tetaxz, 
     +tetazy
C
C     ZZ PARAMETERS:
C     ===============
C
      INTEGER intzz(30)
      COMMON /integerzz/ intzz
C     CPU time evaluation (all real*4)
      REAL*8 pmnew, pmold
      COMMON /mxmi/ pmnew, pmold
C---------------------------------------------------------------------   
C     Local variables definition
      INTEGER is, iseg, nubo1, nubo2
      REAL*8 gamo, usg0, pow, coeff, dtpred
      REAL*8 ro, usro, u, v, w, p, rnorm
      REAL*8 rob, usrob, ub, vb, wb, pb
      REAL*8 aix, aiy, aiz, delta, switch
      REAL*8 deltab
      REAL*8 squsr1, squsr2
      REAL*8 squsr1b, squsr2b
      REAL*8 beta2, beta3, beta
      REAL*8 dpm, dpor, dpex, aux1, aux2, e2
      REAL*8 dpmb, dporb, dpexb
      REAL*8 xsigm, vp1, vp4, vp5
      REAL*8 vp1b, vp4b, vp5b
      REAL*8 uas1(2), uas2(2), uas3(2), uas4(2), uas5(2)
      REAL*8 uas1b(2), uas2b(2), uas3b(2), uas4b(2), uas5b(2)
      REAL*8 vno(3)
      REAL*8 prod1, prod2, bsign
      REAL*8 prod1b, prod2b
      REAL*8 tet1, tet2, tet3
      REAL*8 tet1b, tet2b, tet3b
      REAL*8 cr, cr2, ener1, ener2, pror, qir
      REAL*8 crb, cr2b, ener1b, ener2b, prorb, qirb
      REAL*8 uar1, uar2, uar3, uar4, uar5
      REAL*8 uar2b, uar3b, uar4b, uar5b
      REAL*8 dif1, dif2, dif3, dif4, dif5
      REAL*8 dif1b, dif2b, dif3b, dif4b, dif5b
      REAL*8 flur1, flur2, flur3, flur4, flur5
      REAL*8 flur1b, flur2b, flur3b, flur4b, flur5b
      REAL*8 fltr1, fltr2, fltr3, fltr4, fltr5
      REAL*8 fltr1b, fltr2b, fltr3b, fltr4b, fltr5b
      REAL*8 flum1, flum2, flum3, flum4, flum5
      REAL*8 flum1b, flum2b, flum3b, flum4b, flum5b
      INTRINSIC SIGN
      INTRINSIC SQRT
      INTRINSIC DABS
      INTRINSIC DSQRT
      INTRINSIC ABS
      DOUBLE PRECISION dabs0
      DOUBLE PRECISION dabs0b
      REAL*8 abs0
      REAL*8 abs0b
      REAL*8 abs1
      REAL*8 abs1b
      REAL*8 abs2
      REAL*8 abs2b
      REAL*8 abs3
      REAL*8 abs3b
      REAL*8 abs4
      REAL*8 abs4b
      REAL*8 tempb
      REAL*8 tempb0
      REAL*8 tempb1
      REAL*8 tempb2
      REAL*8 tempb3
      REAL*8 tempb4
      REAL*8 tempb5
      REAL*8 tempb6
      REAL*8 tempb7
      REAL*8 tempb8
      REAL*8 tempb9
      REAL*8 tempb10
      REAL*8 tempb11
      REAL*8 tempb12
      REAL*8 tempb13
      REAL*8 tempb14
      REAL*8 tempb15
      REAL*8 tempb16
      REAL*8 tempb17
      REAL*8 temp
      REAL*8 temp0
      REAL*8 temp1
      REAL*8 temp2
      REAL*8 temp3
      REAL*8 temp4
      REAL*8 temp5
      REAL*8 temp6
      REAL*8 temp7
      REAL*8 temp8
      REAL*8 tempb18
      REAL*8 tempb19
      REAL*8 tempb20
      REAL*8 tempb21
      REAL*8 tempb22
      REAL*8 tempb23
      REAL*8 tempb24
      REAL*8 tempb25
      REAL*8 tempb26
      REAL*8 tempb27
      REAL*8 tempb28
      REAL*8 tempb29
      REAL*8 tempb30
      REAL*8 tempb31
      REAL*8 tempb32
      REAL*8 tempb33
      REAL*8 tempb34
      REAL*8 tempb35
      REAL*8 tempb36
      REAL*8 tempb37
      REAL*8 temp9
      REAL*8 temp10
      REAL*8 tempb38
      REAL*8 tempb39
      REAL*8 tempb40
      REAL*8 tempb41
      REAL*8 tempb42
      REAL*8 tempb43
      REAL*8 tempb44
      REAL*8 tempb45
      REAL*8 tempb46
      REAL*8 tempb47
      REAL*8 tempb48
      REAL*8 tempb49
      REAL*8 tempb50
      REAL*8 temp11
      REAL*8 temp12
      REAL*8 temp13
      REAL*8 temp14
      REAL*8 tempb51
      REAL*8 tempb52
      REAL*8 tempb53
      REAL*8 tempb54
      REAL*8 tempb55
      REAL*8 temp15
      REAL*8 temp16
      REAL*8 temp17
      REAL*8 temp18
      REAL*8 tempb56
      REAL*8 tempb57
      REAL*8 tempb58
      REAL*8 tempb59
      REAL*8 tempb60
      REAL*8 temp19
      REAL*8 temp20
      REAL*8 temp21
      REAL*8 temp22
      REAL*8 tempb61
      REAL*8 tempb62
      REAL*8 tempb63
      REAL*8 tempb64
      REAL*8 tempb65
      REAL*8 temp23
      REAL*8 temp24
      REAL*8 temp25
      REAL*8 temp26
      REAL*8 tempb66
      REAL*8 tempb67
      REAL*8 temp27
      REAL*8 temp28
      REAL*8 temp29
      REAL*8 temp30
      REAL*8 tempb68
      REAL*8 tempb69
      REAL*8 tempb70
      REAL*8 tempb71
      REAL*8 tempb72
      REAL*8 tempb73
      REAL*8 tempb74
      REAL*8 tempb75
      REAL*8 tempb76
      REAL*8 tempb77
      REAL*8 tempb78
      REAL*8 tempb79
      REAL*8 tempb80
      REAL*8 tempb81
      REAL*8 tempb82
      REAL*8 tempb83
      INTEGER branch
      INTEGER ii1
      INTEGER ii2
      COMMON /rsol1_b/ uab, ceb, dxb, dyb, dzb
C
      bsign = 1.0d0
C
      IF (nordre .EQ. 2) bsign = -1.0d0
C
      beta = 0.5d0
C
      beta2 = beta
      beta3 = 0.5d0*(1.0d0-2.0d0*beta)
C
      e2 = 1.0d-16
C
C
      DO is=1,ns
C
        dtpred = 0.5d0*dtl(is)*ipred
C
        ro = ua(1, is)
        usro = 1.0d0/ro
        u = ua(2, is)*usro
        v = ua(3, is)*usro
        w = ua(4, is)*usro
        p = gam1*(ua(5, is)-0.5d0*ro*(u*u+v*v+w*w))
C
        un(1, is) = ro - dtpred*(u*dx(1, is)+v*dy(1, is)+w*dz(1, is)+ro*
     +    (dx(2, is)+dy(3, is)+dz(4, is)))
        un(2, is) = u - dtpred*(u*dx(2, is)+v*dy(2, is)+w*dz(2, is)+dx(5
     +    , is)*usro)
        un(3, is) = v - dtpred*(u*dx(3, is)+v*dy(3, is)+w*dz(3, is)+dy(5
     +    , is)*usro)
        un(4, is) = w - dtpred*(u*dx(4, is)+v*dy(4, is)+w*dz(4, is)+dz(5
     +    , is)*usro)
        un(5, is) = p - dtpred*(u*dx(5, is)+v*dy(5, is)+w*dz(5, is)+gam*
     +    p*(dx(2, is)+dy(3, is)+dz(4, is)))
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,5
          unb(ii2, ii1) = 0.0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,5
          dxb(ii2, ii1) = 0.0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,5
          dyb(ii2, ii1) = 0.0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,5
          dzb(ii2, ii1) = 0.0
        ENDDO
      ENDDO
      DO ii1=1,2
        uas1b(ii1) = 0.0
      ENDDO
      DO ii1=1,2
        uas2b(ii1) = 0.0
      ENDDO
      DO ii1=1,2
        uas3b(ii1) = 0.0
      ENDDO
      DO ii1=1,2
        uas4b(ii1) = 0.0
      ENDDO
      DO ii1=1,2
        uas5b(ii1) = 0.0
      ENDDO
      DO iseg=1,nseg
C
        nubo1 = nubo(1, iseg)
        nubo2 = nubo(2, iseg)
C
C        Indirect addressing on vertices physical states
C
        uas1(1) = un(1, nubo1)
        uas1(2) = un(1, nubo2)
        uas2(1) = un(2, nubo1)
        uas2(2) = un(2, nubo2)
        uas3(1) = un(3, nubo1)
        uas3(2) = un(3, nubo2)
        uas4(1) = un(4, nubo1)
        uas4(2) = un(4, nubo2)
        uas5(1) = un(5, nubo1)
        uas5(2) = un(5, nubo2)
C
        flur1 = 0.0d0
        flur2 = 0.0d0
        flur3 = 0.0d0
        flur4 = 0.0d0
        flur5 = 0.0d0
C         
        fltr1 = 0.0d0
        fltr2 = 0.0d0
        fltr3 = 0.0d0
        fltr4 = 0.0d0
        fltr5 = 0.0d0
C
        IF (nordre .EQ. 1) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
C
          aix = coor(1, nubo2) - coor(1, nubo1)
          aiy = coor(2, nubo2) - coor(2, nubo1)
          aiz = coor(3, nubo2) - coor(3, nubo1)
C
          flur1 = beta2*(aix*dx(1, nubo1)+aiy*dy(1, nubo1)+aiz*dz(1, 
     +      nubo1)) + beta3*(uas1(2)-uas1(1))
          flur2 = beta2*(aix*dx(2, nubo1)+aiy*dy(2, nubo1)+aiz*dz(2, 
     +      nubo1)) + beta3*(uas2(2)-uas2(1))
          flur3 = beta2*(aix*dx(3, nubo1)+aiy*dy(3, nubo1)+aiz*dz(3, 
     +      nubo1)) + beta3*(uas3(2)-uas3(1))
          flur4 = beta2*(aix*dx(4, nubo1)+aiy*dy(4, nubo1)+aiz*dz(4, 
     +      nubo1)) + beta3*(uas4(2)-uas4(1))
          flur5 = beta2*(aix*dx(5, nubo1)+aiy*dy(5, nubo1)+aiz*dz(5, 
     +      nubo1)) + beta3*(uas5(2)-uas5(1))
C
          fltr1 = beta2*(aix*dx(1, nubo2)+aiy*dy(1, nubo2)+aiz*dz(1, 
     +      nubo2)) + beta3*(uas1(2)-uas1(1))
          fltr2 = beta2*(aix*dx(2, nubo2)+aiy*dy(2, nubo2)+aiz*dz(2, 
     +      nubo2)) + beta3*(uas2(2)-uas2(1))
          fltr3 = beta2*(aix*dx(3, nubo2)+aiy*dy(3, nubo2)+aiz*dz(3, 
     +      nubo2)) + beta3*(uas3(2)-uas3(1))
          fltr4 = beta2*(aix*dx(4, nubo2)+aiy*dy(4, nubo2)+aiz*dz(4, 
     +      nubo2)) + beta3*(uas4(2)-uas4(1))
          fltr5 = beta2*(aix*dx(5, nubo2)+aiy*dy(5, nubo2)+aiz*dz(5, 
     +      nubo2)) + beta3*(uas5(2)-uas5(1))
C
          IF (nordre .EQ. 3 .OR. nordre .EQ. 4) THEN
            CALL PUSHCONTROL2B(1)
          ELSE
C
C        Auxiliary Values for the Van Albada Procedure
C
            dpm = -(uas1(2)-uas1(1))
            dpex = -(4.0d0*flur1) - dpm
            aux1 = 0.25*(1.0d0+SIGN(1.0d0, dpex*dpm))
            dpor = -(4.0d0*fltr1) - dpm
            aux2 = 0.25*(1.0d0+SIGN(1.0d0, dpor*dpm))
C
            flur1 = aux1*((dpex*dpex+e2)*dpm+(dpm*dpm+e2)*dpex)/(dpex*
     +        dpex+dpm*dpm+2.0d0*e2)
            fltr1 = aux2*((dpor*dpor+e2)*dpm+(dpm*dpm+e2)*dpor)/(dpor*
     +        dpor+dpm*dpm+2.0d0*e2)
C
            CALL PUSHREAL8(dpm)
            dpm = -(uas2(2)-uas2(1))
            CALL PUSHREAL8(dpex)
            dpex = -(4.0d0*flur2) - dpm
            CALL PUSHREAL8(aux1)
            aux1 = 0.25*(1.0d0+SIGN(1.0d0, dpex*dpm))
            CALL PUSHREAL8(dpor)
            dpor = -(4.0d0*fltr2) - dpm
            CALL PUSHREAL8(aux2)
            aux2 = 0.25*(1.0d0+SIGN(1.0d0, dpor*dpm))
C
            flur2 = aux1*((dpex*dpex+e2)*dpm+(dpm*dpm+e2)*dpex)/(dpex*
     +        dpex+dpm*dpm+2.0d0*e2)
            fltr2 = aux2*((dpor*dpor+e2)*dpm+(dpm*dpm+e2)*dpor)/(dpor*
     +        dpor+dpm*dpm+2.0d0*e2)
C
            CALL PUSHREAL8(dpm)
            dpm = -(uas3(2)-uas3(1))
            CALL PUSHREAL8(dpex)
            dpex = -(4.0d0*flur3) - dpm
            CALL PUSHREAL8(aux1)
            aux1 = 0.25*(1.0d0+SIGN(1.0d0, dpex*dpm))
            CALL PUSHREAL8(dpor)
            dpor = -(4.0d0*fltr3) - dpm
            CALL PUSHREAL8(aux2)
            aux2 = 0.25*(1.0d0+SIGN(1.0d0, dpor*dpm))
C
            flur3 = aux1*((dpex*dpex+e2)*dpm+(dpm*dpm+e2)*dpex)/(dpex*
     +        dpex+dpm*dpm+2.0d0*e2)
            fltr3 = aux2*((dpor*dpor+e2)*dpm+(dpm*dpm+e2)*dpor)/(dpor*
     +        dpor+dpm*dpm+2.0d0*e2)
C
            CALL PUSHREAL8(dpm)
            dpm = -(uas4(2)-uas4(1))
            CALL PUSHREAL8(dpex)
            dpex = -(4.0d0*flur4) - dpm
            CALL PUSHREAL8(aux1)
            aux1 = 0.25*(1.0d0+SIGN(1.0d0, dpex*dpm))
            CALL PUSHREAL8(dpor)
            dpor = -(4.0d0*fltr4) - dpm
            CALL PUSHREAL8(aux2)
            aux2 = 0.25*(1.0d0+SIGN(1.0d0, dpor*dpm))
C      
            flur4 = aux1*((dpex*dpex+e2)*dpm+(dpm*dpm+e2)*dpex)/(dpex*
     +        dpex+dpm*dpm+2.0d0*e2)
            fltr4 = aux2*((dpor*dpor+e2)*dpm+(dpm*dpm+e2)*dpor)/(dpor*
     +        dpor+dpm*dpm+2.0d0*e2)
C
            CALL PUSHREAL8(dpm)
            dpm = -(uas5(2)-uas5(1))
            CALL PUSHREAL8(dpex)
            dpex = -(4.0d0*flur5) - dpm
            CALL PUSHREAL8(aux1)
            aux1 = 0.25*(1.0d0+SIGN(1.0d0, dpex*dpm))
            CALL PUSHREAL8(dpor)
            dpor = -(4.0d0*fltr5) - dpm
            CALL PUSHREAL8(aux2)
            aux2 = 0.25*(1.0d0+SIGN(1.0d0, dpor*dpm))
C
            flur5 = aux1*((dpex*dpex+e2)*dpm+(dpm*dpm+e2)*dpex)/(dpex*
     +        dpex+dpm*dpm+2.0d0*e2)
            fltr5 = aux2*((dpor*dpor+e2)*dpm+(dpm*dpm+e2)*dpor)/(dpor*
     +        dpor+dpm*dpm+2.0d0*e2)
            CALL PUSHCONTROL2B(2)
          END IF
        END IF
C
C
        uas1(1) = uas1(1) + bsign*flur1
        uas2(1) = uas2(1) + bsign*flur2
        uas3(1) = uas3(1) + bsign*flur3
        uas4(1) = uas4(1) + bsign*flur4
        uas5(1) = uas5(1) + bsign*flur5
C
        uas1(2) = uas1(2) - bsign*fltr1
        uas2(2) = uas2(2) - bsign*fltr2
        uas3(2) = uas3(2) - bsign*fltr3
        uas4(2) = uas4(2) - bsign*fltr4
        uas5(2) = uas5(2) - bsign*fltr5
C
        rnorm = 1.0d0/SQRT(vnocl(1, iseg)*vnocl(1, iseg)+vnocl(2, iseg)*
     +    vnocl(2, iseg)+vnocl(3, iseg)*vnocl(3, iseg))
C
        vno(1) = -(vnocl(1, iseg)*rnorm)
        vno(2) = -(vnocl(2, iseg)*rnorm)
        vno(3) = -(vnocl(3, iseg)*rnorm)
C
        xsigm = -(sigma(iseg)*rnorm)
C
        prod1 = uas2(1)*vno(1) + uas3(1)*vno(2) + uas4(1)*vno(3)
C
        ener1 = uas5(1)/gam1 + 0.5d0*uas1(1)*(uas2(1)*uas2(1)+uas3(1)*
     +    uas3(1)+uas4(1)*uas4(1))
C 
        prod2 = uas2(2)*vno(1) + uas3(2)*vno(2) + uas4(2)*vno(3)
C
        ener2 = uas5(2)/gam1 + 0.5d0*uas1(2)*(uas2(2)*uas2(2)+uas3(2)*
     +    uas3(2)+uas4(2)*uas4(2))
C
C
C
C
C
C
        squsr1 = SQRT(uas1(1))
        squsr2 = SQRT(uas1(2))
C
        usro = 1.0d0/(squsr1+squsr2)
C
C
        uar2 = (squsr1*uas2(1)+squsr2*uas2(2))*usro
C
        uar3 = (squsr1*uas3(1)+squsr2*uas3(2))*usro
C
        uar4 = (squsr1*uas4(1)+squsr2*uas4(2))*usro
C
        uar5 = ((ener1+uas5(1))/squsr1+(ener2+uas5(2))/squsr2)*usro
C
        pror = vno(1)*uar2 + vno(2)*uar3 + vno(3)*uar4
C
        qir = 0.5d0*(uar2*uar2+uar3*uar3+uar4*uar4)
C
        tet1 = vno(3)*uar3 - vno(2)*uar4
        tet2 = vno(1)*uar4 - vno(3)*uar2
        tet3 = vno(2)*uar2 - vno(1)*uar3
C
        cr2 = gam1*(uar5-qir)
        cr = SQRT(cr2)
        CALL PUSHREAL8(cr2)
        cr2 = 1.0d0/cr2
C
        dif1 = uas1(1) - uas1(2)
        dif2 = uas1(1)*uas2(1) - uas1(2)*uas2(2)
        dif3 = uas1(1)*uas3(1) - uas1(2)*uas3(2)
        dif4 = uas1(1)*uas4(1) - uas1(2)*uas4(2)
        dif5 = ener1 - ener2
C
        vp1 = pror - xsigm
        vp4 = pror + cr - xsigm
        vp5 = pror - cr - xsigm
C
C
        IF (ient .EQ. 1) THEN
          IF (vp4 .GE. 0.) THEN
            dabs0 = vp4
            CALL PUSHCONTROL1B(0)
          ELSE
            dabs0 = -vp4
            CALL PUSHCONTROL1B(1)
          END IF
C
          delta = dabs0/100.d0
C
          CALL PUSHREAL8(vp1)
          vp1 = DSQRT(vp1*vp1 + delta)
          CALL PUSHREAL8(vp4)
          vp4 = DSQRT(vp4*vp4 + delta)
          CALL PUSHREAL8(vp5)
          vp5 = DSQRT(vp5*vp5 + delta)
C
C
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (vp1 .GE. 0.) THEN
          abs0 = vp1
          CALL PUSHCONTROL1B(0)
        ELSE
          abs0 = -vp1
          CALL PUSHCONTROL1B(1)
        END IF
C
        flur1 = abs0*((vno(1)*(1.0d0-gam1*qir*cr2)-tet1)*dif1+vno(1)*
     +    gam1*uar2*cr2*dif2+(vno(3)+vno(1)*gam1*uar3*cr2)*dif3+(-vno(2)
     +    +vno(1)*gam1*uar4*cr2)*dif4-vno(1)*gam1*cr2*dif5)
        IF (vp1 .GE. 0.) THEN
          abs1 = vp1
          CALL PUSHCONTROL1B(0)
        ELSE
          abs1 = -vp1
          CALL PUSHCONTROL1B(1)
        END IF
C
        flur2 = abs1*((vno(2)*(1.0d0-gam1*qir*cr2)-tet2)*dif1+(-vno(3)+
     +    vno(2)*gam1*uar2*cr2)*dif2+vno(2)*gam1*uar3*cr2*dif3+(vno(1)+
     +    vno(2)*gam1*uar4*cr2)*dif4-vno(2)*gam1*cr2*dif5)
        IF (vp1 .GE. 0.) THEN
          abs2 = vp1
          CALL PUSHCONTROL1B(0)
        ELSE
          abs2 = -vp1
          CALL PUSHCONTROL1B(1)
        END IF
C
        flur3 = abs2*((vno(3)*(1.0d0-gam1*qir*cr2)-tet3)*dif1+(vno(2)+
     +    vno(3)*gam1*uar2*cr2)*dif2+(-vno(1)+vno(3)*gam1*uar3*cr2)*dif3
     +    +vno(3)*gam1*uar4*cr2*dif4-vno(3)*gam1*cr2*dif5)
        IF (vp4 .GE. 0.) THEN
          abs3 = vp4
          CALL PUSHCONTROL1B(0)
        ELSE
          abs3 = -vp4
          CALL PUSHCONTROL1B(1)
        END IF
C
        flur4 = abs3*((-(cr*pror)+gam1*qir)*dif1+(cr*vno(1)-gam1*uar2)*
     +    dif2+(cr*vno(2)-gam1*uar3)*dif3+(cr*vno(3)-gam1*uar4)*dif4+
     +    gam1*dif5)
        IF (vp5 .GE. 0.) THEN
          abs4 = vp5
          CALL PUSHCONTROL1B(0)
        ELSE
          abs4 = -vp5
          CALL PUSHCONTROL1B(1)
        END IF
C
        flur5 = abs4*((cr*pror+gam1*qir)*dif1+(-(cr*vno(1))-gam1*uar2)*
     +    dif2+(-(cr*vno(2))-gam1*uar3)*dif3+(-(cr*vno(3))-gam1*uar4)*
     +    dif4+gam1*dif5)
C
C
C
C
C
C
        rnorm = 0.5d0/rnorm
C
C
        flum5b = rnorm*ceb(5, nubo2) - rnorm*ceb(5, nubo1)
        fltr5b = rnorm*ceb(5, nubo2) - rnorm*ceb(5, nubo1)
        flum4b = rnorm*ceb(4, nubo2) - rnorm*ceb(4, nubo1)
        fltr4b = rnorm*ceb(4, nubo2) - rnorm*ceb(4, nubo1)
        flum3b = rnorm*ceb(3, nubo2) - rnorm*ceb(3, nubo1)
        fltr3b = rnorm*ceb(3, nubo2) - rnorm*ceb(3, nubo1)
        flum2b = rnorm*ceb(2, nubo2) - rnorm*ceb(2, nubo1)
        fltr2b = rnorm*ceb(2, nubo2) - rnorm*ceb(2, nubo1)
        flum1b = rnorm*ceb(1, nubo2) - rnorm*ceb(1, nubo1)
        fltr1b = rnorm*ceb(1, nubo2) - rnorm*ceb(1, nubo1)
        tempb68 = 0.5d0*pror*fltr5b/cr
        tempb69 = (flur4-flur5)*0.5d0*fltr5b/cr
        tempb70 = 0.5d0*uar5*cr2*fltr5b
        tempb71 = 0.5d0*(flur4+flur5)*fltr5b
        tet1b = flur1*fltr5b
        flur1b = (vno(1)*uar4-vno(2))*fltr4b + vno(1)*uar2*fltr2b + vno(
     +    1)*fltr1b + (vno(3)+vno(1)*uar3)*fltr3b + (vno(1)*qir+tet1)*
     +    fltr5b
        tet2b = flur2*fltr5b
        flur2b = (vno(1)+vno(2)*uar4)*fltr4b + (vno(2)*uar2-vno(3))*
     +    fltr2b + vno(2)*fltr1b + vno(2)*uar3*fltr3b + (vno(2)*qir+tet2
     +    )*fltr5b
        tet3b = flur3*fltr5b
        flur3b = vno(3)*uar4*fltr4b + (vno(2)+vno(3)*uar2)*fltr2b + vno(
     +    3)*fltr1b + (vno(3)*uar3-vno(1))*fltr3b + (vno(3)*qir+tet3)*
     +    fltr5b
        uar5b = cr2*tempb71
        tempb73 = vno(3)*0.5d0*fltr4b/cr
        tempb74 = 0.5d0*uar4*cr2*fltr4b
        tempb81 = 0.5d0*(flur4+flur5)*fltr4b
        tempb79 = vno(2)*0.5d0*fltr3b/cr
        tempb78 = 0.5d0*uar3*cr2*fltr3b
        tempb83 = 0.5d0*(flur4+flur5)*fltr3b
        tempb75 = vno(1)*0.5d0*fltr2b/cr
        tempb76 = 0.5d0*uar2*cr2*fltr2b
        tempb82 = 0.5d0*(flur4+flur5)*fltr2b
        cr2b = uar4*tempb81 + uar2*tempb82 + 0.5d0*(flur4+flur5)*fltr1b 
     +    + uar3*tempb83 + uar5*tempb71
        tempb77 = 0.5d0*cr2*fltr1b
        flur4b = tempb73 + tempb74 + tempb75 + tempb76 + tempb77 + 
     +    tempb78 + tempb79 + tempb70 + tempb68
        flur5b = tempb74 - tempb73 - tempb75 + tempb76 + tempb77 + 
     +    tempb78 - tempb79 + tempb70 - tempb68
        temp30 = -(vno(3)*cr) - gam1*uar4
        temp29 = -(vno(2)*cr) - gam1*uar3
        temp28 = -(vno(1)*cr) - gam1*uar2
        temp27 = cr*pror + gam1*qir
        tempb80 = abs4*flur5b
        uar4b = cr2*tempb81 - dif4*gam1*tempb80 + (vno(3)*flur3+flur2*
     +    vno(2)+flur1*vno(1))*fltr4b
        uar3b = cr2*tempb83 - dif3*gam1*tempb80 + (flur3*vno(3)+vno(2)*
     +    flur2+flur1*vno(1))*fltr3b
        uar2b = cr2*tempb82 - dif2*gam1*tempb80 + (flur3*vno(3)+flur2*
     +    vno(2)+vno(1)*flur1)*fltr2b
        tempb72 = dif1*tempb80
        qirb = gam1*tempb72 + (flur3*vno(3)+flur2*vno(2)+flur1*vno(1))*
     +    fltr5b
        prorb = cr*tempb72 + tempb69
        crb = (-(dif4*vno(3))-dif3*vno(2)-dif2*vno(1))*tempb80 - (flur4-
     +    flur5)*tempb75/cr - (flur4-flur5)*tempb73/cr + pror*tempb72 - 
     +    (flur4-flur5)*tempb79/cr - pror*tempb69/cr
        abs4b = (temp27*dif1+temp28*dif2+temp29*dif3+temp30*dif4+gam1*
     +    dif5)*flur5b
        dif1b = temp27*tempb80
        dif2b = temp28*tempb80
        dif3b = temp29*tempb80
        dif4b = temp30*tempb80
        dif5b = gam1*tempb80
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          vp5b = abs4b
        ELSE
          vp5b = -abs4b
        END IF
        temp26 = vno(3)*cr - gam1*uar4
        temp25 = vno(2)*cr - gam1*uar3
        temp24 = vno(1)*cr - gam1*uar2
        temp23 = gam1*qir - cr*pror
        tempb66 = abs3*flur4b
        tempb67 = dif1*tempb66
        abs3b = (temp23*dif1+temp24*dif2+temp25*dif3+temp26*dif4+gam1*
     +    dif5)*flur4b
        qirb = qirb + gam1*tempb67
        crb = crb + (dif4*vno(3)+dif3*vno(2)+dif2*vno(1))*tempb66 - pror
     +    *tempb67
        prorb = prorb - cr*tempb67
        dif1b = dif1b + temp23*tempb66
        uar2b = uar2b - dif2*gam1*tempb66
        dif2b = dif2b + temp24*tempb66
        uar3b = uar3b - dif3*gam1*tempb66
        dif3b = dif3b + temp25*tempb66
        uar4b = uar4b - dif4*gam1*tempb66
        dif4b = dif4b + temp26*tempb66
        dif5b = dif5b + gam1*tempb66
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          vp4b = abs3b
        ELSE
          vp4b = -abs3b
        END IF
        temp22 = vno(3)*gam1
        temp21 = vno(3)*gam1*uar3*cr2 - vno(1)
        temp20 = vno(2) + vno(3)*gam1*uar2*cr2
        temp19 = vno(3)*(-(gam1*qir*cr2)+1.0d0) - tet3
        tempb61 = abs2*flur3b
        tempb62 = -(vno(3)*dif1*gam1*tempb61)
        tempb63 = dif2*vno(3)*gam1*tempb61
        tempb64 = dif3*vno(3)*gam1*tempb61
        tempb65 = vno(3)*gam1*tempb61
        abs2b = (temp19*dif1+temp20*dif2+temp21*dif3+vno(3)*gam1*(uar4*
     +    cr2*dif4)-temp22*(cr2*dif5))*flur3b
        qirb = qirb + cr2*tempb62
        cr2b = cr2b + dif4*uar4*tempb65 - temp22*dif5*tempb61 + uar3*
     +    tempb64 + uar2*tempb63 + qir*tempb62
        tet3b = tet3b - dif1*tempb61
        dif1b = dif1b + temp19*tempb61
        uar2b = uar2b + cr2*tempb63
        dif2b = dif2b + temp20*tempb61
        uar3b = uar3b + cr2*tempb64
        dif3b = dif3b + temp21*tempb61
        uar4b = uar4b + dif4*cr2*tempb65
        dif4b = dif4b + uar4*cr2*tempb65
        dif5b = dif5b - temp22*cr2*tempb61
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          vp1b = abs2b
        ELSE
          vp1b = -abs2b
        END IF
        temp18 = vno(2)*gam1
        temp17 = vno(1) + vno(2)*gam1*uar4*cr2
        temp16 = vno(2)*gam1*uar2*cr2 - vno(3)
        temp15 = vno(2)*(-(gam1*qir*cr2)+1.0d0) - tet2
        tempb56 = abs1*flur2b
        tempb57 = -(vno(2)*dif1*gam1*tempb56)
        tempb58 = dif2*vno(2)*gam1*tempb56
        tempb59 = vno(2)*gam1*tempb56
        tempb60 = dif4*vno(2)*gam1*tempb56
        abs1b = (temp15*dif1+temp16*dif2+vno(2)*gam1*(uar3*cr2*dif3)+
     +    temp17*dif4-temp18*(cr2*dif5))*flur2b
        qirb = qirb + cr2*tempb57
        cr2b = cr2b + uar4*tempb60 - temp18*dif5*tempb56 + dif3*uar3*
     +    tempb59 + uar2*tempb58 + qir*tempb57
        tet2b = tet2b - dif1*tempb56
        dif1b = dif1b + temp15*tempb56
        uar2b = uar2b + cr2*tempb58
        dif2b = dif2b + temp16*tempb56
        uar3b = uar3b + dif3*cr2*tempb59
        dif3b = dif3b + uar3*cr2*tempb59
        uar4b = uar4b + cr2*tempb60
        dif4b = dif4b + temp17*tempb56
        dif5b = dif5b - temp18*cr2*tempb56
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          vp1b = vp1b + abs1b
        ELSE
          vp1b = vp1b - abs1b
        END IF
        temp14 = vno(1)*gam1
        temp13 = vno(1)*gam1*uar4*cr2 - vno(2)
        temp12 = vno(3) + vno(1)*gam1*uar3*cr2
        temp11 = vno(1)*(-(gam1*qir*cr2)+1.0d0) - tet1
        tempb51 = abs0*flur1b
        tempb52 = -(vno(1)*dif1*gam1*tempb51)
        tempb53 = vno(1)*gam1*tempb51
        tempb54 = dif3*vno(1)*gam1*tempb51
        tempb55 = dif4*vno(1)*gam1*tempb51
        abs0b = (temp11*dif1+vno(1)*gam1*(uar2*cr2*dif2)+temp12*dif3+
     +    temp13*dif4-temp14*(cr2*dif5))*flur1b
        qirb = qirb + cr2*tempb52
        cr2b = cr2b + uar4*tempb55 - temp14*dif5*tempb51 + uar3*tempb54 
     +    + dif2*uar2*tempb53 + qir*tempb52
        tet1b = tet1b - dif1*tempb51
        dif1b = dif1b + temp11*tempb51
        uar2b = uar2b + dif2*cr2*tempb53
        dif2b = dif2b + uar2*cr2*tempb53
        uar3b = uar3b + cr2*tempb54
        dif3b = dif3b + temp12*tempb51
        uar4b = uar4b + cr2*tempb55
        dif4b = dif4b + temp13*tempb51
        dif5b = dif5b - temp14*cr2*tempb51
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          vp1b = vp1b + abs0b
        ELSE
          vp1b = vp1b - abs0b
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPREAL8(vp5)
          IF (vp5**2 + delta .EQ. 0.0) THEN
            tempb48 = 0.0
          ELSE
            tempb48 = vp5b/(2.D0*DSQRT(vp5**2+delta))
          END IF
          vp5b = 2*vp5*tempb48
          CALL POPREAL8(vp4)
          IF (vp4**2 + delta .EQ. 0.0) THEN
            tempb49 = 0.0
          ELSE
            tempb49 = vp4b/(2.D0*DSQRT(vp4**2+delta))
          END IF
          vp4b = 2*vp4*tempb49
          CALL POPREAL8(vp1)
          IF (vp1**2 + delta .EQ. 0.0) THEN
            tempb50 = 0.0
          ELSE
            tempb50 = vp1b/(2.D0*DSQRT(vp1**2+delta))
          END IF
          deltab = tempb49 + tempb50 + tempb48
          vp1b = 2*vp1*tempb50
          dabs0b = deltab/100.d0
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            vp4b = vp4b + dabs0b
          ELSE
            vp4b = vp4b - dabs0b
          END IF
        END IF
        prorb = prorb + vp4b + vp1b + vp5b
        crb = crb + vp4b - vp5b
        uas1b(1) = uas1b(1) + uas4(1)*dif4b
        uas4b(1) = uas4b(1) + uas1(1)*dif4b
        uas1b(2) = uas1b(2) - uas4(2)*dif4b
        uas4b(2) = uas4b(2) - uas1(2)*dif4b
        uas1b(1) = uas1b(1) + uas3(1)*dif3b
        uas3b(1) = uas3b(1) + uas1(1)*dif3b
        uas1b(2) = uas1b(2) - uas3(2)*dif3b
        uas3b(2) = uas3b(2) - uas1(2)*dif3b
        uas1b(1) = uas1b(1) + uas2(1)*dif2b
        uas2b(1) = uas2b(1) + uas1(1)*dif2b
        uas1b(2) = uas1b(2) - uas2(2)*dif2b
        uas2b(2) = uas2b(2) - uas1(2)*dif2b
        uas1b(1) = uas1b(1) + dif1b
        CALL POPREAL8(cr2)
        IF (cr2 .EQ. 0.0) THEN
          cr2b = -(cr2b/cr2**2)
        ELSE
          cr2b = crb/(2.0*SQRT(cr2)) - cr2b/cr2**2
        END IF
        uar5b = uar5b + gam1*cr2b
        qirb = qirb - gam1*cr2b
        tempb40 = 0.5d0*qirb
        uar2b = uar2b + vno(1)*prorb - vno(3)*tet2b + 2*uar2*tempb40 + 
     +    vno(2)*tet3b
        uar3b = uar3b + vno(3)*tet1b + vno(2)*prorb + 2*uar3*tempb40 - 
     +    vno(1)*tet3b
        uar4b = uar4b + vno(3)*prorb - vno(2)*tet1b + 2*uar4*tempb40 + 
     +    vno(1)*tet2b
        tempb41 = usro*uar5b
        tempb38 = tempb41/squsr1
        ener1b = tempb38 + (prod1-xsigm)*flum5b + dif5b
        temp9 = (ener1+uas5(1))/squsr1
        tempb39 = tempb41/squsr2
        ener2b = tempb39 + (prod2-xsigm)*flum5b - dif5b
        temp10 = (ener2+uas5(2))/squsr2
        uas5b(1) = uas5b(1) + tempb38
        uas5b(2) = uas5b(2) + tempb39
        usrob = (squsr1*uas4(1)+squsr2*uas4(2))*uar4b + (squsr1*uas2(1)+
     +    squsr2*uas2(2))*uar2b + (squsr1*uas3(1)+squsr2*uas3(2))*uar3b 
     +    + (temp9+temp10)*uar5b
        tempb42 = usro*uar4b
        uas4b(1) = uas4b(1) + squsr1*tempb42
        uas4b(2) = uas4b(2) + squsr2*tempb42
        tempb45 = usro*uar3b
        uas3b(1) = uas3b(1) + squsr1*tempb45
        uas3b(2) = uas3b(2) + squsr2*tempb45
        tempb43 = usro*uar2b
        uas2b(1) = uas2b(1) + squsr1*tempb43
        uas2b(2) = uas2b(2) + squsr2*tempb43
        tempb44 = -(usrob/(squsr1+squsr2)**2)
        squsr1b = uas4(1)*tempb42 + uas2(1)*tempb43 + tempb44 + uas3(1)*
     +    tempb45 - temp9*tempb38
        squsr2b = uas4(2)*tempb42 + uas2(2)*tempb43 + tempb44 + uas3(2)*
     +    tempb45 - temp10*tempb39
        IF (uas1(2) .EQ. 0.0) THEN
          uas1b(2) = uas1b(2) - dif1b
        ELSE
          uas1b(2) = uas1b(2) + squsr2b/(2.0*SQRT(uas1(2))) - dif1b
        END IF
        IF (uas1(1) .EQ. 0.0) THEN
          uas1b(1) = uas1b(1) + (prod1-xsigm)*uas4(1)*flum4b
        ELSE
          uas1b(1) = uas1b(1) + (prod1-xsigm)*uas4(1)*flum4b + squsr1b/(
     +      2.0*SQRT(uas1(1)))
        END IF
        prod1b = uas1(1)*uas4(1)*flum4b + uas1(1)*uas2(1)*flum2b + uas1(
     +    1)*flum1b + uas1(1)*uas3(1)*flum3b + (uas5(1)+ener1)*flum5b
        prod2b = uas1(2)*uas4(2)*flum4b + uas1(2)*uas2(2)*flum2b + uas1(
     +    2)*flum1b + uas1(2)*uas3(2)*flum3b + (uas5(2)+ener2)*flum5b
        uas5b(1) = uas5b(1) + prod1*flum5b
        uas5b(2) = uas5b(2) + prod2*flum5b
        uas4b(1) = uas4b(1) + (prod1-xsigm)*uas1(1)*flum4b
        uas1b(2) = uas1b(2) + (prod2-xsigm)*uas4(2)*flum4b
        uas5b(1) = uas5b(1) + vno(3)*flum4b
        uas5b(2) = uas5b(2) + vno(3)*flum4b
        uas1b(1) = uas1b(1) + (prod1-xsigm)*uas3(1)*flum3b
        uas3b(1) = uas3b(1) + (prod1-xsigm)*uas1(1)*flum3b
        uas1b(2) = uas1b(2) + (prod2-xsigm)*uas3(2)*flum3b
        uas5b(1) = uas5b(1) + vno(2)*flum3b
        uas5b(2) = uas5b(2) + vno(2)*flum3b
        uas1b(1) = uas1b(1) + (prod1-xsigm)*uas2(1)*flum2b
        uas2b(1) = uas2b(1) + (prod1-xsigm)*uas1(1)*flum2b
        uas1b(2) = uas1b(2) + (prod2-xsigm)*uas2(2)*flum2b
        uas5b(1) = uas5b(1) + vno(1)*flum2b
        uas5b(2) = uas5b(2) + ener2b/gam1 + vno(1)*flum2b
        uas1b(1) = uas1b(1) + (prod1-xsigm)*flum1b
        uas1b(2) = uas1b(2) + 0.5d0*(uas2(2)**2+uas3(2)**2+uas4(2)**2)*
     +    ener2b + (prod2-xsigm)*flum1b
        tempb46 = 0.5d0*uas1(2)*ener2b
        uas4b(2) = uas4b(2) + 2*uas4(2)*tempb46 + vno(3)*prod2b + (prod2
     +    -xsigm)*uas1(2)*flum4b
        uas3b(2) = uas3b(2) + 2*uas3(2)*tempb46 + vno(2)*prod2b + (prod2
     +    -xsigm)*uas1(2)*flum3b
        uas2b(2) = uas2b(2) + 2*uas2(2)*tempb46 + vno(1)*prod2b + (prod2
     +    -xsigm)*uas1(2)*flum2b
        tempb47 = 0.5d0*uas1(1)*ener1b
        uas5b(1) = uas5b(1) + ener1b/gam1
        uas1b(1) = uas1b(1) + 0.5d0*(uas2(1)**2+uas3(1)**2+uas4(1)**2)*
     +    ener1b
        uas2b(1) = uas2b(1) + vno(1)*prod1b + 2*uas2(1)*tempb47
        uas3b(1) = uas3b(1) + vno(2)*prod1b + 2*uas3(1)*tempb47
        uas4b(1) = uas4b(1) + vno(3)*prod1b + 2*uas4(1)*tempb47
        fltr5b = -(bsign*uas5b(2))
        fltr4b = -(bsign*uas4b(2))
        fltr3b = -(bsign*uas3b(2))
        fltr2b = -(bsign*uas2b(2))
        fltr1b = -(bsign*uas1b(2))
        flur5b = bsign*uas5b(1)
        flur4b = bsign*uas4b(1)
        flur3b = bsign*uas3b(1)
        flur2b = bsign*uas2b(1)
        flur1b = bsign*uas1b(1)
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            temp7 = 2.0d0*e2 + dpex**2 + dpm**2
            tempb20 = aux1*flur5b/temp7
            tempb21 = -(((e2+dpex**2)*dpm+(e2+dpm**2)*dpex)*tempb20/
     +        temp7)
            dpexb = 2*dpex*tempb21 + (e2+dpm**2+dpm*2*dpex)*tempb20
            temp8 = 2.0d0*e2 + dpor**2 + dpm**2
            tempb18 = aux2*fltr5b/temp8
            tempb19 = -(((e2+dpor**2)*dpm+(e2+dpm**2)*dpor)*tempb18/
     +        temp8)
            dporb = 2*dpor*tempb19 + (e2+dpm**2+dpm*2*dpor)*tempb18
            dpmb = (dpex*2*dpm+e2+dpex**2)*tempb20 + 2*dpm*tempb21 - 
     +        dpexb - dporb + 2*dpm*tempb19 + (dpor*2*dpm+e2+dpor**2)*
     +        tempb18
            CALL POPREAL8(aux2)
            CALL POPREAL8(dpor)
            fltr5b = -(4.0d0*dporb)
            CALL POPREAL8(aux1)
            CALL POPREAL8(dpex)
            flur5b = -(4.0d0*dpexb)
            CALL POPREAL8(dpm)
            uas5b(1) = uas5b(1) + dpmb
            uas5b(2) = uas5b(2) - dpmb
            temp6 = 2.0d0*e2 + dpor**2 + dpm**2
            tempb22 = aux2*fltr4b/temp6
            tempb23 = -(((e2+dpor**2)*dpm+(e2+dpm**2)*dpor)*tempb22/
     +        temp6)
            dporb = 2*dpor*tempb23 + (e2+dpm**2+dpm*2*dpor)*tempb22
            temp5 = 2.0d0*e2 + dpex**2 + dpm**2
            tempb24 = aux1*flur4b/temp5
            tempb25 = -(((e2+dpex**2)*dpm+(e2+dpm**2)*dpex)*tempb24/
     +        temp5)
            dpexb = 2*dpex*tempb25 + (e2+dpm**2+dpm*2*dpex)*tempb24
            dpmb = (dpex*2*dpm+e2+dpex**2)*tempb24 + 2*dpm*tempb25 - 
     +        dpexb - dporb + 2*dpm*tempb23 + (dpor*2*dpm+e2+dpor**2)*
     +        tempb22
            CALL POPREAL8(aux2)
            CALL POPREAL8(dpor)
            fltr4b = -(4.0d0*dporb)
            CALL POPREAL8(aux1)
            CALL POPREAL8(dpex)
            flur4b = -(4.0d0*dpexb)
            CALL POPREAL8(dpm)
            uas4b(1) = uas4b(1) + dpmb
            uas4b(2) = uas4b(2) - dpmb
            temp4 = 2.0d0*e2 + dpor**2 + dpm**2
            tempb26 = aux2*fltr3b/temp4
            tempb27 = -(((e2+dpor**2)*dpm+(e2+dpm**2)*dpor)*tempb26/
     +        temp4)
            dporb = 2*dpor*tempb27 + (e2+dpm**2+dpm*2*dpor)*tempb26
            temp3 = 2.0d0*e2 + dpex**2 + dpm**2
            tempb28 = aux1*flur3b/temp3
            tempb29 = -(((e2+dpex**2)*dpm+(e2+dpm**2)*dpex)*tempb28/
     +        temp3)
            dpexb = 2*dpex*tempb29 + (e2+dpm**2+dpm*2*dpex)*tempb28
            dpmb = (dpex*2*dpm+e2+dpex**2)*tempb28 + 2*dpm*tempb29 - 
     +        dpexb - dporb + 2*dpm*tempb27 + (dpor*2*dpm+e2+dpor**2)*
     +        tempb26
            CALL POPREAL8(aux2)
            CALL POPREAL8(dpor)
            fltr3b = -(4.0d0*dporb)
            CALL POPREAL8(aux1)
            CALL POPREAL8(dpex)
            flur3b = -(4.0d0*dpexb)
            CALL POPREAL8(dpm)
            uas3b(1) = uas3b(1) + dpmb
            uas3b(2) = uas3b(2) - dpmb
            temp2 = 2.0d0*e2 + dpor**2 + dpm**2
            tempb30 = aux2*fltr2b/temp2
            tempb31 = -(((e2+dpor**2)*dpm+(e2+dpm**2)*dpor)*tempb30/
     +        temp2)
            dporb = 2*dpor*tempb31 + (e2+dpm**2+dpm*2*dpor)*tempb30
            temp1 = 2.0d0*e2 + dpex**2 + dpm**2
            tempb32 = aux1*flur2b/temp1
            tempb33 = -(((e2+dpex**2)*dpm+(e2+dpm**2)*dpex)*tempb32/
     +        temp1)
            dpexb = 2*dpex*tempb33 + (e2+dpm**2+dpm*2*dpex)*tempb32
            dpmb = (dpex*2*dpm+e2+dpex**2)*tempb32 + 2*dpm*tempb33 - 
     +        dpexb - dporb + 2*dpm*tempb31 + (dpor*2*dpm+e2+dpor**2)*
     +        tempb30
            CALL POPREAL8(aux2)
            CALL POPREAL8(dpor)
            fltr2b = -(4.0d0*dporb)
            CALL POPREAL8(aux1)
            CALL POPREAL8(dpex)
            flur2b = -(4.0d0*dpexb)
            CALL POPREAL8(dpm)
            uas2b(1) = uas2b(1) + dpmb
            uas2b(2) = uas2b(2) - dpmb
            temp0 = 2.0d0*e2 + dpor**2 + dpm**2
            tempb34 = aux2*fltr1b/temp0
            tempb35 = -(((e2+dpor**2)*dpm+(e2+dpm**2)*dpor)*tempb34/
     +        temp0)
            dporb = 2*dpor*tempb35 + (e2+dpm**2+dpm*2*dpor)*tempb34
            temp = 2.0d0*e2 + dpex**2 + dpm**2
            tempb36 = aux1*flur1b/temp
            tempb37 = -(((e2+dpex**2)*dpm+(e2+dpm**2)*dpex)*tempb36/temp
     +        )
            dpexb = 2*dpex*tempb37 + (e2+dpm**2+dpm*2*dpex)*tempb36
            dpmb = (dpex*2*dpm+e2+dpex**2)*tempb36 + 2*dpm*tempb37 - 
     +        dpexb - dporb + 2*dpm*tempb35 + (dpor*2*dpm+e2+dpor**2)*
     +        tempb34
            fltr1b = -(4.0d0*dporb)
            flur1b = -(4.0d0*dpexb)
            uas1b(1) = uas1b(1) + dpmb
            uas1b(2) = uas1b(2) - dpmb
          END IF
          tempb8 = beta2*fltr5b
          dxb(5, nubo2) = dxb(5, nubo2) + aix*tempb8
          dyb(5, nubo2) = dyb(5, nubo2) + aiy*tempb8
          dzb(5, nubo2) = dzb(5, nubo2) + aiz*tempb8
          uas5b(2) = uas5b(2) + beta3*fltr5b
          uas5b(1) = uas5b(1) - beta3*fltr5b
          tempb9 = beta2*fltr4b
          dxb(4, nubo2) = dxb(4, nubo2) + aix*tempb9
          dyb(4, nubo2) = dyb(4, nubo2) + aiy*tempb9
          dzb(4, nubo2) = dzb(4, nubo2) + aiz*tempb9
          uas4b(2) = uas4b(2) + beta3*fltr4b
          uas4b(1) = uas4b(1) - beta3*fltr4b
          tempb10 = beta2*fltr3b
          dxb(3, nubo2) = dxb(3, nubo2) + aix*tempb10
          dyb(3, nubo2) = dyb(3, nubo2) + aiy*tempb10
          dzb(3, nubo2) = dzb(3, nubo2) + aiz*tempb10
          uas3b(2) = uas3b(2) + beta3*fltr3b
          uas3b(1) = uas3b(1) - beta3*fltr3b
          tempb11 = beta2*fltr2b
          dxb(2, nubo2) = dxb(2, nubo2) + aix*tempb11
          dyb(2, nubo2) = dyb(2, nubo2) + aiy*tempb11
          dzb(2, nubo2) = dzb(2, nubo2) + aiz*tempb11
          uas2b(2) = uas2b(2) + beta3*fltr2b
          uas2b(1) = uas2b(1) - beta3*fltr2b
          tempb12 = beta2*fltr1b
          dxb(1, nubo2) = dxb(1, nubo2) + aix*tempb12
          dyb(1, nubo2) = dyb(1, nubo2) + aiy*tempb12
          dzb(1, nubo2) = dzb(1, nubo2) + aiz*tempb12
          uas1b(2) = uas1b(2) + beta3*fltr1b
          uas1b(1) = uas1b(1) - beta3*fltr1b
          tempb13 = beta2*flur5b
          dxb(5, nubo1) = dxb(5, nubo1) + aix*tempb13
          dyb(5, nubo1) = dyb(5, nubo1) + aiy*tempb13
          dzb(5, nubo1) = dzb(5, nubo1) + aiz*tempb13
          uas5b(2) = uas5b(2) + beta3*flur5b
          uas5b(1) = uas5b(1) - beta3*flur5b
          tempb14 = beta2*flur4b
          dxb(4, nubo1) = dxb(4, nubo1) + aix*tempb14
          dyb(4, nubo1) = dyb(4, nubo1) + aiy*tempb14
          dzb(4, nubo1) = dzb(4, nubo1) + aiz*tempb14
          uas4b(2) = uas4b(2) + beta3*flur4b
          uas4b(1) = uas4b(1) - beta3*flur4b
          tempb15 = beta2*flur3b
          dxb(3, nubo1) = dxb(3, nubo1) + aix*tempb15
          dyb(3, nubo1) = dyb(3, nubo1) + aiy*tempb15
          dzb(3, nubo1) = dzb(3, nubo1) + aiz*tempb15
          uas3b(2) = uas3b(2) + beta3*flur3b
          uas3b(1) = uas3b(1) - beta3*flur3b
          tempb16 = beta2*flur2b
          dxb(2, nubo1) = dxb(2, nubo1) + aix*tempb16
          dyb(2, nubo1) = dyb(2, nubo1) + aiy*tempb16
          dzb(2, nubo1) = dzb(2, nubo1) + aiz*tempb16
          uas2b(2) = uas2b(2) + beta3*flur2b
          uas2b(1) = uas2b(1) - beta3*flur2b
          tempb17 = beta2*flur1b
          dxb(1, nubo1) = dxb(1, nubo1) + aix*tempb17
          dyb(1, nubo1) = dyb(1, nubo1) + aiy*tempb17
          dzb(1, nubo1) = dzb(1, nubo1) + aiz*tempb17
          uas1b(2) = uas1b(2) + beta3*flur1b
          uas1b(1) = uas1b(1) - beta3*flur1b
        END IF
        unb(5, nubo2) = unb(5, nubo2) + uas5b(2)
        uas5b(2) = 0.D0
        unb(5, nubo1) = unb(5, nubo1) + uas5b(1)
        uas5b(1) = 0.D0
        unb(4, nubo2) = unb(4, nubo2) + uas4b(2)
        uas4b(2) = 0.D0
        unb(4, nubo1) = unb(4, nubo1) + uas4b(1)
        uas4b(1) = 0.D0
        unb(3, nubo2) = unb(3, nubo2) + uas3b(2)
        uas3b(2) = 0.D0
        unb(3, nubo1) = unb(3, nubo1) + uas3b(1)
        uas3b(1) = 0.D0
        unb(2, nubo2) = unb(2, nubo2) + uas2b(2)
        uas2b(2) = 0.D0
        unb(2, nubo1) = unb(2, nubo1) + uas2b(1)
        uas2b(1) = 0.D0
        unb(1, nubo2) = unb(1, nubo2) + uas1b(2)
        uas1b(2) = 0.D0
        unb(1, nubo1) = unb(1, nubo1) + uas1b(1)
        uas1b(1) = 0.D0
      ENDDO
      DO is=1,ns
C
        dtpred = 0.5d0*dtl(is)*ipred
C
        ro = ua(1, is)
        usro = 1.0d0/ro
        u = ua(2, is)*usro
        v = ua(3, is)*usro
        w = ua(4, is)*usro
        p = gam1*(ua(5, is)-0.5d0*ro*(u*u+v*v+w*w))
C
        tempb = -(dtpred*unb(5, is))
        tempb0 = gam*p*tempb
        pb = gam*(dx(2, is)+dy(3, is)+dz(4, is))*tempb + unb(5, is)
        dxb(5, is) = dxb(5, is) + u*tempb
        dyb(5, is) = dyb(5, is) + v*tempb
        dzb(5, is) = dzb(5, is) + w*tempb
        dxb(2, is) = dxb(2, is) + tempb0
        dyb(3, is) = dyb(3, is) + tempb0
        unb(5, is) = 0.D0
        tempb1 = -(dtpred*unb(4, is))
        wb = unb(4, is) + dz(4, is)*tempb1 + dz(5, is)*tempb
        dzb(4, is) = dzb(4, is) + w*tempb1 + tempb0
        dxb(4, is) = dxb(4, is) + u*tempb1
        dyb(4, is) = dyb(4, is) + v*tempb1
        dzb(5, is) = dzb(5, is) + usro*tempb1
        unb(4, is) = 0.D0
        tempb3 = -(dtpred*unb(3, is))
        vb = dy(4, is)*tempb1 + dy(3, is)*tempb3 + unb(3, is) + dy(5, is
     +    )*tempb
        dxb(3, is) = dxb(3, is) + u*tempb3
        dyb(3, is) = dyb(3, is) + v*tempb3
        dzb(3, is) = dzb(3, is) + w*tempb3
        dyb(5, is) = dyb(5, is) + usro*tempb3
        unb(3, is) = 0.D0
        tempb2 = -(dtpred*unb(2, is))
        ub = dx(4, is)*tempb1 + unb(2, is) + dx(2, is)*tempb2 + dx(3, is
     +    )*tempb3 + dx(5, is)*tempb
        dxb(2, is) = dxb(2, is) + u*tempb2
        dyb(2, is) = dyb(2, is) + v*tempb2
        dzb(2, is) = dzb(2, is) + w*tempb2
        dxb(5, is) = dxb(5, is) + usro*tempb2
        unb(2, is) = 0.D0
        tempb5 = -(dtpred*unb(1, is))
        tempb6 = ro*tempb5
        dxb(1, is) = dxb(1, is) + u*tempb5
        dyb(1, is) = dyb(1, is) + v*tempb5
        dzb(1, is) = dzb(1, is) + w*tempb5
        dxb(2, is) = dxb(2, is) + tempb6
        dyb(3, is) = dyb(3, is) + tempb6
        dzb(4, is) = dzb(4, is) + tempb6
        tempb7 = gam1*pb
        tempb4 = -(0.5d0*ro*tempb7)
        wb = wb + dz(2, is)*tempb2 + 2*w*tempb4 + dz(1, is)*tempb5 + dz(
     +    3, is)*tempb3
        vb = vb + dy(1, is)*tempb5 + 2*v*tempb4 + dy(2, is)*tempb2
        ub = ub + 2*u*tempb4 + dx(1, is)*tempb5
        usrob = dy(5, is)*tempb3 + ua(4, is)*wb + ua(2, is)*ub + ua(3, 
     +    is)*vb + dx(5, is)*tempb2 + dz(5, is)*tempb1
        rob = (dx(2, is)+dy(3, is)+dz(4, is))*tempb5 - usrob/ro**2 - 
     +    0.5d0*(u**2+v**2+w**2)*tempb7 + unb(1, is)
        unb(1, is) = 0.D0
        uab(5, is) = uab(5, is) + tempb7
        uab(4, is) = uab(4, is) + usro*wb
        uab(3, is) = uab(3, is) + usro*vb
        uab(2, is) = uab(2, is) + usro*ub
        uab(1, is) = uab(1, is) + rob
      ENDDO
      END

C  Differentiation of gradnod in reverse (adjoint) mode:
C   gradient     of useful results: ua dx dy dz
C   with respect to varying inputs: ua
      SUBROUTINE GRADNOD_B()
      IMPLICIT NONE
C     -----------------------------------------------------------------
C     Degres de liberte
      INTEGER nequation
      PARAMETER (nequation=5)
C
C     Maximum number of vertices 
      INTEGER nsmax
      PARAMETER (nsmax=12966)
C     Maximum number of tetraedra
      INTEGER ntmax
      PARAMETER (ntmax=65421)
C     Maximum number of boundary faces
      INTEGER nfcmax
      PARAMETER (nfcmax=7350)
C     Maximum number of edges 
      INTEGER nsgmax
      PARAMETER (nsgmax=82056)
C     Maximum number of edges attached to a mesh vertex
      INTEGER ndmax
      PARAMETER (ndmax=150)
C     Maximum number of tetraedra attached to a mesh vertex
      INTEGER nvmax
      PARAMETER (nvmax=49)
C     Allowable values for boundary vertices logical reference
      INTEGER klogmin, klogmax
      PARAMETER (klogmin=1, klogmax=30)
C     Maximum numbers of colors for the tetraedra and edges 
      INTEGER nctmax, ncamax
      PARAMETER (nctmax=710, ncamax=710)
C     Characteristic length for vectorisation
      INTEGER lvect
      PARAMETER (lvect=128)
C     Maximum length of arrays for vector operations
      INTEGER lvmax
      PARAMETER (lvmax=128)
C     -----------------------------------------------------------------
C     Maximum number of timers
      INTEGER icpmax
      PARAMETER (icpmax=21)
C     Timers definition
      REAL*8 time(icpmax)
C     Mflop rates
      REAL*8 flop(icpmax)
C
      COMMON /rtimrs/ time, flop
C
C     -----------------------------------------------------------------
C     Effective numbers of tetraedra and edges colors 
      INTEGER nca, nct
C     Data structures for the tetraedra and edges colors
      INTEGER icolt(0:nctmax), icola(0:ncamax)
      INTEGER mark(nsgmax)
C
      COMMON /icolor/ nca, nct, icolt, icola, mark
C
C     -----------------------------------------------------------------
C     Effective numbers of vertices, tetraedra, edges and 
C     boundary faces
      INTEGER ns, nt, nseg, nfac
C     Tetraedra connectivity table
      INTEGER nu(4, ntmax)
C     Boundary faces connectivity table
      INTEGER nsfac(3, nfcmax)
C     Boundary faces logical reference table
      INTEGER logfac(nfcmax), log1fac(nfcmax)
C     Boundary vertices logical reference table
      INTEGER logfr(nsmax)
C     Auxiliary table for boundary vertices logical reference 
      INTEGER fv(nsmax)
C     Boundary faces index table
      INTEGER noe1(nfcmax)
C     Effective numbers of faces for each allowable value of
C     boundary face logical reference
      INTEGER nblog(klogmin:klogmax)
C     Edges connectivity table
      INTEGER nubo(2, nsgmax)
C     Effective number of edges attached to a mesh vertex
      INTEGER ndeg(nsmax), inew(nsmax)
C     Identification of the set of edges attached to 
C     a mesh vertex
      INTEGER jaret(nsmax, ndmax)
C     Effective number of tetraedra attached to a mesh vertex
      INTEGER nbvoi(nsmax)
C     Identification of the set of tetraedra attached to 
C     a mesh vertex
      INTEGER ivoi(nsmax, nvmax)
C     Identification of the upstream and downstream tetraedra 
C     associated to an edge
      INTEGER jta(2, nsgmax)
C     Effective number of faces with a given boundary logical 
C     reference 
      INTEGER nf1, nf2, nf3, nf11
C   
      COMMON /igeom0/ ns, nt, nseg, nfac
      COMMON /igeom1/ nu, nsfac, logfac, nubo, logfr, log1fac
      COMMON /igeom2/ noe1, nblog, fv
      COMMON /igeom3/ nf1, nf2, nf3, nf11
      COMMON /igeom4/ ndeg, inew, jaret, nbvoi, ivoi, jta
C
C     Initial and instantaneous coordinates of the mesh vertices
      REAL*8 coor(3, nsmax), coco(3, nsmax)
C     Initial mesh coordinates (zz)
      REAL*8 coin(3, nsmax)
C     Control volume and tetraedra volumes
      REAL*8 vols(nsmax), volt(ntmax)
C     Control volume boundary normal components
      REAL*8 vnocl(3, nsgmax)
C     Boundary faces normal components
      REAL*8 vnfac(3, nfcmax)
C     Mean values of the normal to tetradra faces
      REAL*8 tvno(ntmax, 4, 3)
C 
      COMMON /rgeom1/ coor, coco, coin
      COMMON /rgeom2/ vols, volt, vnocl, vnfac
      COMMON /rgeom3/ tvno
C
C     -----------------------------------------------------------------
C     Physical solution
      REAL*8 ua(5, nsmax), un(5, nsmax)
      REAL*8 uab(5, nsmax)
C     Nodal fluxes (gathered convective and diffusive fluxes)
      REAL*8 ce(5, nsmax)
      REAL*8 ceb(5, nsmax)
C     Nodal gradients
      REAL*8 dx(5, nsmax), dy(5, nsmax), dz(5, nsmax)
      REAL*8 dxb(5, nsmax), dyb(5, nsmax), dzb(5, nsmax)
C     Local time steps
      REAL*8 dtl(nsmax)
C     Mesh vertices velocities
      REAL*8 xw1(nsmax), xw2(nsmax), xw3(nsmax)
C     Mean value of mesh edges and boundary faces velocities
      REAL*8 sigma(nsgmax), vnsig(nfcmax)
C     Auxiliary array used during mesh vertices based operations
      REAL*8 ce1(nsmax)
C
      COMMON /rsol1/ ua, un, ce, dx, dy, dz
      COMMON /rsol2/ dtl
      COMMON /rsol3/ xw1, xw2, xw3
      COMMON /rsol4/ sigma, vnsig
      COMMON /rsol5/ ce1
C
C     -----------------------------------------------------------------
C     Reinitialisation flag 
      INTEGER ncont
C     Local time-step strategy flag
      INTEGER iloc
C     Courant number law parameters
      REAL*8 cfl, xcfl, ycfl, zcfl, cflmax
C     Convective flux solver identifier
      INTEGER iflux
C     Spatial approximation precision order
      INTEGER nordre
C     Predictor-corrector time integration scheme flag
      INTEGER ipred
C     Maximum, initial and effective number of time steps
      INTEGER ktmax, kt0, kt
C     Flag for a viscous computation
      INTEGER ivis
C     Flag for a moving mesh computation
      INTEGER idefor
C     Flag used when deforming the mesh
      INTEGER imcas
C     Flag for explicit/implicit time integration 
C     Maximum and effective number of relaxations in the 
C     implicit phase
C     Relaxations pour l'etat-adjoint
      INTEGER nexp, nbrel, nit, nbrelpi
C     Linear system solver identifier
      INTEGER irlax
C     Flag for the type of storage used for the extra-diagonal 
C     blocks 
      INTEGER istok
C     Residual tolerance for the linear iteration (implicit phase)
      REAL*8 err
C     Maximal, initial and effective  physical time 
      REAL*8 tmax, t0, t
C     Global and maximal allowable time step
      REAL*8 dt, ddtmax
C     Residual tolerance for the non-linear iteration
      REAL*8 resf
C     Flow characteristic quantities
      REAL*8 rhoref, pref, lref, vref
C     Free stream Mach number
      REAL*8 xmach
C     Free stream quantities used to define the free stream 
C     physical states
      REAL*8 roin, uxin, uyin, uzin, pin
      REAL*8 roout, uxout, uyout, uzout, pout
C     Free stream physical states
      REAL*8 ub2(5, nfcmax), ub3(5, nfcmax)
C     Real gaz physical quantities
      REAL*8 gam, gam1
C     Reynolds and Prandtl numbers, viscosisty and temperature 
C     on the body
      REAL*8 rey, pr, xmu, tbrd
C
      INTEGER oneshot
      COMMON /ressimul/ oneshot
C
C     Nombre d'iterations de jacobi pour resoudre l'etat et l'etat-adjoint
C     en one-shot
      INTEGER nbrelos
C
      COMMON /icmflg/ ncont, iloc, ivis, idefor, ipred
      COMMON /icmflx/ iflux
      COMMON /icmgrd/ imcas
      COMMON /icmimp/ nexp, nbrel, nit, irlax, istok, nbrelos, nbrelpi
      COMMON /icmord/ nordre
C
C     Nombre d'iterations maximales pour l'etat en one-shot
      INTEGER ktmaxos
      COMMON /icmstp/ ktmax, kt0, kt, ktmaxos
C
C     Residu a atteindre pour resoudre l'etat-adjoint
      REAL*8 errjacpi
C
      COMMON /rcmstp/ tmax, t0, t, resf
      COMMON /rcmdtg/ dt, ddtmax
      COMMON /rcmimp/ err, errjacpi
      COMMON /comcfl/ cfl, xcfl, ycfl, zcfl, cflmax
      COMMON /comref/ rhoref, pref, lref, vref
      COMMON /frsmch/ xmach
      COMMON /frstr1/ roin, uxin, uyin, uzin, pin, roout, uxout, uyout, 
     +uzout, pout
      COMMON /frstr2/ ub2, ub3
      COMMON /comgam/ gam, gam1
      COMMON /comvis/ rey, pr, xmu, tbrd
C
C     -----------------------------------------------------------------
C     Frequency parameters used when printing and saving the physical 
C     solution
      INTEGER ifre, ifre1, impre, ifrel
C
      COMMON /icmedt/ ifre, ifre1, impre, ifrel
C
C     -----------------------------------------------------------------
C     Selected problem identifier
      INTEGER coefm1
C     Variables related to the piston engine geometry
      REAL*8 cadmax, cads
      REAL*8 thet0, ca, squish, rps, stroke, conrod
      REAL*8 wpist, wspa, wspe
      REAL*8 vpist(3), vspa(3), vspe(3)
      REAL*8 aoa, aoe, rfa, rfe, lma, lme
      REAL*8 hpist, hspa, hspe, hplan, href
C
      COMMON /icmpst/ coefm1
C
      COMMON /cmpst0/ cadmax, cads
      COMMON /cmpst1/ thet0, ca, squish, rps, stroke, conrod
      COMMON /cmpst2/ wpist, wspa, wspe, vpist, vspa, vspe
      COMMON /cmpst3/ aoa, aoe, rfa, rfe, lma, lme
      COMMON /cmpst4/ hpist, hspa, hspe, hplan, href
C
C     -----------------------------------------------------------------
C     Parameters and data structures related to the implicit time 
C     integration scheme
      INTEGER nsegs
      PARAMETER (nsegs=50*nsgmax)
C     Storage of the diagonal blocks
      REAL*8 diag(nsmax, 5, 5), adh1(nsmax)
C     Storage of the extra diagonal blocks
      REAL*8 stmat(nsegs)
C     Stockage des termes extra-diagonaux de la matrice
      REAL*8 zm(5, 5, 2, nsgmax)
C
      COMMON /comimp/ diag, stmat, adh1, zm
C 
C     -----------------------------------------------------------------
C     Auxiliary variables used when computing the convective fluxes
      INTEGER ient, icoef
      REAL*8 epsiim, epsiex
C
      COMMON /icmfx1/ ient, icoef
      COMMON /rcmfx1/ epsiim, epsiex
C
C     -----------------------------------------------------------------
C     Auxiliary  variables related to the moving mesh feature
C     Maximum and effective number of relaxations in the 
C     moving mesh phase
      INTEGER maxjac, kjac
C     Residual tolerance and effective residual for the linear 
C     iteration in the moving mesh phase phase
      REAL*8 rsjacf, rsjac
C     Elastic center coordinates
      REAL*8 xce, yce, zce
C     Instantaneous angle of attack
      REAL*8 tetat
C     Original coordinates of the mesh vertices
      REAL*8 xt0(nsmax), yt0(nsmax), zt0(nsmax)
C     Displacements of the mesh vertices
      REAL*8 deltx(2, nsmax), delty(2, nsmax), deltz(2, nsmax)
C     Predicted displacements of the mesh vertices
      REAL*8 deltxp(nsmax), deltyp(nsmax), deltzp(nsmax)
C
      COMMON /imomsh/ maxjac, kjac
      COMMON /mvmsh0/ rsjacf, rsjac
      COMMON /mvmsh1/ xce, yce, zce, tetat
      COMMON /mvmsh2/ xt0, yt0, zt0
      COMMON /mvmsh3/ deltx, delty, deltz, deltxp, deltyp, deltzp
C
      REAL*8 som1, dro1, som, dro
      COMMON /residus/ som1, dro1, som, dro
C
      REAL*8 omega
      COMMON /newton/ omega
C
      INTEGER diric, bound
      COMMON /boundaries/ diric, bound
C
C     NODE3D2D :Tab. de correspondance entre maillage et coque sur les noeuds
C     FACE3D2D :  "            "         "      "          "           faces
C
      INTEGER node3d2d(nsmax), face3d2d(nfcmax)
      COMMON /corres3d2d/ node3d2d, face3d2d
C
      REAL*8 pdesp(nsmax), djdw(5, nsmax), piadj(5, nsmax)
      COMMON /pression/ pdesp
      COMMON /opti/ djdw, piadj
C
      INTEGER validpsi, newton, testder, testadj, testgrad, testderw
      COMMON /verif/ validpsi, newton, testder, testadj, testgrad, 
     +testderw
C
      INTEGER itmax, itopt, ncf, npres, ncontopt, contr, defortuy
      COMMON /optimis/ itmax, itopt, ncf, npres, ncontopt, contr, 
     +defortuy
C
      INTEGER niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
      COMMON /hiera/ niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
C
      REAL*8 erreur, roopt, roinit, roos
      COMMON /resopti/ erreur, roopt, roinit, roos
C
      REAL*8 coeftrainee, teta, cltarget, cdinit, cdtarget, tetacdcl
      REAL*8 coefpres
      REAL*8 tetaxy, tetaxz, tetazy
      INTEGER*4 igicc
      COMMON /iangles/ igicc
      COMMON /calctrainchoc/ coeftrainee, cltarget, cdinit, cdtarget
      COMMON /anglesincid/ teta, tetacdcl, coefpres, tetaxy, tetaxz, 
     +tetazy
C
C     ZZ PARAMETERS:
C     ===============
C
      INTEGER intzz(30)
      COMMON /integerzz/ intzz
C     CPU time evaluation (all real*4)
      REAL*8 pmnew, pmold
      COMMON /mxmi/ pmnew, pmold
C---------------------------------------------------------------------
C     Local variables definition
      INTEGER ivar, k, jt, ia, ib
      INTEGER is, is1, is2, is3, is4, id1, id2
      INTEGER iseg, nub1, nub2, js1, js2
      REAL*8 usro
      REAL*8 usrob
      REAL*8 vol6, ait, ais
      REAL*8 ds3, us4, us6
      REAL*8 x(4), y(4), z(4), b(4), c(4), d(4)
      REAL*8 dbx(5), dby(5), dbz(5)
      REAL*8 dxt(5), dyt(5), dzt(5)
      REAL*8 dxtb(5), dytb(5), dztb(5)
      REAL*8 uph(5, 4)
      REAL*8 uphb(5, 4)
      REAL*8 pentel(nsmax)
      INTRINSIC SIGN
      INTRINSIC ABS
      INTRINSIC MIN
      REAL*8 min1
      REAL*8 min1b
      REAL*8 min2
      REAL*8 min2b
      REAL*8 min3
      REAL*8 min3b
      REAL*8 tempb
      REAL*8 tempb0
      REAL*8 x1b
      REAL*8 y1b
      REAL*8 tempb1
      REAL*8 x2b
      REAL*8 y2b
      REAL*8 tempb2
      REAL*8 x3b
      REAL*8 y3b
      REAL*8 tempb3
      INTEGER branch
      INTEGER ii1
      INTEGER ii2
      REAL*8 x3
      REAL*8 x2
      REAL*8 x1
      REAL*8 y3
      REAL*8 y2
      REAL*8 y1
      COMMON /rsol1_b/ uab, ceb, dxb, dyb, dzb
C
C     Initialisations
C
      us4 = 1.0d0/4.0d0
      us6 = 1.0d0/6.0d0
C
C
      DO is=1,ns
        pentel(is) = 0.0d0
      ENDDO
C
C
C           --------
C
C
C
C       IF ((nordre .EQ. 2) .OR. (nordre .EQ. 3)) THEN 
C     ========
C
C
C
C
C
C     Completing the non-limited nodal gradients
C
      IF (nordre .EQ. 2 .OR. nordre .EQ. 3) THEN
        DO ivar=1,5
          CALL PUSHINTEGER4(is)
          DO is=ns,1,-1
            ais = 1.0d0/vols(is)
            dzb(ivar, is) = ais*dzb(ivar, is)
            dyb(ivar, is) = ais*dyb(ivar, is)
            dxb(ivar, is) = ais*dxb(ivar, is)
          ENDDO
          CALL POPINTEGER4(is)
        ENDDO
      END IF
      DO ii1=1,4
        DO ii2=1,5
          uphb(ii2, ii1) = 0.0
        ENDDO
      ENDDO
      DO ii1=1,5
        dxtb(ii1) = 0.0
      ENDDO
      DO ii1=1,5
        dytb(ii1) = 0.0
      ENDDO
      DO ii1=1,5
        dztb(ii1) = 0.0
      ENDDO
      DO jt=1,nt
C     ===============
C
C
C
        DO k=1,4
C        -----------
          is = nu(k, jt)
C
          uph(1, k) = ua(1, is)
          CALL PUSHREAL8(usro)
          usro = 1.0d0/uph(1, k)
C
          CALL PUSHREAL8(uph(2, k))
          uph(2, k) = ua(2, is)*usro
          CALL PUSHREAL8(uph(3, k))
          uph(3, k) = ua(3, is)*usro
          CALL PUSHREAL8(uph(4, k))
          uph(4, k) = ua(4, is)*usro
C
          CALL PUSHREAL8(uph(5, k))
          uph(5, k) = gam1*(ua(5, is)-0.5d0*uph(1, k)*(uph(2, k)*uph(2, 
     +      k)+uph(3, k)*uph(3, k)+uph(4, k)*uph(4, k)))
        ENDDO
C
C        --------
C
C
        is1 = nu(1, jt)
        is2 = nu(2, jt)
        is3 = nu(3, jt)
        is4 = nu(4, jt)
C
        x(1) = coor(1, is1)
        y(1) = coor(2, is1)
        z(1) = coor(3, is1)
C
        x(2) = coor(1, is2)
        y(2) = coor(2, is2)
        z(2) = coor(3, is2)
C
        x(3) = coor(1, is3)
        y(3) = coor(2, is3)
        z(3) = coor(3, is3)
C
        x(4) = coor(1, is4)
        y(4) = coor(2, is4)
        z(4) = coor(3, is4)
C     
C
C        Computing the basis function gradients
C
        CALL GRADFB(x, y, z, b, c, d, vol6)
C
        ait = us6/volt(jt)
C
        dbx(1) = b(1)*ait
        dbx(2) = b(2)*ait
        dbx(3) = b(3)*ait
        dbx(4) = b(4)*ait
C
        dby(1) = c(1)*ait
        dby(2) = c(2)*ait
        dby(3) = c(3)*ait
        dby(4) = c(4)*ait
C
        dbz(1) = d(1)*ait
        dbz(2) = d(2)*ait
        dbz(3) = d(3)*ait
        dbz(4) = d(4)*ait
C
C
C        Computing the P1-gradients on each tetraedra
C
C
        DO ivar=1,5
C        --------------
          dxt(ivar) = uph(ivar, 1)*dbx(1) + uph(ivar, 2)*dbx(2) + uph(
     +      ivar, 3)*dbx(3) + uph(ivar, 4)*dbx(4)
C
          dyt(ivar) = uph(ivar, 1)*dby(1) + uph(ivar, 2)*dby(2) + uph(
     +      ivar, 3)*dby(3) + uph(ivar, 4)*dby(4)
C
          dzt(ivar) = uph(ivar, 1)*dbz(1) + uph(ivar, 2)*dbz(2) + uph(
     +      ivar, 3)*dbz(3) + uph(ivar, 4)*dbz(4)
        ENDDO
C
C        --------
C
        IF (nordre .NE. 1) THEN
          IF (nordre .EQ. 4) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
C
C        Computing the hermitian nodal gradients
C
            ait = us4*volt(jt)
C
            DO ivar=1,5
C        --------------
              dx(ivar, is1) = dx(ivar, is1) + dxt(ivar)*ait
              dx(ivar, is2) = dx(ivar, is2) + dxt(ivar)*ait
              dx(ivar, is3) = dx(ivar, is3) + dxt(ivar)*ait
              dx(ivar, is4) = dx(ivar, is4) + dxt(ivar)*ait
C
              dy(ivar, is1) = dy(ivar, is1) + dyt(ivar)*ait
              dy(ivar, is2) = dy(ivar, is2) + dyt(ivar)*ait
              dy(ivar, is3) = dy(ivar, is3) + dyt(ivar)*ait
              dy(ivar, is4) = dy(ivar, is4) + dyt(ivar)*ait
C     
              dz(ivar, is1) = dz(ivar, is1) + dzt(ivar)*ait
              dz(ivar, is2) = dz(ivar, is2) + dzt(ivar)*ait
              dz(ivar, is3) = dz(ivar, is3) + dzt(ivar)*ait
              dz(ivar, is4) = dz(ivar, is4) + dzt(ivar)*ait
            ENDDO
            CALL PUSHCONTROL1B(1)
          END IF
C
C        --------
C
C          IF (nordre .EQ. 4) 
C
          IF (nordre .EQ. 4) THEN
C
            DO k=1,4
C           -------------
              is = nu(k, jt)
C
              DO ivar=1,5
                IF (dxt(ivar) .GE. 0.) THEN
                  x1 = dxt(ivar)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  x1 = -dxt(ivar)
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (dx(ivar, is) .GE. 0.) THEN
                  y1 = dx(ivar, is)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  y1 = -dx(ivar, is)
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (x1 .GT. y1) THEN
                  min1 = y1
                  CALL PUSHCONTROL1B(0)
                ELSE
                  min1 = x1
                  CALL PUSHCONTROL1B(1)
                END IF
C
                CALL PUSHREAL8(dx(ivar, is))
                dx(ivar, is) = (1.0d0-pentel(is))*dxt(ivar) + pentel(is)
     +            *0.5d0*(SIGN(1.0d0, dxt(ivar))+SIGN(1.0d0, dx(ivar, is
     +            )))*min1
                IF (dyt(ivar) .GE. 0.) THEN
                  x2 = dyt(ivar)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  x2 = -dyt(ivar)
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (dy(ivar, is) .GE. 0.) THEN
                  y2 = dy(ivar, is)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  y2 = -dy(ivar, is)
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (x2 .GT. y2) THEN
                  min2 = y2
                  CALL PUSHCONTROL1B(0)
                ELSE
                  min2 = x2
                  CALL PUSHCONTROL1B(1)
                END IF
C
                CALL PUSHREAL8(dy(ivar, is))
                dy(ivar, is) = (1.0d0-pentel(is))*dyt(ivar) + pentel(is)
     +            *0.5d0*(SIGN(1.0d0, dyt(ivar))+SIGN(1.0d0, dy(ivar, is
     +            )))*min2
                IF (dzt(ivar) .GE. 0.) THEN
                  x3 = dzt(ivar)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  x3 = -dzt(ivar)
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (dz(ivar, is) .GE. 0.) THEN
                  y3 = dz(ivar, is)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  y3 = -dz(ivar, is)
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (x3 .GT. y3) THEN
                  min3 = y3
                  CALL PUSHCONTROL1B(0)
                ELSE
                  min3 = x3
                  CALL PUSHCONTROL1B(1)
                END IF
C
                CALL PUSHREAL8(dz(ivar, is))
                dz(ivar, is) = (1.0d0-pentel(is))*dzt(ivar) + pentel(is)
     +            *0.5d0*(SIGN(1.0d0, dzt(ivar))+SIGN(1.0d0, dz(ivar, is
     +            )))*min3
C
                CALL PUSHREAL8(pentel(is))
                pentel(is) = 1.0d0
              ENDDO
            ENDDO
            DO k=4,1,-1
              is = nu(k, jt)
              DO ivar=5,1,-1
                CALL POPREAL8(pentel(is))
                CALL POPREAL8(dz(ivar, is))
                tempb3 = pentel(is)*0.5d0*dzb(ivar, is)
                dztb(ivar) = dztb(ivar) + (1.0d0-pentel(is))*dzb(ivar, 
     +            is)
                min3b = (SIGN(1.0d0, dzt(ivar))+SIGN(1.0d0, dz(ivar, is)
     +            ))*tempb3
                dzb(ivar, is) = 0.D0
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y3b = min3b
                  x3b = 0.0
                ELSE
                  x3b = min3b
                  y3b = 0.0
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  dzb(ivar, is) = dzb(ivar, is) + y3b
                ELSE
                  dzb(ivar, is) = dzb(ivar, is) - y3b
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  dztb(ivar) = dztb(ivar) + x3b
                ELSE
                  dztb(ivar) = dztb(ivar) - x3b
                END IF
                CALL POPREAL8(dy(ivar, is))
                tempb2 = pentel(is)*0.5d0*dyb(ivar, is)
                dytb(ivar) = dytb(ivar) + (1.0d0-pentel(is))*dyb(ivar, 
     +            is)
                min2b = (SIGN(1.0d0, dyt(ivar))+SIGN(1.0d0, dy(ivar, is)
     +            ))*tempb2
                dyb(ivar, is) = 0.D0
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y2b = min2b
                  x2b = 0.0
                ELSE
                  x2b = min2b
                  y2b = 0.0
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  dyb(ivar, is) = dyb(ivar, is) + y2b
                ELSE
                  dyb(ivar, is) = dyb(ivar, is) - y2b
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  dytb(ivar) = dytb(ivar) + x2b
                ELSE
                  dytb(ivar) = dytb(ivar) - x2b
                END IF
                CALL POPREAL8(dx(ivar, is))
                tempb1 = pentel(is)*0.5d0*dxb(ivar, is)
                dxtb(ivar) = dxtb(ivar) + (1.0d0-pentel(is))*dxb(ivar, 
     +            is)
                min1b = (SIGN(1.0d0, dxt(ivar))+SIGN(1.0d0, dx(ivar, is)
     +            ))*tempb1
                dxb(ivar, is) = 0.D0
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y1b = min1b
                  x1b = 0.0
                ELSE
                  x1b = min1b
                  y1b = 0.0
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  dxb(ivar, is) = dxb(ivar, is) + y1b
                ELSE
                  dxb(ivar, is) = dxb(ivar, is) - y1b
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  dxtb(ivar) = dxtb(ivar) + x1b
                ELSE
                  dxtb(ivar) = dxtb(ivar) - x1b
                END IF
              ENDDO
            ENDDO
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            DO ivar=5,1,-1
              dztb(ivar) = dztb(ivar) + ait*dzb(ivar, is3) + ait*dzb(
     +          ivar, is1) + ait*dzb(ivar, is2) + ait*dzb(ivar, is4)
              dytb(ivar) = dytb(ivar) + ait*dyb(ivar, is3) + ait*dyb(
     +          ivar, is1) + ait*dyb(ivar, is2) + ait*dyb(ivar, is4)
              dxtb(ivar) = dxtb(ivar) + ait*dxb(ivar, is3) + ait*dxb(
     +          ivar, is1) + ait*dxb(ivar, is2) + ait*dxb(ivar, is4)
            ENDDO
          END IF
        END IF
        DO ivar=5,1,-1
          uphb(ivar, 1) = uphb(ivar, 1) + dbz(1)*dztb(ivar)
          uphb(ivar, 2) = uphb(ivar, 2) + dbz(2)*dztb(ivar)
          uphb(ivar, 3) = uphb(ivar, 3) + dbz(3)*dztb(ivar)
          uphb(ivar, 4) = uphb(ivar, 4) + dbz(4)*dztb(ivar)
          dztb(ivar) = 0.D0
          uphb(ivar, 1) = uphb(ivar, 1) + dby(1)*dytb(ivar)
          uphb(ivar, 2) = uphb(ivar, 2) + dby(2)*dytb(ivar)
          uphb(ivar, 3) = uphb(ivar, 3) + dby(3)*dytb(ivar)
          uphb(ivar, 4) = uphb(ivar, 4) + dby(4)*dytb(ivar)
          dytb(ivar) = 0.D0
          uphb(ivar, 1) = uphb(ivar, 1) + dbx(1)*dxtb(ivar)
          uphb(ivar, 2) = uphb(ivar, 2) + dbx(2)*dxtb(ivar)
          uphb(ivar, 3) = uphb(ivar, 3) + dbx(3)*dxtb(ivar)
          uphb(ivar, 4) = uphb(ivar, 4) + dbx(4)*dxtb(ivar)
          dxtb(ivar) = 0.D0
        ENDDO
        DO k=4,1,-1
          is = nu(k, jt)
          CALL POPREAL8(uph(5, k))
          tempb = gam1*uphb(5, k)
          tempb0 = -(0.5d0*uph(1, k)*tempb)
          uab(5, is) = uab(5, is) + tempb
          uphb(1, k) = uphb(1, k) - 0.5d0*(uph(2, k)**2+uph(3, k)**2+uph
     +      (4, k)**2)*tempb
          uphb(2, k) = uphb(2, k) + 2*uph(2, k)*tempb0
          uphb(3, k) = uphb(3, k) + 2*uph(3, k)*tempb0
          uphb(4, k) = uphb(4, k) + 2*uph(4, k)*tempb0
          uphb(5, k) = 0.D0
          CALL POPREAL8(uph(4, k))
          uab(4, is) = uab(4, is) + usro*uphb(4, k)
          usrob = ua(4, is)*uphb(4, k)
          uphb(4, k) = 0.D0
          CALL POPREAL8(uph(3, k))
          uab(3, is) = uab(3, is) + usro*uphb(3, k)
          usrob = usrob + ua(3, is)*uphb(3, k)
          uphb(3, k) = 0.D0
          CALL POPREAL8(uph(2, k))
          uab(2, is) = uab(2, is) + usro*uphb(2, k)
          usrob = usrob + ua(2, is)*uphb(2, k)
          uphb(2, k) = 0.D0
          CALL POPREAL8(usro)
          uphb(1, k) = uphb(1, k) - usrob/uph(1, k)**2
          uab(1, is) = uab(1, is) + uphb(1, k)
          uphb(1, k) = 0.D0
        ENDDO
      ENDDO
      END

C  Differentiation of transpiration in reverse (adjoint) mode:
C   gradient     of useful results: psi
C   with respect to varying inputs: ua psi
      SUBROUTINE TRANSPIRATION_B(psi, psib, ctrl)
      IMPLICIT NONE
C     -----------------------------------------------------------------
C     Degres de liberte
      INTEGER nequation
      PARAMETER (nequation=5)
C
C     Maximum number of vertices 
      INTEGER nsmax
      PARAMETER (nsmax=12966)
C     Maximum number of tetraedra
      INTEGER ntmax
      PARAMETER (ntmax=65421)
C     Maximum number of boundary faces
      INTEGER nfcmax
      PARAMETER (nfcmax=7350)
C     Maximum number of edges 
      INTEGER nsgmax
      PARAMETER (nsgmax=82056)
C     Maximum number of edges attached to a mesh vertex
      INTEGER ndmax
      PARAMETER (ndmax=150)
C     Maximum number of tetraedra attached to a mesh vertex
      INTEGER nvmax
      PARAMETER (nvmax=49)
C     Allowable values for boundary vertices logical reference
      INTEGER klogmin, klogmax
      PARAMETER (klogmin=1, klogmax=30)
C     Maximum numbers of colors for the tetraedra and edges 
      INTEGER nctmax, ncamax
      PARAMETER (nctmax=710, ncamax=710)
C     Characteristic length for vectorisation
      INTEGER lvect
      PARAMETER (lvect=128)
C     Maximum length of arrays for vector operations
      INTEGER lvmax
      PARAMETER (lvmax=128)
C     -----------------------------------------------------------------
C     Maximum number of timers
      INTEGER icpmax
      PARAMETER (icpmax=21)
C     Timers definition
      REAL*8 time(icpmax)
C     Mflop rates
      REAL*8 flop(icpmax)
C
      COMMON /rtimrs/ time, flop
C
C     -----------------------------------------------------------------
C     Effective numbers of tetraedra and edges colors 
      INTEGER nca, nct
C     Data structures for the tetraedra and edges colors
      INTEGER icolt(0:nctmax), icola(0:ncamax)
      INTEGER mark(nsgmax)
C
      COMMON /icolor/ nca, nct, icolt, icola, mark
C
C     -----------------------------------------------------------------
C     Effective numbers of vertices, tetraedra, edges and 
C     boundary faces
      INTEGER ns, nt, nseg, nfac
C     Tetraedra connectivity table
      INTEGER nu(4, ntmax)
C     Boundary faces connectivity table
      INTEGER nsfac(3, nfcmax)
C     Boundary faces logical reference table
      INTEGER logfac(nfcmax), log1fac(nfcmax)
C     Boundary vertices logical reference table
      INTEGER logfr(nsmax)
C     Auxiliary table for boundary vertices logical reference 
      INTEGER fv(nsmax)
C     Boundary faces index table
      INTEGER noe1(nfcmax)
C     Effective numbers of faces for each allowable value of
C     boundary face logical reference
      INTEGER nblog(klogmin:klogmax)
C     Edges connectivity table
      INTEGER nubo(2, nsgmax)
C     Effective number of edges attached to a mesh vertex
      INTEGER ndeg(nsmax), inew(nsmax)
C     Identification of the set of edges attached to 
C     a mesh vertex
      INTEGER jaret(nsmax, ndmax)
C     Effective number of tetraedra attached to a mesh vertex
      INTEGER nbvoi(nsmax)
C     Identification of the set of tetraedra attached to 
C     a mesh vertex
      INTEGER ivoi(nsmax, nvmax)
C     Identification of the upstream and downstream tetraedra 
C     associated to an edge
      INTEGER jta(2, nsgmax)
C     Effective number of faces with a given boundary logical 
C     reference 
      INTEGER nf1, nf2, nf3, nf11
C   
      COMMON /igeom0/ ns, nt, nseg, nfac
      COMMON /igeom1/ nu, nsfac, logfac, nubo, logfr, log1fac
      COMMON /igeom2/ noe1, nblog, fv
      COMMON /igeom3/ nf1, nf2, nf3, nf11
      COMMON /igeom4/ ndeg, inew, jaret, nbvoi, ivoi, jta
C
C     Initial and instantaneous coordinates of the mesh vertices
      REAL*8 coor(3, nsmax), coco(3, nsmax)
C     Initial mesh coordinates (zz)
      REAL*8 coin(3, nsmax)
C     Control volume and tetraedra volumes
      REAL*8 vols(nsmax), volt(ntmax)
C     Control volume boundary normal components
      REAL*8 vnocl(3, nsgmax)
C     Boundary faces normal components
      REAL*8 vnfac(3, nfcmax)
C     Mean values of the normal to tetradra faces
      REAL*8 tvno(ntmax, 4, 3)
C 
      COMMON /rgeom1/ coor, coco, coin
      COMMON /rgeom2/ vols, volt, vnocl, vnfac
      COMMON /rgeom3/ tvno
C
C     -----------------------------------------------------------------
C     Physical solution
      REAL*8 ua(5, nsmax), un(5, nsmax)
      REAL*8 uab(5, nsmax)
C     Nodal fluxes (gathered convective and diffusive fluxes)
      REAL*8 ce(5, nsmax)
      REAL*8 ceb(5, nsmax)
C     Nodal gradients
      REAL*8 dx(5, nsmax), dy(5, nsmax), dz(5, nsmax)
      REAL*8 dxb(5, nsmax), dyb(5, nsmax), dzb(5, nsmax)
C     Local time steps
      REAL*8 dtl(nsmax)
C     Mesh vertices velocities
      REAL*8 xw1(nsmax), xw2(nsmax), xw3(nsmax)
C     Mean value of mesh edges and boundary faces velocities
      REAL*8 sigma(nsgmax), vnsig(nfcmax)
C     Auxiliary array used during mesh vertices based operations
      REAL*8 ce1(nsmax)
C
      COMMON /rsol1/ ua, un, ce, dx, dy, dz
      COMMON /rsol2/ dtl
      COMMON /rsol3/ xw1, xw2, xw3
      COMMON /rsol4/ sigma, vnsig
      COMMON /rsol5/ ce1
C
C     -----------------------------------------------------------------
C     Reinitialisation flag 
      INTEGER ncont
C     Local time-step strategy flag
      INTEGER iloc
C     Courant number law parameters
      REAL*8 cfl, xcfl, ycfl, zcfl, cflmax
C     Convective flux solver identifier
      INTEGER iflux
C     Spatial approximation precision order
      INTEGER nordre
C     Predictor-corrector time integration scheme flag
      INTEGER ipred
C     Maximum, initial and effective number of time steps
      INTEGER ktmax, kt0, kt
C     Flag for a viscous computation
      INTEGER ivis
C     Flag for a moving mesh computation
      INTEGER idefor
C     Flag used when deforming the mesh
      INTEGER imcas
C     Flag for explicit/implicit time integration 
C     Maximum and effective number of relaxations in the 
C     implicit phase
C     Relaxations pour l'etat-adjoint
      INTEGER nexp, nbrel, nit, nbrelpi
C     Linear system solver identifier
      INTEGER irlax
C     Flag for the type of storage used for the extra-diagonal 
C     blocks 
      INTEGER istok
C     Residual tolerance for the linear iteration (implicit phase)
      REAL*8 err
C     Maximal, initial and effective  physical time 
      REAL*8 tmax, t0, t
C     Global and maximal allowable time step
      REAL*8 dt, ddtmax
C     Residual tolerance for the non-linear iteration
      REAL*8 resf
C     Flow characteristic quantities
      REAL*8 rhoref, pref, lref, vref
C     Free stream Mach number
      REAL*8 xmach
C     Free stream quantities used to define the free stream 
C     physical states
      REAL*8 roin, uxin, uyin, uzin, pin
      REAL*8 roout, uxout, uyout, uzout, pout
C     Free stream physical states
      REAL*8 ub2(5, nfcmax), ub3(5, nfcmax)
C     Real gaz physical quantities
      REAL*8 gam, gam1
C     Reynolds and Prandtl numbers, viscosisty and temperature 
C     on the body
      REAL*8 rey, pr, xmu, tbrd
C
      INTEGER oneshot
      COMMON /ressimul/ oneshot
C
C     Nombre d'iterations de jacobi pour resoudre l'etat et l'etat-adjoint
C     en one-shot
      INTEGER nbrelos
C
      COMMON /icmflg/ ncont, iloc, ivis, idefor, ipred
      COMMON /icmflx/ iflux
      COMMON /icmgrd/ imcas
      COMMON /icmimp/ nexp, nbrel, nit, irlax, istok, nbrelos, nbrelpi
      COMMON /icmord/ nordre
C
C     Nombre d'iterations maximales pour l'etat en one-shot
      INTEGER ktmaxos
      COMMON /icmstp/ ktmax, kt0, kt, ktmaxos
C
C     Residu a atteindre pour resoudre l'etat-adjoint
      REAL*8 errjacpi
C
      COMMON /rcmstp/ tmax, t0, t, resf
      COMMON /rcmdtg/ dt, ddtmax
      COMMON /rcmimp/ err, errjacpi
      COMMON /comcfl/ cfl, xcfl, ycfl, zcfl, cflmax
      COMMON /comref/ rhoref, pref, lref, vref
      COMMON /frsmch/ xmach
      COMMON /frstr1/ roin, uxin, uyin, uzin, pin, roout, uxout, uyout, 
     +uzout, pout
      COMMON /frstr2/ ub2, ub3
      COMMON /comgam/ gam, gam1
      COMMON /comvis/ rey, pr, xmu, tbrd
C
C     -----------------------------------------------------------------
C     Frequency parameters used when printing and saving the physical 
C     solution
      INTEGER ifre, ifre1, impre, ifrel
C
      COMMON /icmedt/ ifre, ifre1, impre, ifrel
C
C     -----------------------------------------------------------------
C     Selected problem identifier
      INTEGER coefm1
C     Variables related to the piston engine geometry
      REAL*8 cadmax, cads
      REAL*8 thet0, ca, squish, rps, stroke, conrod
      REAL*8 wpist, wspa, wspe
      REAL*8 vpist(3), vspa(3), vspe(3)
      REAL*8 aoa, aoe, rfa, rfe, lma, lme
      REAL*8 hpist, hspa, hspe, hplan, href
C
      COMMON /icmpst/ coefm1
C
      COMMON /cmpst0/ cadmax, cads
      COMMON /cmpst1/ thet0, ca, squish, rps, stroke, conrod
      COMMON /cmpst2/ wpist, wspa, wspe, vpist, vspa, vspe
      COMMON /cmpst3/ aoa, aoe, rfa, rfe, lma, lme
      COMMON /cmpst4/ hpist, hspa, hspe, hplan, href
C
C     -----------------------------------------------------------------
C     Parameters and data structures related to the implicit time 
C     integration scheme
      INTEGER nsegs
      PARAMETER (nsegs=50*nsgmax)
C     Storage of the diagonal blocks
      REAL*8 diag(nsmax, 5, 5), adh1(nsmax)
C     Storage of the extra diagonal blocks
      REAL*8 stmat(nsegs)
C     Stockage des termes extra-diagonaux de la matrice
      REAL*8 zm(5, 5, 2, nsgmax)
C
      COMMON /comimp/ diag, stmat, adh1, zm
C 
C     -----------------------------------------------------------------
C     Auxiliary variables used when computing the convective fluxes
      INTEGER ient, icoef
      REAL*8 epsiim, epsiex
C
      COMMON /icmfx1/ ient, icoef
      COMMON /rcmfx1/ epsiim, epsiex
C
C     -----------------------------------------------------------------
C     Auxiliary  variables related to the moving mesh feature
C     Maximum and effective number of relaxations in the 
C     moving mesh phase
      INTEGER maxjac, kjac
C     Residual tolerance and effective residual for the linear 
C     iteration in the moving mesh phase phase
      REAL*8 rsjacf, rsjac
C     Elastic center coordinates
      REAL*8 xce, yce, zce
C     Instantaneous angle of attack
      REAL*8 tetat
C     Original coordinates of the mesh vertices
      REAL*8 xt0(nsmax), yt0(nsmax), zt0(nsmax)
C     Displacements of the mesh vertices
      REAL*8 deltx(2, nsmax), delty(2, nsmax), deltz(2, nsmax)
C     Predicted displacements of the mesh vertices
      REAL*8 deltxp(nsmax), deltyp(nsmax), deltzp(nsmax)
C
      COMMON /imomsh/ maxjac, kjac
      COMMON /mvmsh0/ rsjacf, rsjac
      COMMON /mvmsh1/ xce, yce, zce, tetat
      COMMON /mvmsh2/ xt0, yt0, zt0
      COMMON /mvmsh3/ deltx, delty, deltz, deltxp, deltyp, deltzp
C
      REAL*8 som1, dro1, som, dro
      COMMON /residus/ som1, dro1, som, dro
C
      REAL*8 omega
      COMMON /newton/ omega
C
      INTEGER diric, bound
      COMMON /boundaries/ diric, bound
C
C     NODE3D2D :Tab. de correspondance entre maillage et coque sur les noeuds
C     FACE3D2D :  "            "         "      "          "           faces
C
      INTEGER node3d2d(nsmax), face3d2d(nfcmax)
      COMMON /corres3d2d/ node3d2d, face3d2d
C
      REAL*8 pdesp(nsmax), djdw(5, nsmax), piadj(5, nsmax)
      COMMON /pression/ pdesp
      COMMON /opti/ djdw, piadj
C
      INTEGER validpsi, newton, testder, testadj, testgrad, testderw
      COMMON /verif/ validpsi, newton, testder, testadj, testgrad, 
     +testderw
C
      INTEGER itmax, itopt, ncf, npres, ncontopt, contr, defortuy
      COMMON /optimis/ itmax, itopt, ncf, npres, ncontopt, contr, 
     +defortuy
C
      INTEGER niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
      COMMON /hiera/ niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
C
      REAL*8 erreur, roopt, roinit, roos
      COMMON /resopti/ erreur, roopt, roinit, roos
C
      REAL*8 coeftrainee, teta, cltarget, cdinit, cdtarget, tetacdcl
      REAL*8 coefpres
      REAL*8 tetaxy, tetaxz, tetazy
      INTEGER*4 igicc
      COMMON /iangles/ igicc
      COMMON /calctrainchoc/ coeftrainee, cltarget, cdinit, cdtarget
      COMMON /anglesincid/ teta, tetacdcl, coefpres, tetaxy, tetaxz, 
     +tetazy
C
C     ZZ PARAMETERS:
C     ===============
C
      INTEGER intzz(30)
      COMMON /integerzz/ intzz
C     CPU time evaluation (all real*4)
      REAL*8 pmnew, pmold
      COMMON /mxmi/ pmnew, pmold
      INCLUDE 'Paramopt3D.h'
C
      INTEGER isp, is, i
      REAL*8 qt, pression, u, v, w
      REAL*8 qtb, pressionb, ub, vb, wb
      REAL*8 pi, aalpha
      REAL*8 psi(5, nsmax), ctrl(nnsp), vncoq(3, nnsp)
      REAL*8 psib(5, nsmax)
      REAL*8 ray, normalis, x, ddx
      REAL*8 tempb
      REAL*8 tempb0
      REAL*8 tempb1
      REAL*8 tempb2
      INTEGER ii2
      INTEGER ii1
      COMMON /rsol1_b/ uab, ceb, dxb, dyb, dzb
C
C*** Inclusion des conditions de transpiration : ITRANS=1
C    On ne les inclut que sur la carlingue (cas du falcon) ou bien l'aile.
C    La carlingue et l'aile sont reperes si lo1fac = 200 ou si logfac = -2.
C    Transpiration : on traite le plan de symetrie comme avant
C                       et on applique la transpiration sur la coque.
C
C**** cas ou l'on se trouve soit sur la carlingue, soit sur l'aile
C     ==> TRANSPIRATION
C
C     PSI_bords = Q(T)*(RHO,RHOU,RHOV,RHOW,E) + (0,P.nx,P.ny,P.nz,P.Q(T))
C                -->   -->  --->    -->
C     avec Q(T) = V . (NO - N(T))   NO = (nx,ny,nz) est stoque dans VNO
C                                   --->
C                                   N(T) est stoque dans VNCOQ
C
C      IF ((COEFM1.NE.10).AND.(NPRES.EQ.0)) THEN 
C   
C  Cas ou l'on ne se trouve pas sur la tuyere et ou l'on veut calculer
C  la pression desiree par incidence simulee par transpiration.
C
C*** INCIDENCE DE 3.06 DEGRES. ROTATION 2D, DANS LE PLAN (X,Y).
C
C         PI = 4.0 * ATAN(1.0)
C         AALPHA = 3.06*PI/180
C
C         DO ISP = 1,NSP
C          VNCOQ(1,ISP) = VNO(1,ISP)*COS(AALPHA)+VNO(2,ISP)*SIN(AALPHA)
C          VNCOQ(2,ISP) = -VNO(1,ISP)*SIN(AALPHA)+VNO(2,ISP)*COS(AALPHA)
C          VNCOQ(3,ISP) = VNO(3,ISP)
C         END DO
C
C      ENDIF
C
C      IF ((COEFM1.EQ.10).OR.((COEFM1.NE.10).AND.(NPRES.NE.0))) THEN
C
      CALL NORMCOQ(ctrl, vncoq)
C
C$$$         if (kt.eq.1) then
C$$$c
C$$$            print*,'Transpiration.'
C$$$         do isp = 1,nsp
C$$$            is = node2d3d(isp)
C$$$            write(6,222) isp,vncoq(1,isp),vncoq(2,isp),coor(1,is)
C$$$     $                   ,coor(2,is)
C$$$c
C$$$ 222        format(i2,1x,4(e10.3,1x))
C$$$         end do
C$$$c
C$$$         write(6,*)'  '
C$$$         write(6,*) 'Normales specifiees'
C$$$c
C$$$      endif
C
C$$$
C$$$c
C$$$               ray=2.99719
C$$$c
C$$$               DO ISP = 1,NSP
C$$$c
C$$$                  NORMALIS = 0.
C$$$                  DO I = 1,3
C$$$                     NORMALIS = NORMALIS + VNO(I,ISP)*VNO(I,ISP)
C$$$                  END DO
C$$$                  NORMALIS = SQRT(NORMALIS)
C$$$c
C$$$                  VNCOQ(1,ISP) = 0.
C$$$                  VNCOQ(2,ISP) = - NORMALIS
C$$$                  VNCOQ(3,ISP) = 0.
C$$$c
C$$$                  IS = NODE2D3D(ISP) 
C$$$                  IF (((COOR(1,IS).GE.0.).AND.(COOR(1,IS).LE.2.)).AND.
C$$$     $                 (COOR(2,IS).EQ.5.)) THEN
C$$$                     x = 0.5*coor(1,is) + 0.5
C$$$                     if (abs(x-1.0).le.0.5) then
C$$$                     ddx=x-1.0
C$$$                     vncoq(1,isp) = ddx/sqrt(ray*ray-ddx*ddx)
C$$$                     ddx = sqrt(vncoq(1,isp)**2 + 1.)
C$$$                     vncoq(1,isp) = -vncoq(1,isp)*normalis/ddx
C$$$                     vncoq(2,isp) = normalis/ddx
C$$$c
C$$$
C$$$                     endif
C$$$                  ENDIF
C$$$c
C$$$         if (kt.eq.1) then
C$$$            write(6,222) isp,vncoq(1,isp),vncoq(2,isp),coor(1,is)
C$$$     $                   ,coor(2,is)
C$$$         endif
C$$$
C$$$               END DO
C
C      ENDIF
C
C
C
C
      DO ii1=1,nsmax
        DO ii2=1,5
          uab(ii2, ii1) = 0.0
        ENDDO
      ENDDO
      DO isp=1,nsp
C
        is = node2d3d(isp)
C
        u = ua(2, is)/ua(1, is)
        v = ua(3, is)/ua(1, is)
        w = ua(4, is)/ua(1, is)
C
        qt = u*(vno(1, isp)-vncoq(1, isp)) + v*(vno(2, isp)-vncoq(2, isp
     +    )) + w*(vno(3, isp)-vncoq(3, isp))
C
        pression = gam1*(ua(5, is)-(ua(2, is)**2+ua(3, is)**2+ua(4, is)
     +    **2)/(2.d0*ua(1, is)))
C
        uab(5, is) = uab(5, is) - qt*psib(5, is)
        pressionb = -(vno(3, isp)*psib(4, is)) - vno(1, isp)*psib(2, is)
     +    - vno(2, isp)*psib(3, is) - qt*psib(5, is)
        qtb = -(ua(4, is)*psib(4, is)) - ua(2, is)*psib(2, is) - ua(1, 
     +    is)*psib(1, is) - ua(3, is)*psib(3, is) - (ua(5, is)+pression)
     +    *psib(5, is)
        uab(4, is) = uab(4, is) - qt*psib(4, is)
        uab(3, is) = uab(3, is) - qt*psib(3, is)
        uab(2, is) = uab(2, is) - qt*psib(2, is)
        uab(1, is) = uab(1, is) - qt*psib(1, is)
        tempb = -(gam1*pressionb/(2.d0*ua(1, is)))
        uab(5, is) = uab(5, is) + gam1*pressionb
        uab(2, is) = uab(2, is) + 2*ua(2, is)*tempb
        uab(3, is) = uab(3, is) + 2*ua(3, is)*tempb
        uab(4, is) = uab(4, is) + 2*ua(4, is)*tempb
        uab(1, is) = uab(1, is) - (ua(2, is)**2+ua(3, is)**2+ua(4, is)**
     +    2)*tempb/ua(1, is)
        ub = (vno(1, isp)-vncoq(1, isp))*qtb
        vb = (vno(2, isp)-vncoq(2, isp))*qtb
        wb = (vno(3, isp)-vncoq(3, isp))*qtb
        tempb0 = wb/ua(1, is)
        uab(4, is) = uab(4, is) + tempb0
        uab(1, is) = uab(1, is) - ua(4, is)*tempb0/ua(1, is)
        tempb1 = vb/ua(1, is)
        uab(3, is) = uab(3, is) + tempb1
        uab(1, is) = uab(1, is) - ua(3, is)*tempb1/ua(1, is)
        tempb2 = ub/ua(1, is)
        uab(2, is) = uab(2, is) + tempb2
        uab(1, is) = uab(1, is) - ua(2, is)*tempb2/ua(1, is)
      ENDDO
      END

C  Differentiation of vcurvm in reverse (adjoint) mode:
C   gradient     of useful results: ua ce
C   with respect to varying inputs: ua ce
      SUBROUTINE VCURVM_B(ctrlno)
      IMPLICIT NONE
C
C
C
C
C
C      stop
C     -----------------------------------------------------------------
C     Degres de liberte
      INTEGER nequation
      PARAMETER (nequation=5)
C
C     Maximum number of vertices 
      INTEGER nsmax
      PARAMETER (nsmax=12966)
C     Maximum number of tetraedra
      INTEGER ntmax
      PARAMETER (ntmax=65421)
C     Maximum number of boundary faces
      INTEGER nfcmax
      PARAMETER (nfcmax=7350)
C     Maximum number of edges 
      INTEGER nsgmax
      PARAMETER (nsgmax=82056)
C     Maximum number of edges attached to a mesh vertex
      INTEGER ndmax
      PARAMETER (ndmax=150)
C     Maximum number of tetraedra attached to a mesh vertex
      INTEGER nvmax
      PARAMETER (nvmax=49)
C     Allowable values for boundary vertices logical reference
      INTEGER klogmin, klogmax
      PARAMETER (klogmin=1, klogmax=30)
C     Maximum numbers of colors for the tetraedra and edges 
      INTEGER nctmax, ncamax
      PARAMETER (nctmax=710, ncamax=710)
C     Characteristic length for vectorisation
      INTEGER lvect
      PARAMETER (lvect=128)
C     Maximum length of arrays for vector operations
      INTEGER lvmax
      PARAMETER (lvmax=128)
C     -----------------------------------------------------------------
C     Maximum number of timers
      INTEGER icpmax
      PARAMETER (icpmax=21)
C     Timers definition
      REAL*8 time(icpmax)
C     Mflop rates
      REAL*8 flop(icpmax)
C
      COMMON /rtimrs/ time, flop
C
C     -----------------------------------------------------------------
C     Effective numbers of tetraedra and edges colors 
      INTEGER nca, nct
C     Data structures for the tetraedra and edges colors
      INTEGER icolt(0:nctmax), icola(0:ncamax)
      INTEGER mark(nsgmax)
C
      COMMON /icolor/ nca, nct, icolt, icola, mark
C
C     -----------------------------------------------------------------
C     Effective numbers of vertices, tetraedra, edges and 
C     boundary faces
      INTEGER ns, nt, nseg, nfac
C     Tetraedra connectivity table
      INTEGER nu(4, ntmax)
C     Boundary faces connectivity table
      INTEGER nsfac(3, nfcmax)
C     Boundary faces logical reference table
      INTEGER logfac(nfcmax), log1fac(nfcmax)
C     Boundary vertices logical reference table
      INTEGER logfr(nsmax)
C     Auxiliary table for boundary vertices logical reference 
      INTEGER fv(nsmax)
C     Boundary faces index table
      INTEGER noe1(nfcmax)
C     Effective numbers of faces for each allowable value of
C     boundary face logical reference
      INTEGER nblog(klogmin:klogmax)
C     Edges connectivity table
      INTEGER nubo(2, nsgmax)
C     Effective number of edges attached to a mesh vertex
      INTEGER ndeg(nsmax), inew(nsmax)
C     Identification of the set of edges attached to 
C     a mesh vertex
      INTEGER jaret(nsmax, ndmax)
C     Effective number of tetraedra attached to a mesh vertex
      INTEGER nbvoi(nsmax)
C     Identification of the set of tetraedra attached to 
C     a mesh vertex
      INTEGER ivoi(nsmax, nvmax)
C     Identification of the upstream and downstream tetraedra 
C     associated to an edge
      INTEGER jta(2, nsgmax)
C     Effective number of faces with a given boundary logical 
C     reference 
      INTEGER nf1, nf2, nf3, nf11
C   
      COMMON /igeom0/ ns, nt, nseg, nfac
      COMMON /igeom1/ nu, nsfac, logfac, nubo, logfr, log1fac
      COMMON /igeom2/ noe1, nblog, fv
      COMMON /igeom3/ nf1, nf2, nf3, nf11
      COMMON /igeom4/ ndeg, inew, jaret, nbvoi, ivoi, jta
C
C     Initial and instantaneous coordinates of the mesh vertices
      REAL*8 coor(3, nsmax), coco(3, nsmax)
C     Initial mesh coordinates (zz)
      REAL*8 coin(3, nsmax)
C     Control volume and tetraedra volumes
      REAL*8 vols(nsmax), volt(ntmax)
C     Control volume boundary normal components
      REAL*8 vnocl(3, nsgmax)
C     Boundary faces normal components
      REAL*8 vnfac(3, nfcmax)
C     Mean values of the normal to tetradra faces
      REAL*8 tvno(ntmax, 4, 3)
C 
      COMMON /rgeom1/ coor, coco, coin
      COMMON /rgeom2/ vols, volt, vnocl, vnfac
      COMMON /rgeom3/ tvno
C
C     -----------------------------------------------------------------
C     Physical solution
      REAL*8 ua(5, nsmax), un(5, nsmax)
      REAL*8 uab(5, nsmax)
C     Nodal fluxes (gathered convective and diffusive fluxes)
      REAL*8 ce(5, nsmax)
      REAL*8 ceb(5, nsmax)
C     Nodal gradients
      REAL*8 dx(5, nsmax), dy(5, nsmax), dz(5, nsmax)
      REAL*8 dxb(5, nsmax), dyb(5, nsmax), dzb(5, nsmax)
C     Local time steps
      REAL*8 dtl(nsmax)
C     Mesh vertices velocities
      REAL*8 xw1(nsmax), xw2(nsmax), xw3(nsmax)
C     Mean value of mesh edges and boundary faces velocities
      REAL*8 sigma(nsgmax), vnsig(nfcmax)
C     Auxiliary array used during mesh vertices based operations
      REAL*8 ce1(nsmax)
C
      COMMON /rsol1/ ua, un, ce, dx, dy, dz
      COMMON /rsol2/ dtl
      COMMON /rsol3/ xw1, xw2, xw3
      COMMON /rsol4/ sigma, vnsig
      COMMON /rsol5/ ce1
C
C     -----------------------------------------------------------------
C     Reinitialisation flag 
      INTEGER ncont
C     Local time-step strategy flag
      INTEGER iloc
C     Courant number law parameters
      REAL*8 cfl, xcfl, ycfl, zcfl, cflmax
C     Convective flux solver identifier
      INTEGER iflux
C     Spatial approximation precision order
      INTEGER nordre
C     Predictor-corrector time integration scheme flag
      INTEGER ipred
C     Maximum, initial and effective number of time steps
      INTEGER ktmax, kt0, kt
C     Flag for a viscous computation
      INTEGER ivis
C     Flag for a moving mesh computation
      INTEGER idefor
C     Flag used when deforming the mesh
      INTEGER imcas
C     Flag for explicit/implicit time integration 
C     Maximum and effective number of relaxations in the 
C     implicit phase
C     Relaxations pour l'etat-adjoint
      INTEGER nexp, nbrel, nit, nbrelpi
C     Linear system solver identifier
      INTEGER irlax
C     Flag for the type of storage used for the extra-diagonal 
C     blocks 
      INTEGER istok
C     Residual tolerance for the linear iteration (implicit phase)
      REAL*8 err
C     Maximal, initial and effective  physical time 
      REAL*8 tmax, t0, t
C     Global and maximal allowable time step
      REAL*8 dt, ddtmax
C     Residual tolerance for the non-linear iteration
      REAL*8 resf
C     Flow characteristic quantities
      REAL*8 rhoref, pref, lref, vref
C     Free stream Mach number
      REAL*8 xmach
C     Free stream quantities used to define the free stream 
C     physical states
      REAL*8 roin, uxin, uyin, uzin, pin
      REAL*8 roout, uxout, uyout, uzout, pout
C     Free stream physical states
      REAL*8 ub2(5, nfcmax), ub3(5, nfcmax)
C     Real gaz physical quantities
      REAL*8 gam, gam1
C     Reynolds and Prandtl numbers, viscosisty and temperature 
C     on the body
      REAL*8 rey, pr, xmu, tbrd
C
      INTEGER oneshot
      COMMON /ressimul/ oneshot
C
C     Nombre d'iterations de jacobi pour resoudre l'etat et l'etat-adjoint
C     en one-shot
      INTEGER nbrelos
C
      COMMON /icmflg/ ncont, iloc, ivis, idefor, ipred
      COMMON /icmflx/ iflux
      COMMON /icmgrd/ imcas
      COMMON /icmimp/ nexp, nbrel, nit, irlax, istok, nbrelos, nbrelpi
      COMMON /icmord/ nordre
C
C     Nombre d'iterations maximales pour l'etat en one-shot
      INTEGER ktmaxos
      COMMON /icmstp/ ktmax, kt0, kt, ktmaxos
C
C     Residu a atteindre pour resoudre l'etat-adjoint
      REAL*8 errjacpi
C
      COMMON /rcmstp/ tmax, t0, t, resf
      COMMON /rcmdtg/ dt, ddtmax
      COMMON /rcmimp/ err, errjacpi
      COMMON /comcfl/ cfl, xcfl, ycfl, zcfl, cflmax
      COMMON /comref/ rhoref, pref, lref, vref
      COMMON /frsmch/ xmach
      COMMON /frstr1/ roin, uxin, uyin, uzin, pin, roout, uxout, uyout, 
     +uzout, pout
      COMMON /frstr2/ ub2, ub3
      COMMON /comgam/ gam, gam1
      COMMON /comvis/ rey, pr, xmu, tbrd
C
C     -----------------------------------------------------------------
C     Frequency parameters used when printing and saving the physical 
C     solution
      INTEGER ifre, ifre1, impre, ifrel
C
      COMMON /icmedt/ ifre, ifre1, impre, ifrel
C
C     -----------------------------------------------------------------
C     Selected problem identifier
      INTEGER coefm1
C     Variables related to the piston engine geometry
      REAL*8 cadmax, cads
      REAL*8 thet0, ca, squish, rps, stroke, conrod
      REAL*8 wpist, wspa, wspe
      REAL*8 vpist(3), vspa(3), vspe(3)
      REAL*8 aoa, aoe, rfa, rfe, lma, lme
      REAL*8 hpist, hspa, hspe, hplan, href
C
      COMMON /icmpst/ coefm1
C
      COMMON /cmpst0/ cadmax, cads
      COMMON /cmpst1/ thet0, ca, squish, rps, stroke, conrod
      COMMON /cmpst2/ wpist, wspa, wspe, vpist, vspa, vspe
      COMMON /cmpst3/ aoa, aoe, rfa, rfe, lma, lme
      COMMON /cmpst4/ hpist, hspa, hspe, hplan, href
C
C     -----------------------------------------------------------------
C     Parameters and data structures related to the implicit time 
C     integration scheme
      INTEGER nsegs
      PARAMETER (nsegs=50*nsgmax)
C     Storage of the diagonal blocks
      REAL*8 diag(nsmax, 5, 5), adh1(nsmax)
C     Storage of the extra diagonal blocks
      REAL*8 stmat(nsegs)
C     Stockage des termes extra-diagonaux de la matrice
      REAL*8 zm(5, 5, 2, nsgmax)
C
      COMMON /comimp/ diag, stmat, adh1, zm
C 
C     -----------------------------------------------------------------
C     Auxiliary variables used when computing the convective fluxes
      INTEGER ient, icoef
      REAL*8 epsiim, epsiex
C
      COMMON /icmfx1/ ient, icoef
      COMMON /rcmfx1/ epsiim, epsiex
C
C     -----------------------------------------------------------------
C     Auxiliary  variables related to the moving mesh feature
C     Maximum and effective number of relaxations in the 
C     moving mesh phase
      INTEGER maxjac, kjac
C     Residual tolerance and effective residual for the linear 
C     iteration in the moving mesh phase phase
      REAL*8 rsjacf, rsjac
C     Elastic center coordinates
      REAL*8 xce, yce, zce
C     Instantaneous angle of attack
      REAL*8 tetat
C     Original coordinates of the mesh vertices
      REAL*8 xt0(nsmax), yt0(nsmax), zt0(nsmax)
C     Displacements of the mesh vertices
      REAL*8 deltx(2, nsmax), delty(2, nsmax), deltz(2, nsmax)
C     Predicted displacements of the mesh vertices
      REAL*8 deltxp(nsmax), deltyp(nsmax), deltzp(nsmax)
C
      COMMON /imomsh/ maxjac, kjac
      COMMON /mvmsh0/ rsjacf, rsjac
      COMMON /mvmsh1/ xce, yce, zce, tetat
      COMMON /mvmsh2/ xt0, yt0, zt0
      COMMON /mvmsh3/ deltx, delty, deltz, deltxp, deltyp, deltzp
C
      REAL*8 som1, dro1, som, dro
      COMMON /residus/ som1, dro1, som, dro
C
      REAL*8 omega
      COMMON /newton/ omega
C
      INTEGER diric, bound
      COMMON /boundaries/ diric, bound
C
C     NODE3D2D :Tab. de correspondance entre maillage et coque sur les noeuds
C     FACE3D2D :  "            "         "      "          "           faces
C
      INTEGER node3d2d(nsmax), face3d2d(nfcmax)
      COMMON /corres3d2d/ node3d2d, face3d2d
C
      REAL*8 pdesp(nsmax), djdw(5, nsmax), piadj(5, nsmax)
      COMMON /pression/ pdesp
      COMMON /opti/ djdw, piadj
C
      INTEGER validpsi, newton, testder, testadj, testgrad, testderw
      COMMON /verif/ validpsi, newton, testder, testadj, testgrad, 
     +testderw
C
      INTEGER itmax, itopt, ncf, npres, ncontopt, contr, defortuy
      COMMON /optimis/ itmax, itopt, ncf, npres, ncontopt, contr, 
     +defortuy
C
      INTEGER niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
      COMMON /hiera/ niveau, nivg, multiniv, vcyc, fvc, nbvc, nbvcfin
C
      REAL*8 erreur, roopt, roinit, roos
      COMMON /resopti/ erreur, roopt, roinit, roos
C
      REAL*8 coeftrainee, teta, cltarget, cdinit, cdtarget, tetacdcl
      REAL*8 coefpres
      REAL*8 tetaxy, tetaxz, tetazy
      INTEGER*4 igicc
      COMMON /iangles/ igicc
      COMMON /calctrainchoc/ coeftrainee, cltarget, cdinit, cdtarget
      COMMON /anglesincid/ teta, tetacdcl, coefpres, tetaxy, tetaxz, 
     +tetazy
C
C     ZZ PARAMETERS:
C     ===============
C
      INTEGER intzz(30)
      COMMON /integerzz/ intzz
C     CPU time evaluation (all real*4)
      REAL*8 pmnew, pmold
      COMMON /mxmi/ pmnew, pmold
      INCLUDE 'Paramopt3D.h'
C---------------------------------------------------------------------   
C     Local variables definition
C
      INTEGER if1, if2, if3, is1, is2, is3, ifac, is, j, ilogf
      REAL*8 rhom, rhum, rhvm, rhwm, rhem, pm, vnx, vny, vnz
      REAL*8 rhomb, rhumb, rhvmb, rhwmb, rhemb, pmb
      REAL*8 sig, pm1, pm2, pm3
      REAL*8 pm1b, pm2b, pm3b
      REAL*8 cap, capd1, capd2, capd3
      REAL*8 ro, usro, u, v, w, p, c, e, usc, unx
      REAL*8 rob, usrob, ub, vb, wb, cb, uscb, unxb
      REAL*8 vp1, vp4, vp5, vpp, vpm
      REAL*8 vp1b, vp4b, vp5b, vppb, vpmb
      REAL*8 x1, x2, x3, x4, x5, vit, c2, cc
      REAL*8 x1b, x2b, x3b, x4b, x5b, vitb, c2b, ccb
      REAL*8 xn1, xn2, ff, gg
      REAL*8 xn1b, xn2b, ffb, ggb
      REAL*8 fgp(5), fgm(5), ctrlno
      REAL*8 fgpb(5)
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC MIN
      REAL*8 tempb
      REAL*8 tempb0
      REAL*8 tempb1
      REAL*8 tempb2
      REAL*8 tempb3
      REAL*8 tempb4
      REAL*8 tempb5
      INTEGER branch
      INTEGER ii1
      COMMON /rsol1_b/ uab, ceb, dxb, dyb, dzb
C
C*** Traitement des bords glissants
C
      IF (nf1 .GT. 0) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
C
C
C
C*** Traitement des conditions a l'infini (Steger-Warming)
C
      IF (nf3 .GT. 0) THEN
        DO ii1=1,5
          fgpb(ii1) = 0.0
        ENDDO
        DO if3=1,nf3
C
          ifac = noe1(nf11+nf1+nf2+if3)
C     
          vnx = vnfac(1, ifac)
          vny = vnfac(2, ifac)
          vnz = vnfac(3, ifac)
C  
C            sig                    = vnsig(ifac)
C
          cap = SQRT(vnx*vnx + vny*vny + vnz*vnz)
          capd1 = vnx/cap
          capd2 = vny/cap
          capd3 = vnz/cap
C              
          DO j=1,3
C
C   Partie +
C
            is = nsfac(j, ifac)
C
            CALL PUSHREAL8(ro)
            ro = ua(1, is)
            usro = 1.0d0/ro
C
            CALL PUSHREAL8(u)
            u = ua(2, is)*usro
            CALL PUSHREAL8(v)
            v = ua(3, is)*usro
            CALL PUSHREAL8(w)
            w = ua(4, is)*usro
C
            vit = 0.5d0*(u*u+v*v+w*w)
            CALL PUSHREAL8(pm)
            pm = gam1*(ua(5, is)-ro*vit)
C      
            c2 = gam*pm*usro
            CALL PUSHREAL8(c)
            c = SQRT(c2)
            usc = 1.0d0/c
            unx = capd1*u + capd2*v + capd3*w
C
C
C
            x1 = ro
            x2 = ro*u
            x3 = ro*v
            x4 = ro*w
            x5 = pm/gam1 + ro*vit
            IF (cap*unx .LT. 0.0d0) THEN
              CALL PUSHREAL8(vp1)
              vp1 = 0.0d0
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(vp1)
              vp1 = cap*unx
              CALL PUSHCONTROL1B(1)
            END IF
            IF (cap*(unx+c) .LT. 0.0d0) THEN
              CALL PUSHCONTROL1B(0)
              vp4 = 0.0d0
            ELSE
              vp4 = cap*(unx+c)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (cap*(unx-c) .LT. 0.0d0) THEN
              vp5 = 0.0d0
              CALL PUSHCONTROL1B(0)
            ELSE
              vp5 = cap*(unx-c)
              CALL PUSHCONTROL1B(1)
            END IF
C
            CALL PUSHREAL8(vpp)
            vpp = vp1 - 0.5d0*(vp4+vp5)
            CALL PUSHREAL8(vpm)
            vpm = 0.5d0*(vp5-vp4)
C
            CALL PUSHREAL8(xn1)
            xn1 = gam1*usc*(-(vit*x1)+u*x2+v*x3+w*x4-x5)
C
C
C
C
C   Partie -
C
C
C
C
          ENDDO
          DO j=3,1,-1
            is = nsfac(j, ifac)
            fgpb(5) = fgpb(5) - ceb(5, is)
            fgpb(4) = fgpb(4) - ceb(4, is)
            fgpb(3) = fgpb(3) - ceb(3, is)
            fgpb(2) = fgpb(2) - ceb(2, is)
            fgpb(1) = fgpb(1) - ceb(1, is)
            usc = 1.0d0/c
            usro = 1.0d0/ro
            c2 = gam*pm*usro
            unx = capd1*u + capd2*v + capd3*w
            x1 = ro
            x2 = ro*u
            x3 = ro*v
            x4 = ro*w
            xn2 = unx*x1 - capd1*x2 - capd2*x3 - capd3*x4
            ff = usc*(vpp*xn1+vpm*xn2)
            vit = 0.5d0*(u*u+v*v+w*w)
            cc = vit + c2/gam1
            is = nsfac(j, ifac)
            x5 = pm/gam1 + ro*vit
            gg = vpm*xn1 + vpp*xn2
            vp1b = x5*fgpb(5)
            x5b = vp1*fgpb(5)
            ccb = ff*fgpb(5)
            ffb = cc*fgpb(5)
            unxb = gg*fgpb(5)
            ggb = unx*fgpb(5)
            fgpb(5) = 0.D0
            vp1b = vp1b + x4*fgpb(4)
            x4b = vp1*fgpb(4)
            wb = ff*fgpb(4)
            ffb = ffb + w*fgpb(4)
            ggb = ggb + capd3*fgpb(4)
            fgpb(4) = 0.D0
            vp1b = vp1b + x3*fgpb(3)
            x3b = vp1*fgpb(3)
            vb = ff*fgpb(3)
            ffb = ffb + v*fgpb(3)
            ggb = ggb + capd2*fgpb(3)
            fgpb(3) = 0.D0
            vp1b = vp1b + x2*fgpb(2)
            x2b = vp1*fgpb(2)
            ub = ff*fgpb(2)
            ffb = ffb + u*fgpb(2)
            ggb = ggb + capd1*fgpb(2)
            fgpb(2) = 0.D0
            ffb = ffb + fgpb(1)
            tempb5 = usc*ffb
            vpmb = xn2*tempb5 + xn1*ggb
            xn1b = vpp*tempb5 + vpm*ggb
            vppb = xn1*tempb5 + xn2*ggb
            vp1b = vp1b + vppb + x1*fgpb(1)
            xn2b = vpm*tempb5 + vpp*ggb
            uscb = gam1*(u*x2-vit*x1+v*x3+w*x4-x5)*xn1b + (vpp*xn1+vpm*
     +        xn2)*ffb
            unxb = unxb + x1*xn2b
            CALL POPREAL8(xn1)
            tempb4 = gam1*usc*xn1b
            x1b = unx*xn2b - vit*tempb4 + vp1*fgpb(1)
            fgpb(1) = 0.D0
            x2b = x2b + u*tempb4 - capd1*xn2b
            x3b = x3b + v*tempb4 - capd2*xn2b
            x4b = x4b + w*tempb4 - capd3*xn2b
            ub = ub + x2*tempb4
            vitb = -(x1*tempb4)
            vb = vb + x3*tempb4
            wb = wb + x4*tempb4
            x5b = x5b - tempb4
            CALL POPREAL8(vpm)
            vp5b = 0.5d0*vpmb - 0.5d0*vppb
            vp4b = -(0.5d0*vppb) - 0.5d0*vpmb
            CALL POPREAL8(vpp)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              cb = 0.0
            ELSE
              unxb = unxb + cap*vp5b
              cb = -(cap*vp5b)
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              unxb = unxb + cap*vp4b
              cb = cb + cap*vp4b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(vp1)
            ELSE
              CALL POPREAL8(vp1)
              unxb = unxb + cap*vp1b
            END IF
            cb = cb - uscb/c**2
            IF (c2 .EQ. 0.0) THEN
              c2b = ccb/gam1
            ELSE
              c2b = cb/(2.0*SQRT(c2)) + ccb/gam1
            END IF
            pmb = gam*usro*c2b + x5b/gam1
            CALL POPREAL8(c)
            tempb2 = gam1*pmb
            vitb = vitb + ccb - ro*tempb2 + ro*x5b
            uab(5, is) = uab(5, is) + tempb2
            tempb3 = 0.5d0*vitb
            wb = wb + capd3*unxb + 2*w*tempb3 + ro*x4b
            vb = vb + capd2*unxb + 2*v*tempb3 + ro*x3b
            ub = ub + capd1*unxb + 2*u*tempb3 + ro*x2b
            usrob = ua(4, is)*wb + ua(2, is)*ub + ua(3, is)*vb + gam*pm*
     +        c2b
            rob = w*x4b + u*x2b - vit*tempb2 - usrob/ro**2 + x1b + v*x3b
     +        + vit*x5b
            CALL POPREAL8(pm)
            CALL POPREAL8(w)
            uab(4, is) = uab(4, is) + usro*wb
            CALL POPREAL8(v)
            uab(3, is) = uab(3, is) + usro*vb
            CALL POPREAL8(u)
            uab(2, is) = uab(2, is) + usro*ub
            CALL POPREAL8(ro)
            uab(1, is) = uab(1, is) + rob
          ENDDO
        ENDDO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO if1=1,nf1
C
          ifac = noe1(nf11+if1)
C
C*** Inclusion des conditions de transpiration : ITRANS=1
C    On ne les inclut que sur la carlingue (cas du falcon) ou bien l'aile
C    ou bien la tuyere.
C    La carlingue, l'aile et la tuyere sont reperees si logfac = 200 ou 
C    si logfac = -2 ou si logfac = 7.
C    Test : Si transpiration, on traite le plan de symetrie comme avant
C                             et on applique la transpiration sur la coque.
C           Si non transpiration, on traite la coque et l'axe de symetrie
C                                 de la meme facon.
C
C*** Non transpiration :
C      Psi_bords = (0,P.nx,P.ny,P.nz,0)
C
C
          ilogf = logfac(ifac)
          IF (ilogf .EQ. -2 .AND. ctrlno .LT. 1.d-10) ilogf = 2
          IF ((itrans .EQ. 1 .AND. ilogf .NE. -2 .AND. ilogf .NE. 200 
     +        .AND. ilogf .NE. 7) .OR. itrans .EQ. 0) THEN
C
            is1 = nsfac(1, ifac)
            is2 = nsfac(2, ifac)
            is3 = nsfac(3, ifac)
C
C
C
C
C
            rhom = ua(1, is3)
            rhum = ua(2, is3)
            rhvm = ua(3, is3)
            rhwm = ua(4, is3)
C
C
C
C
C
            pm3b = -(vnfac(3, ifac)*ceb(4, is3)) - vnfac(1, ifac)*ceb(2
     +        , is3) - vnfac(2, ifac)*ceb(3, is3) - vnsig(ifac)*ceb(5, 
     +        is3)
            pm2b = -(vnfac(3, ifac)*ceb(4, is2)) - vnfac(1, ifac)*ceb(2
     +        , is2) - vnfac(2, ifac)*ceb(3, is2) - vnsig(ifac)*ceb(5, 
     +        is2)
            pm1b = -(vnfac(3, ifac)*ceb(4, is1)) - vnfac(1, ifac)*ceb(2
     +        , is1) - vnfac(2, ifac)*ceb(3, is1) - vnsig(ifac)*ceb(5, 
     +        is1)
            tempb = -(0.5d0*gam1*pm3b/rhom)
            rhemb = gam1*pm3b
            rhumb = 2*rhum*tempb
            rhvmb = 2*rhvm*tempb
            rhwmb = 2*rhwm*tempb
            rhomb = -((rhum**2+rhvm**2+rhwm**2)*tempb/rhom)
            uab(5, is3) = uab(5, is3) + rhemb
            uab(4, is3) = uab(4, is3) + rhwmb
            uab(3, is3) = uab(3, is3) + rhvmb
            uab(2, is3) = uab(2, is3) + rhumb
            uab(1, is3) = uab(1, is3) + rhomb
            rhwm = ua(4, is2)
            rhum = ua(2, is2)
            rhom = ua(1, is2)
            rhvm = ua(3, is2)
            tempb0 = -(0.5d0*gam1*pm2b/rhom)
            rhemb = gam1*pm2b
            rhumb = 2*rhum*tempb0
            rhvmb = 2*rhvm*tempb0
            rhwmb = 2*rhwm*tempb0
            rhomb = -((rhum**2+rhvm**2+rhwm**2)*tempb0/rhom)
            uab(5, is2) = uab(5, is2) + rhemb
            uab(4, is2) = uab(4, is2) + rhwmb
            uab(3, is2) = uab(3, is2) + rhvmb
            uab(2, is2) = uab(2, is2) + rhumb
            uab(1, is2) = uab(1, is2) + rhomb
            rhwm = ua(4, is1)
            rhum = ua(2, is1)
            rhom = ua(1, is1)
            rhvm = ua(3, is1)
            tempb1 = -(0.5d0*gam1*pm1b/rhom)
            rhemb = gam1*pm1b
            rhumb = 2*rhum*tempb1
            rhvmb = 2*rhvm*tempb1
            rhwmb = 2*rhwm*tempb1
            rhomb = -((rhum**2+rhvm**2+rhwm**2)*tempb1/rhom)
            uab(5, is1) = uab(5, is1) + rhemb
            uab(4, is1) = uab(4, is1) + rhwmb
            uab(3, is1) = uab(3, is1) + rhvmb
            uab(2, is1) = uab(2, is1) + rhumb
            uab(1, is1) = uab(1, is1) + rhomb
          END IF
        ENDDO
      END IF
      END

