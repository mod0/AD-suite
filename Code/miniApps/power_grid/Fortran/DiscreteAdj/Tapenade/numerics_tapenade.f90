!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
MODULE NUMERICS_B
  IMPLICIT NONE
!====================== The end of linsolve2 ===========================
! Constants
  DOUBLE PRECISION :: pi, pmax, omegab, omegas, h, d, phis, beta, c, t0&
& , tend, tf, tcl, dt, perturb
! Shared
  DOUBLE PRECISION, SAVE :: pm, quad_f, quad_b
  DOUBLE PRECISION, SAVE :: pmb, quad_fb
  PARAMETER (pi=3.141592653589793d0, pmax=2.0877d0, omegab=120.0d0*pi, &
& omegas=1d0, h=5.0d0, d=5.0d0, phis=1.0d0, beta=2.0d0, c=10000.0d0, t0=&
&   0.0d0, tend=10.0d0, tf=0.095d0, tcl=0.205d0, dt=0.01d0, perturb=&
&   1.0d0)
! Set the parameter values
! trying to evade floating pt issues
! trying to evade floating pt issues

CONTAINS
!  Differentiation of get_cost_function_and_gradient in reverse (adjoint) mode:
!   gradient     of useful results: f
!   with respect to varying inputs: pm f
!   RW status of diff variables: pm:out quad_f:(loc) f:in-zero
!
! Wrapper method which obtains the cost function and gradient
! used by the upper level optimization routine.
!
  SUBROUTINE GET_COST_FUNCTION_AND_GRADIENT_B(f, fb, g, tlen)
    IMPLICIT NONE
    INTEGER :: tlen, i
    DOUBLE PRECISION :: f
    DOUBLE PRECISION :: fb
    DOUBLE PRECISION, DIMENSION(:), INTENT(OUT) :: g
! -------------------------------------------------------------------------
! declare variables for the integration scheme - use fixed time stepping
! may be use the SAVE attribute to avoid repeated allocation/deallocation
! -------------------------------------------------------------------------
    DOUBLE PRECISION, DIMENSION(2) :: x
    DOUBLE PRECISION, DIMENSION(2) :: xb
    DOUBLE PRECISION, DIMENSION(2) :: lm
    DOUBLE PRECISION, DIMENSION(tlen) :: tout_f
    DOUBLE PRECISION, DIMENSION(tlen) :: tout_b
    DOUBLE PRECISION, DIMENSION(tlen, 2) :: yout_f
    DOUBLE PRECISION, DIMENSION(tlen, 2) :: yout_b
    INTRINSIC ASIN
! Initialize the time array.
    tout_f(1) = t0
    DO i=2,tlen-1
      tout_f(i) = tout_f(i-1) + dt
    END DO
    tout_f(tlen) = tend
! Reverse the forward time array for adjoint use.
! print the current parameter value
! print *, "pm is ", pm
! Initialize the x value
    x(1) = ASIN(perturb*pm/pmax)
    x(2) = perturb*1.0d0
! Compute the function value.
    CALL POWER_GRID_COST_FUNCTION_B(x, xb, tout_f, yout_f, f, fb)
    xb(2) = 0.D0
    IF (.NOT.(perturb*(pm/pmax) .EQ. 1.0 .OR. perturb*(pm/pmax) .EQ. (&
&       -1.0))) pmb = pmb + perturb*xb(1)/(SQRT(1.0-(perturb*(pm/pmax))&
&       **2)*pmax)
    fb = 0.D0
  END SUBROUTINE GET_COST_FUNCTION_AND_GRADIENT_B
!
! Wrapper method which obtains the cost function and gradient
! used by the upper level optimization routine.
!
  SUBROUTINE GET_COST_FUNCTION_AND_GRADIENT(f, g, tlen)
    IMPLICIT NONE
    INTEGER :: tlen, i
    DOUBLE PRECISION, INTENT(OUT) :: f
    DOUBLE PRECISION, DIMENSION(:), INTENT(OUT) :: g
! -------------------------------------------------------------------------
! declare variables for the integration scheme - use fixed time stepping
! may be use the SAVE attribute to avoid repeated allocation/deallocation
! -------------------------------------------------------------------------
    DOUBLE PRECISION, DIMENSION(2) :: x
    DOUBLE PRECISION, DIMENSION(2) :: lm
    DOUBLE PRECISION, DIMENSION(tlen) :: tout_f
    DOUBLE PRECISION, DIMENSION(tlen) :: tout_b
    DOUBLE PRECISION, DIMENSION(tlen, 2) :: yout_f
    DOUBLE PRECISION, DIMENSION(tlen, 2) :: yout_b
    INTRINSIC ASIN
! Initialize the time array.
    tout_f(1) = t0
    DO i=2,tlen-1
      tout_f(i) = tout_f(i-1) + dt
    END DO
    tout_f(tlen) = tend
! Reverse the forward time array for adjoint use.
    tout_b = tout_f(tlen:1:-1)
! print the current parameter value
! print *, "pm is ", pm
! Initialize the x value
    x(1) = ASIN(perturb*pm/pmax)
    x(2) = perturb*1.0d0
! Compute the function value.
    CALL POWER_GRID_COST_FUNCTION(x, tout_f, yout_f, f)
!>>>>>>>>>>>>> UNCOMMENT THE FOLLOWING LINES TO WRITE THE SOLUTIONS
! TO A FILE WHICH CAN LATER BE VISUALIZED USING MATLAB.
! FORWARD TIME STEPS
!    OPEN(UNIT=1, FILE='toutf')
!    WRITE (1,'(E23.16)') (tout_f(I), I = 1,TLEN)
!    CLOSE(UNIT=1)
!    ! FORWARD SOLUTION PHI
!    OPEN(UNIT=1, FILE='phi')
!    WRITE (1,'(E23.16)') (yout_f(I,1), I = 1,TLEN)
!    CLOSE(UNIT=1)
!    ! FORWARD SOLUTION OMEGA
!    OPEN(UNIT=1, FILE='omega')
!    WRITE (1,'(E23.16)') (yout_f(I,2), I = 1,TLEN)
!    CLOSE(UNIT=1)
  END SUBROUTINE GET_COST_FUNCTION_AND_GRADIENT
!  Differentiation of power_grid_cost_function in reverse (adjoint) mode:
!   gradient     of useful results: f
!   with respect to varying inputs: pm x
!
! The subroutine computes power grid cost function
! This subroutine should call the time integrator
! in the forward mode along with the mode being
! set to "FWD".
!
  SUBROUTINE POWER_GRID_COST_FUNCTION_B(x, xb, tout_f, yout_f, f, fb)
    IMPLICIT NONE
!print *, "The cost function is ", f
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: x
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: xb
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: tout_f
    DOUBLE PRECISION, DIMENSION(:, :), INTENT(OUT) :: yout_f
    DOUBLE PRECISION :: f
    DOUBLE PRECISION :: fb
    quad_fb = fb
    pmb = -fb
    CALL CRANK_NICOLSON_B(x, xb, tout_f, yout_f, 'FWD')
  END SUBROUTINE POWER_GRID_COST_FUNCTION_B
!
! The subroutine computes power grid cost function
! This subroutine should call the time integrator
! in the forward mode along with the mode being
! set to "FWD".
!
  SUBROUTINE POWER_GRID_COST_FUNCTION(x, tout_f, yout_f, f)
    IMPLICIT NONE
!print *, "The cost function is ", f
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: x
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: tout_f
    DOUBLE PRECISION, DIMENSION(:, :), INTENT(OUT) :: yout_f
    DOUBLE PRECISION, INTENT(OUT) :: f
    CALL CRANK_NICOLSON(x, tout_f, yout_f, 'FWD')
    f = -pm + quad_f
  END SUBROUTINE POWER_GRID_COST_FUNCTION
!  Differentiation of crank_nicolson in reverse (adjoint) mode:
!   gradient     of useful results: pm quad_f
!   with respect to varying inputs: pm x0
!
! Perform time integration by Crank Nicolson scheme.
!
  SUBROUTINE CRANK_NICOLSON_B(x0, x0b, tout, yout, mode, tout_traj, &
&   yout_traj)
    IMPLICIT NONE
! solve the system for dx_n
! first factorize the matrix
! call dgeco(J_n, 2, 2, ipvt, rcond, wz)
! check the conditioning of the matrix
    LOGICAL :: converged
    INTEGER :: max_conv_iter, iter, idx
    DOUBLE PRECISION :: dh, t, rcond
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: x0
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: x0b
    INTEGER, DIMENSION(2) :: ipvt
    DOUBLE PRECISION, DIMENSION(2) :: x_n_1, x_n, dx_n, f_n_1, f_n, wz
    DOUBLE PRECISION, DIMENSION(2) :: x_n_1b, x_nb, dx_nb, f_n_1b, f_nb
    DOUBLE PRECISION :: conv_err
    DOUBLE PRECISION, DIMENSION(2, 2) :: j_n, i_n
    DOUBLE PRECISION, DIMENSION(2, 2) :: j_nb
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: tout
    DOUBLE PRECISION, DIMENSION(:, :), INTENT(OUT) :: yout
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT), OPTIONAL :: tout_traj
    DOUBLE PRECISION, DIMENSION(:, :), INTENT(INOUT), OPTIONAL :: &
&   yout_traj
    CHARACTER(len=3) :: mode
    INTRINSIC SIZE
    INTEGER :: branch
    INTEGER :: ad_to
    DOUBLE PRECISION :: tempb(2)
! set the maximum number of iterations (newton) before convergence.
    max_conv_iter = 10
! get the first time step
    t = tout(1)
! set the solution at the first time step as starting value
! get the step size depending on whether we are going forward or
! backward. (FWD)
    dh = dt
! Initialize the forward quadrature value
! read the first time instant x value
    x_n_1 = x0
! start newton iteration with previous time instant value
! this assignment was initially inside the newton iteration
! loop. It has however been pulled out as it is duplicating
! the work done inside the norm check if-block
    x_n = x_n_1
! have an identity matrix handy
    CALL IDENTITY_MATRIX(i_n)
! compute all the other x values based on
! solving the nonlinear system (semi-implicit)
! using newton iteration.
    DO idx=2,SIZE(tout)
! compute the f value at the previous time instant
! and initial previous x value.
      CALL FORWARD_ODE_RHS(t, x_n_1, f_n_1)
! get the new t value
      CALL PUSHREAL8(t)
      t = tout(idx)
! set converged to false
      converged = .false.
! try to converge within max_conv_iter
      DO iter=1,max_conv_iter
        IF (.NOT.converged) THEN
! get the function value and the jacobian
! at the unconverged x and new t
          CALL FORWARD_ODE_RHS(t, x_n, f_n)
          CALL PUSHREAL8ARRAY(j_n, 2**2)
          CALL FORWARD_ODE_JAC(t, x_n, j_n)
! construct the left hand side matrix
          j_n = i_n - dh/2*j_n
! construct the right hand side vector
          CALL PUSHREAL8ARRAY(dx_n, 2)
          dx_n = x_n - x_n_1 - dh/2*(f_n+f_n_1)
!stop "Matrix is badly conditioned."
!print *,"Matrix is badly conditioned."
! solve the system
! call dgesl(J_n, 2, 2, ipvt, dx_n, 0)
          CALL PUSHREAL8ARRAY(dx_n, 2)
          CALL LINSOLVE2(j_n, dx_n, dx_n)
! update the iterate
          CALL PUSHREAL8ARRAY(x_n, 2)
          x_n = x_n - dx_n
! check whether the right hand side vector with
! new iterate has converged
! Note that moving the if block down may change
! the optimal slightly.
          CALL DNRM2(dx_n, 2, conv_err)
          IF (conv_err .LT. 1.0d-8) THEN
! print *, "Converged at t = ", t
            CALL PUSHREAL8ARRAY(x_n_1, 2)
            x_n_1 = x_n
            f_n_1 = f_n
            converged = .true.
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
    END DO
    CALL PUSHINTEGER4(idx - 1)
    x_nb = 0.D0
    CALL FORWARD_ODE_QUAD_B(t, x_n, x_nb, 'DONE')
    j_nb = 0.D0
    x_n_1b = 0.D0
    f_nb = 0.D0
    f_n_1b = 0.D0
    CALL POPINTEGER4(ad_to)
    DO idx=ad_to,2,-1
      CALL FORWARD_ODE_QUAD_B(t, x_n, x_nb, 'ITER')
      DO iter=max_conv_iter,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            f_nb = f_nb + f_n_1b
            CALL POPREAL8ARRAY(x_n_1, 2)
            x_nb = x_nb + x_n_1b
            x_n_1b = 0.D0
            f_n_1b = 0.D0
          END IF
          dx_nb = 0.D0
          CALL POPREAL8ARRAY(x_n, 2)
          dx_nb = -x_nb
          CALL POPREAL8ARRAY(dx_n, 2)
          CALL LINSOLVE2_B(j_n, j_nb, dx_n, dx_nb, dx_n, dx_nb)
          CALL POPREAL8ARRAY(dx_n, 2)
          tempb = -(dh*dx_nb/2)
          x_nb = x_nb + dx_nb
          x_n_1b = x_n_1b - dx_nb
          f_nb = f_nb + tempb
          f_n_1b = f_n_1b + tempb
          j_nb = -(dh*j_nb/2)
          CALL POPREAL8ARRAY(j_n, 2**2)
          CALL FORWARD_ODE_JAC_B(t, x_n, x_nb, j_n, j_nb)
          CALL FORWARD_ODE_RHS_B(t, x_n, x_nb, f_n, f_nb)
        END IF
      END DO
      CALL POPREAL8(t)
      CALL FORWARD_ODE_RHS_B(t, x_n_1, x_n_1b, f_n_1, f_n_1b)
    END DO
    x_n_1b = x_n_1b + x_nb
    x0b = 0.D0
    x0b = x_n_1b
    CALL FORWARD_ODE_QUAD_B(t, x0, x0b, 'INIT')
  END SUBROUTINE CRANK_NICOLSON_B
!
! Perform time integration by Crank Nicolson scheme.
!
  SUBROUTINE CRANK_NICOLSON(x0, tout, yout, mode, tout_traj, yout_traj)
    IMPLICIT NONE
! solve the system for dx_n
! first factorize the matrix
! call dgeco(J_n, 2, 2, ipvt, rcond, wz)
! check the conditioning of the matrix
    LOGICAL :: converged
    INTEGER :: max_conv_iter, iter, idx
    DOUBLE PRECISION :: dh, t, rcond
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: x0
    INTEGER, DIMENSION(2) :: ipvt
    DOUBLE PRECISION, DIMENSION(2) :: x_n_1, x_n, dx_n, f_n_1, f_n, wz
    DOUBLE PRECISION :: conv_err
    DOUBLE PRECISION, DIMENSION(2, 2) :: j_n, i_n
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT) :: tout
    DOUBLE PRECISION, DIMENSION(:, :), INTENT(OUT) :: yout
    DOUBLE PRECISION, DIMENSION(:), INTENT(INOUT), OPTIONAL :: tout_traj
    DOUBLE PRECISION, DIMENSION(:, :), INTENT(INOUT), OPTIONAL :: &
&   yout_traj
    CHARACTER(len=3) :: mode
    INTRINSIC SIZE
! set the maximum number of iterations (newton) before convergence.
    max_conv_iter = 10
! get the first time step
    t = tout(1)
! set the solution at the first time step as starting value
    yout(1, :) = x0
! get the step size depending on whether we are going forward or
! backward. (FWD)
    dh = dt
! Initialize the forward quadrature value
    CALL FORWARD_ODE_QUAD(t, x0, 'INIT')
! read the first time instant x value
    x_n_1 = x0
! start newton iteration with previous time instant value
! this assignment was initially inside the newton iteration
! loop. It has however been pulled out as it is duplicating
! the work done inside the norm check if-block
    x_n = x_n_1
! have an identity matrix handy
    CALL IDENTITY_MATRIX(i_n)
! compute all the other x values based on
! solving the nonlinear system (semi-implicit)
! using newton iteration.
    DO idx=2,SIZE(tout)
! compute the f value at the previous time instant
! and initial previous x value.
      CALL FORWARD_ODE_RHS(t, x_n_1, f_n_1)
! get the new t value
      t = tout(idx)
! set converged to false
      converged = .false.
! try to converge within max_conv_iter
      DO iter=1,max_conv_iter
        IF (.NOT.converged) THEN
! get the function value and the jacobian
! at the unconverged x and new t
          CALL FORWARD_ODE_RHS(t, x_n, f_n)
          CALL FORWARD_ODE_JAC(t, x_n, j_n)
! construct the left hand side matrix
          j_n = i_n - dh/2*j_n
! construct the right hand side vector
          dx_n = x_n - x_n_1 - dh/2*(f_n+f_n_1)
!stop "Matrix is badly conditioned."
!print *,"Matrix is badly conditioned."
! solve the system
! call dgesl(J_n, 2, 2, ipvt, dx_n, 0)
          CALL LINSOLVE2(j_n, dx_n, dx_n)
! update the iterate
          x_n = x_n - dx_n
! check whether the right hand side vector with
! new iterate has converged
! Note that moving the if block down may change
! the optimal slightly.
          CALL DNRM2(dx_n, 2, conv_err)
          IF (conv_err .LT. 1.0d-8) THEN
! print *, "Converged at t = ", t
            x_n_1 = x_n
            f_n_1 = f_n
            converged = .true.
          END IF
        END IF
      END DO
! do nothing.
! update the new value in the solution trajectory
      yout(idx, :) = x_n
! Perform quadrature along
      CALL FORWARD_ODE_QUAD(t, x_n, 'ITER')
    END DO
    CALL FORWARD_ODE_QUAD(t, x_n, 'DONE')
  END SUBROUTINE CRANK_NICOLSON
!
! Subroutine initializes the values of I to
! be a square/non-square (meaningless) identity
! matrix.
!
  SUBROUTINE IDENTITY_MATRIX(i_n)
    IMPLICIT NONE
    INTEGER :: idx, jdx
    DOUBLE PRECISION, DIMENSION(:, :), INTENT(OUT) :: i_n
    INTRINSIC SIZE
    DO idx=1,SIZE(i_n, 1)
      DO jdx=1,SIZE(i_n, 2)
        IF (idx .EQ. jdx) THEN
          i_n(idx, jdx) = 1
        ELSE
          i_n(idx, jdx) = 0
        END IF
      END DO
    END DO
  END SUBROUTINE IDENTITY_MATRIX
!  Differentiation of forward_ode_rhs in reverse (adjoint) mode:
!   gradient     of useful results: pm x y
!   with respect to varying inputs: pm x y
!
! The RHS function of the forward ODE
!
  SUBROUTINE FORWARD_ODE_RHS_B(t, x, xb, y, yb)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(INOUT) :: t
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: x
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: xb
    DOUBLE PRECISION, DIMENSION(2) :: y
    DOUBLE PRECISION, DIMENSION(2) :: yb
    DOUBLE PRECISION :: phi
    DOUBLE PRECISION :: phib
    DOUBLE PRECISION :: omega
    DOUBLE PRECISION :: omegab0
    DOUBLE PRECISION :: pmax_
    INTRINSIC SIN
    DOUBLE PRECISION :: tempb
    phi = x(1)
    IF (t .GT. tf .AND. t .LE. tcl) THEN
      pmax_ = 0.0d0
    ELSE
      pmax_ = pmax
    END IF
    tempb = omegas*yb(2)/(2*h)
    pmb = pmb + tempb
    phib = -(pmax_*COS(phi)*tempb)
    yb(2) = 0.D0
    omegab0 = omegab*yb(1) - d*tempb
    yb(1) = 0.D0
    xb(2) = xb(2) + omegab0
    xb(1) = xb(1) + phib
  END SUBROUTINE FORWARD_ODE_RHS_B
!
! The RHS function of the forward ODE
!
  SUBROUTINE FORWARD_ODE_RHS(t, x, y)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(INOUT) :: t
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: x
    DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: y
    DOUBLE PRECISION :: phi
    DOUBLE PRECISION :: omega
    DOUBLE PRECISION :: pmax_
    INTRINSIC SIN
    phi = x(1)
    omega = x(2)
    IF (t .GT. tf .AND. t .LE. tcl) THEN
      pmax_ = 0.0d0
    ELSE
      pmax_ = pmax
    END IF
    y(1) = omegab*(omega-omegas)
    y(2) = omegas*(pm-pmax_*SIN(phi)-d*(omega-omegas))/(2*h)
  END SUBROUTINE FORWARD_ODE_RHS
!  Differentiation of forward_ode_jac in reverse (adjoint) mode:
!   gradient     of useful results: j x
!   with respect to varying inputs: j x
!
! The JAC function of the forward ODE
!
  SUBROUTINE FORWARD_ODE_JAC_B(t, x, xb, j, jb)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(INOUT) :: t
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: x
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: xb
    DOUBLE PRECISION, DIMENSION(2, 2) :: j
    DOUBLE PRECISION, DIMENSION(2, 2) :: jb
    DOUBLE PRECISION :: phi
    DOUBLE PRECISION :: phib
    DOUBLE PRECISION :: omega
    DOUBLE PRECISION :: pmax_
    INTRINSIC COS
    phi = x(1)
    IF (t .GT. tf .AND. t .LE. tcl) THEN
      pmax_ = 0.0d0
    ELSE
      pmax_ = pmax
    END IF
    jb(2, 2) = 0.D0
    phib = omegas*pmax_*SIN(phi)*jb(2, 1)/(2.0d0*h)
    jb(2, 1) = 0.D0
    jb(1, 2) = 0.D0
    jb(1, 1) = 0.D0
    xb(1) = xb(1) + phib
  END SUBROUTINE FORWARD_ODE_JAC_B
!
! The JAC function of the forward ODE
!
  SUBROUTINE FORWARD_ODE_JAC(t, x, j)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(INOUT) :: t
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: x
    DOUBLE PRECISION, DIMENSION(2, 2), INTENT(OUT) :: j
    DOUBLE PRECISION :: phi
    DOUBLE PRECISION :: omega
    DOUBLE PRECISION :: pmax_
    INTRINSIC COS
    phi = x(1)
    omega = x(2)
    IF (t .GT. tf .AND. t .LE. tcl) THEN
      pmax_ = 0.0d0
    ELSE
      pmax_ = pmax
    END IF
    j(1, 1) = 0.0d0
    j(1, 2) = omegab
    j(2, 1) = -(omegas*pmax_*COS(phi)/(2.0d0*h))
    j(2, 2) = -(d*omegas/(2.0d0*h))
  END SUBROUTINE FORWARD_ODE_JAC
!  Differentiation of forward_ode_quad in reverse (adjoint) mode:
!   gradient     of useful results: quad_f prev_h x
!   with respect to varying inputs: quad_f prev_h x
!
! The subroutine to compute the quadrature in FWD mode
!
  SUBROUTINE FORWARD_ODE_QUAD_B(t, x, xb, state)
    IMPLICIT NONE
!print *, "The forward quadrature value is ", quad_f
    CHARACTER(len=4) :: state
    DOUBLE PRECISION, INTENT(INOUT) :: t
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: x
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: xb
    DOUBLE PRECISION :: phi, omega, new_h
    DOUBLE PRECISION :: phib, new_hb
    DOUBLE PRECISION, SAVE :: prev_h
    DOUBLE PRECISION, SAVE :: prev_hb
    INTRINSIC MAX
    INTEGER :: branch
    DOUBLE PRECISION :: max2b
    DOUBLE PRECISION :: max1b
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: max2
    DOUBLE PRECISION :: max1
    phi = x(1)
    IF (state .EQ. 'ITER') THEN
      IF (0.0d0 .LT. phi - phis) THEN
        max1 = phi - phis
        CALL PUSHCONTROL1B(0)
      ELSE
        max1 = 0.0d0
        CALL PUSHCONTROL1B(1)
      END IF
      tempb = dt*0.5d0*quad_fb
      new_hb = tempb + prev_hb
      prev_hb = tempb
      IF (max1 .LE. 0.0 .AND. (beta .EQ. 0.0 .OR. beta .NE. INT(beta))) &
&     THEN
        max1b = 0.0
      ELSE
        max1b = c*beta*max1**(beta-1)*new_hb
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        phib = max1b
      ELSE
        phib = 0.D0
      END IF
    ELSE IF (state .EQ. 'INIT') THEN
      IF (0.0d0 .LT. phi - phis) THEN
        max2 = phi - phis
        CALL PUSHCONTROL1B(0)
      ELSE
        max2 = 0.0d0
        CALL PUSHCONTROL1B(1)
      END IF
      IF (max2 .LE. 0.0 .AND. (beta .EQ. 0.0 .OR. beta .NE. INT(beta))) &
&     THEN
        max2b = 0.0
      ELSE
        max2b = c*beta*max2**(beta-1)*prev_hb
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        phib = max2b
      ELSE
        phib = 0.D0
      END IF
      quad_fb = 0.D0
      prev_hb = 0.D0
    ELSE
      phib = 0.D0
    END IF
    xb(1) = xb(1) + phib
  END SUBROUTINE FORWARD_ODE_QUAD_B
!
! The subroutine to compute the quadrature in FWD mode
!
  SUBROUTINE FORWARD_ODE_QUAD(t, x, state)
    IMPLICIT NONE
!print *, "The forward quadrature value is ", quad_f
    CHARACTER(len=4) :: state
    DOUBLE PRECISION, INTENT(INOUT) :: t
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: x
    DOUBLE PRECISION :: phi, omega, new_h
    DOUBLE PRECISION, SAVE :: prev_h
    INTRINSIC MAX
    DOUBLE PRECISION :: max2
    DOUBLE PRECISION :: max1
    phi = x(1)
    omega = x(2)
    IF (state .EQ. 'ITER') THEN
      IF (0.0d0 .LT. phi - phis) THEN
        max1 = phi - phis
      ELSE
        max1 = 0.0d0
      END IF
! perform trapezoidal integration using previous height
! and new height.
      new_h = c*max1**beta
      quad_f = quad_f + 0.5d0*dt*(prev_h+new_h)
! update the prev height.
      prev_h = new_h
    ELSE IF (state .EQ. 'INIT') THEN
      quad_f = 0.0d0
      IF (0.0d0 .LT. phi - phis) THEN
        max2 = phi - phis
      ELSE
        max2 = 0.0d0
      END IF
      prev_h = c*max2**beta
    END IF
  END SUBROUTINE FORWARD_ODE_QUAD
!
! Subroutine computes the 2 norm of the vector
! adapted from the original function version
! of the corresponding blas routine from
! NETLIB
!
  SUBROUTINE DNRM2(v, len_v, n)
    IMPLICIT NONE
    INTEGER :: i, len_v
    DOUBLE PRECISION :: n
    DOUBLE PRECISION, DIMENSION(len_v) :: v
    DOUBLE PRECISION :: scale
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC SQRT
    DOUBLE PRECISION :: y1
    n = 0.0d0
    scale = 0.0d0
    DO i=1,len_v
      IF (v(i) .GE. 0.) THEN
        y1 = v(i)
      ELSE
        y1 = -v(i)
      END IF
      IF (scale .LT. y1) THEN
        scale = y1
      ELSE
        scale = scale
      END IF
    END DO
    IF (scale .EQ. 0.0d0) THEN
      n = 0.0d0
    ELSE
      DO i=1,len_v
        n = n + (v(i)/scale)**2
      END DO
      n = scale*SQRT(n)
    END IF
  END SUBROUTINE DNRM2
!  Differentiation of linsolve2 in reverse (adjoint) mode:
!   gradient     of useful results: x a b
!   with respect to varying inputs: x a b
!====================== The end of dnrm2 ===============================
!
! Solve a 2x2 linear system
!
  SUBROUTINE LINSOLVE2_B(a, ab, b, bb, x, xb)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(2, 2), INTENT(INOUT) :: a
    DOUBLE PRECISION, DIMENSION(2, 2), INTENT(INOUT) :: ab
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: b
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: bb
    DOUBLE PRECISION, DIMENSION(2) :: x
    DOUBLE PRECISION, DIMENSION(2) :: xb
    DOUBLE PRECISION, DIMENSION(2) :: b_copy
    DOUBLE PRECISION, DIMENSION(2) :: b_copyb
    DOUBLE PRECISION :: b_copy_row
    DOUBLE PRECISION :: b_copy_rowb
    DOUBLE PRECISION, DIMENSION(2, 2) :: a_copy
    DOUBLE PRECISION, DIMENSION(2, 2) :: a_copyb
    DOUBLE PRECISION, DIMENSION(2) :: a_copy_row
    DOUBLE PRECISION, DIMENSION(2) :: a_copy_rowb
    DOUBLE PRECISION :: factor
    DOUBLE PRECISION :: factorb
    INTRINSIC DABS
    INTEGER :: branch
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: dabs1
    DOUBLE PRECISION :: dabs0
! Maintain a copy of A
    a_copy = a
    b_copy = b
    IF (a_copy(1, 1) .GE. 0.) THEN
      dabs0 = a_copy(1, 1)
    ELSE
      dabs0 = -a_copy(1, 1)
    END IF
    IF (a_copy(2, 1) .GE. 0.) THEN
      dabs1 = a_copy(2, 1)
    ELSE
      dabs1 = -a_copy(2, 1)
    END IF
! Swap the rows if the abs(A(1,1)) < abs(A(2,1))
! Not checking for zero coefficients
    IF (dabs0 .LT. dabs1) THEN
      a_copy_row = a_copy(2, :)
      a_copy(2, :) = a_copy(1, :)
      a_copy(1, :) = a_copy_row
      b_copy_row = b(2)
      b_copy(2) = b_copy(1)
      b_copy(1) = b_copy_row
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    factor = a_copy(2, 1)/a_copy(1, 1)
    CALL PUSHREAL8(a_copy(2, 1))
    a_copy(2, 1) = a_copy(2, 1) - factor*a_copy(1, 1)
    CALL PUSHREAL8(a_copy(2, 2))
    a_copy(2, 2) = a_copy(2, 2) - factor*a_copy(1, 2)
    CALL PUSHREAL8(b_copy(2))
    b_copy(2) = b_copy(2) - factor*b_copy(1)
    x(2) = b_copy(2)/a_copy(2, 2)
    a_copyb = 0.D0
    b_copyb = 0.D0
    tempb = xb(1)/a_copy(1, 1)
    b_copyb(1) = b_copyb(1) + tempb
    a_copyb(1, 2) = a_copyb(1, 2) - x(2)*tempb
    xb(2) = xb(2) - a_copy(1, 2)*tempb
    a_copyb(1, 1) = a_copyb(1, 1) - (b_copy(1)-a_copy(1, 2)*x(2))*tempb/&
&     a_copy(1, 1)
    xb(1) = 0.D0
    tempb0 = xb(2)/a_copy(2, 2)
    b_copyb(2) = b_copyb(2) + tempb0
    a_copyb(2, 2) = a_copyb(2, 2) - b_copy(2)*tempb0/a_copy(2, 2)
    xb(2) = 0.D0
    CALL POPREAL8(b_copy(2))
    CALL POPREAL8(a_copy(2, 2))
    factorb = -(a_copy(1, 2)*a_copyb(2, 2)) - b_copy(1)*b_copyb(2)
    b_copyb(1) = b_copyb(1) - factor*b_copyb(2)
    a_copyb(1, 2) = a_copyb(1, 2) - factor*a_copyb(2, 2)
    CALL POPREAL8(a_copy(2, 1))
    factorb = factorb - a_copy(1, 1)*a_copyb(2, 1)
    a_copyb(1, 1) = a_copyb(1, 1) - factor*a_copyb(2, 1)
    tempb1 = factorb/a_copy(1, 1)
    a_copyb(2, 1) = a_copyb(2, 1) + tempb1
    a_copyb(1, 1) = a_copyb(1, 1) - a_copy(2, 1)*tempb1/a_copy(1, 1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      b_copy_rowb = b_copyb(1)
      b_copyb(1) = b_copyb(2)
      b_copyb(2) = 0.D0
      bb(2) = bb(2) + b_copy_rowb
      a_copy_rowb = 0.D0
      a_copy_rowb = a_copyb(1, :)
      a_copyb(1, :) = a_copyb(2, :)
      a_copyb(2, :) = a_copy_rowb
    END IF
    bb = bb + b_copyb
    ab = ab + a_copyb
  END SUBROUTINE LINSOLVE2_B
!====================== The end of dnrm2 ===============================
!
! Solve a 2x2 linear system
!
  SUBROUTINE LINSOLVE2(a, b, x)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(2, 2), INTENT(INOUT) :: a
    DOUBLE PRECISION, DIMENSION(2), INTENT(INOUT) :: b
    DOUBLE PRECISION, DIMENSION(2), INTENT(OUT) :: x
    DOUBLE PRECISION, DIMENSION(2) :: b_copy
    DOUBLE PRECISION :: b_copy_row
    DOUBLE PRECISION, DIMENSION(2, 2) :: a_copy
    DOUBLE PRECISION, DIMENSION(2) :: a_copy_row
    DOUBLE PRECISION :: factor
    INTRINSIC DABS
    DOUBLE PRECISION :: dabs1
    DOUBLE PRECISION :: dabs0
! Maintain a copy of A
    a_copy = a
    b_copy = b
    IF (a_copy(1, 1) .GE. 0.) THEN
      dabs0 = a_copy(1, 1)
    ELSE
      dabs0 = -a_copy(1, 1)
    END IF
    IF (a_copy(2, 1) .GE. 0.) THEN
      dabs1 = a_copy(2, 1)
    ELSE
      dabs1 = -a_copy(2, 1)
    END IF
! Swap the rows if the abs(A(1,1)) < abs(A(2,1))
! Not checking for zero coefficients
    IF (dabs0 .LT. dabs1) THEN
      a_copy_row = a_copy(2, :)
      a_copy(2, :) = a_copy(1, :)
      a_copy(1, :) = a_copy_row
      b_copy_row = b(2)
      b_copy(2) = b_copy(1)
      b_copy(1) = b_copy_row
    END IF
    factor = a_copy(2, 1)/a_copy(1, 1)
    a_copy(2, 1) = a_copy(2, 1) - factor*a_copy(1, 1)
    a_copy(2, 2) = a_copy(2, 2) - factor*a_copy(1, 2)
    b_copy(2) = b_copy(2) - factor*b_copy(1)
    x(2) = b_copy(2)/a_copy(2, 2)
    x(1) = (b_copy(1)-a_copy(1, 2)*x(2))/a_copy(1, 1)
  END SUBROUTINE LINSOLVE2
END MODULE NUMERICS_B
