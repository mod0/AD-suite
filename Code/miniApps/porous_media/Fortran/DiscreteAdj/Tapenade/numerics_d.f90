!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
MODULE FLUID_D
  IMPLICIT NONE
! Saturation of oil cut
  DOUBLE PRECISION :: vw_, vo_, swc_, sor_
  PARAMETER (vw_=3d-4, vo_=3d-3, swc_=0.2d0, sor_=0.2d0)
! Viscosity of Water
! Viscosity of Oil
! Saturation of water cut
END MODULE FLUID_D

MODULE GRID_D
  IMPLICIT NONE
  INTEGER :: nx_, ny_, nz_, n_
  DOUBLE PRECISION :: hx_, hy_, hz_, v_
  INTEGER :: maxnx, maxny, maxnz
  PARAMETER (maxnx=60, maxny=220, maxnz=85)
  PARAMETER (nx_=10, ny_=10, nz_=2, hx_=20.0d0*0.3048d0, hy_=10.0d0*&
&   0.3048d0, hz_=2.0d0*0.3048d0, n_=nx_*ny_*nz_, v_=hx_*hy_*hz_)
! Dimension in x-direction
! Dimension in y-direction
! Dimension in z-direction
! step size in x-direction
! step size in y-direction
! step size in z-direction
! Total number of grid cells
! Volume of each grid cell
! Porosities
  DOUBLE PRECISION, DIMENSION(n_) :: por
! Permeabilities
  DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: perm
END MODULE GRID_D

MODULE MATHUTIL_D
  IMPLICIT NONE

CONTAINS
!
! Subroutine computes the 2 norm of the vector
! adapted from the original function version
! of the corresponding blas routine from
! NETLIB
!
  SUBROUTINE DNRM2(v, len_v, n)
    IMPLICIT NONE
    INTEGER :: i, len_v
    DOUBLE PRECISION :: n
    DOUBLE PRECISION, DIMENSION(len_v) :: v
    DOUBLE PRECISION :: scalein, scaleout
    INTRINSIC ABS
    INTRINSIC SQRT
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: abs0
    n = 0.0d0
    scalein = 0.0d0
    scaleout = 0.0d0
    DO i=1,len_v
      IF (v(i) .GE. 0.) THEN
        abs0 = v(i)
      ELSE
        abs0 = -v(i)
      END IF
      CALL SCALAR_MAX(scalein, abs0, scaleout)
      scalein = scaleout
    END DO
    IF (scaleout .EQ. 0.0d0) THEN
      n = 0.0d0
    ELSE
      DO i=1,len_v
        n = n + (v(i)/scaleout)**2
      END DO
      result1 = SQRT(n)
      n = scaleout*result1
    END IF
  END SUBROUTINE DNRM2
  SUBROUTINE SCALAR_MAX(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .LE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE SCALAR_MAX
END MODULE MATHUTIL_D

MODULE MATRIX_D
  USE GRID_D
  IMPLICIT NONE
! export module interface
!,disp_spmat
  PUBLIC myreshape, add_x, spmat_multiply, mymin, mymax
  PUBLIC myreshape_d, add_x_d, spmat_multiply_d, mymin_d, mymax_d
  INTERFACE MYRESHAPE
      MODULE PROCEDURE MYRESHAPE_1_2
      MODULE PROCEDURE MYRESHAPE_2_1
      MODULE PROCEDURE MYRESHAPE_1_3
      MODULE PROCEDURE MYRESHAPE_3_1
      MODULE PROCEDURE MYRESHAPE_1_4
      MODULE PROCEDURE MYRESHAPE_4_1
  END INTERFACE MYRESHAPE

  INTERFACE MYRESHAPE_D
      MODULE PROCEDURE MYRESHAPE_1_3_D
      MODULE PROCEDURE MYRESHAPE_3_1_D
      MODULE PROCEDURE MYRESHAPE_1_4_D
  END INTERFACE

  INTERFACE ADD_X
      MODULE PROCEDURE ADDX_ELEM2
      MODULE PROCEDURE ADDX_DIAGONAL2
  END INTERFACE ADD_X

  INTERFACE ADD_X_D
      MODULE PROCEDURE ADDX_ELEM2_D
      MODULE PROCEDURE ADDX_DIAGONAL2_D
  END INTERFACE

  INTERFACE SPMAT_MULTIPLY
      MODULE PROCEDURE SPMAT_MULTIPLY_DIAGONAL2
      MODULE PROCEDURE SPMAT_MULTIPLY_VECTOR2
      MODULE PROCEDURE SCALAR_MULTIPLY_SPMAT2
  END INTERFACE

  INTERFACE SPMAT_MULTIPLY_D
      MODULE PROCEDURE SPMAT_MULTIPLY_DIAGONAL2_D
      MODULE PROCEDURE SPMAT_MULTIPLY_VECTOR2_D
  END INTERFACE

  INTERFACE MYMIN
      MODULE PROCEDURE MYMIN_0_0_DOUBLE
      MODULE PROCEDURE MYMIN_1_0_DOUBLE
      MODULE PROCEDURE MYMIN_1_1_DOUBLE
  END INTERFACE MYMIN

  INTERFACE MYMIN_D
      MODULE PROCEDURE MYMIN_1_0_DOUBLE_D
  END INTERFACE

  INTERFACE MYMAX
      MODULE PROCEDURE MYMAX_0_0_DOUBLE
      MODULE PROCEDURE MYMAX_1_0_DOUBLE
      MODULE PROCEDURE MYMAX_1_1_DOUBLE
  END INTERFACE MYMAX

  INTERFACE MYMAX_D
      MODULE PROCEDURE MYMAX_1_0_DOUBLE_D
  END INTERFACE


CONTAINS
!  Differentiation of addx_elem2 in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: ivalues
!   with respect to varying inputs: ivalues
! !
! ! Display the matrix entries
! !
! subroutine disp_spmat2(innz, irow_index, irow_compressed, icol_index, ivalues, output)
!     implicit none
!     integer :: k, output
!
!     integer ::  innz
!     integer, dimension(7 * N_) :: irow_index
!     integer, dimension(7 * N_) :: icol_index
!     double precision, dimension(7 * N_) :: ivalues
!     integer, dimension(N_ + 1) :: irow_compressed
!
!     if(output /= 0) then
!         do k = 1, innz
!             write (*, '(a, i7, a, i7, a, a, e23.16)'), "(", irow_index(k), ",", &
!                         icol_index(k), ")", " ", ivalues(k)
!         end do
!         write (*, *) irow_compressed
!     end if
! end subroutine disp_spmat2
!
! Subroutine adds x to a particular element.
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix. Further the element may be non-existent. Structure of
! SPMAT has to be changed to allow arbitrary fill-ins.
!
  SUBROUTINE ADDX_ELEM2_D(innz, irow_index, irow_compressed, icol_index&
&   , ivalues, ivaluesd, x, row, col)
    IMPLICIT NONE
    DOUBLE PRECISION :: x
    INTEGER :: i, row, col
    INTEGER :: n, innz
    INTEGER, DIMENSION(7*n_) :: irow_index
    INTEGER, DIMENSION(7*n_) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivaluesd
    INTEGER, DIMENSION(n_ + 1) :: irow_compressed
    DO i=1,innz
      IF (irow_index(i) .EQ. row .AND. icol_index(i) .EQ. col) GOTO 100
    END DO
    GOTO 110
 100 ivalues(i) = ivalues(i) + x
 110 CONTINUE
  END SUBROUTINE ADDX_ELEM2_D
! !
! ! Display the matrix entries
! !
! subroutine disp_spmat2(innz, irow_index, irow_compressed, icol_index, ivalues, output)
!     implicit none
!     integer :: k, output
!
!     integer ::  innz
!     integer, dimension(7 * N_) :: irow_index
!     integer, dimension(7 * N_) :: icol_index
!     double precision, dimension(7 * N_) :: ivalues
!     integer, dimension(N_ + 1) :: irow_compressed
!
!     if(output /= 0) then
!         do k = 1, innz
!             write (*, '(a, i7, a, i7, a, a, e23.16)'), "(", irow_index(k), ",", &
!                         icol_index(k), ")", " ", ivalues(k)
!         end do
!         write (*, *) irow_compressed
!     end if
! end subroutine disp_spmat2
!
! Subroutine adds x to a particular element.
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix. Further the element may be non-existent. Structure of
! SPMAT has to be changed to allow arbitrary fill-ins.
!
  SUBROUTINE ADDX_ELEM2(innz, irow_index, irow_compressed, icol_index, &
&   ivalues, x, row, col)
    IMPLICIT NONE
    DOUBLE PRECISION :: x
    INTEGER :: i, row, col
    INTEGER :: n, innz
    INTEGER, DIMENSION(7*n_) :: irow_index
    INTEGER, DIMENSION(7*n_) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivalues
    INTEGER, DIMENSION(n_ + 1) :: irow_compressed
    DO i=1,innz
      IF (irow_index(i) .EQ. row .AND. icol_index(i) .EQ. col) THEN
        ivalues(i) = ivalues(i) + x
        GOTO 100
      END IF
    END DO
 100 CONTINUE
  END SUBROUTINE ADDX_ELEM2
!  Differentiation of addx_diagonal2 in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: ivalues
!   with respect to varying inputs: ivalues
!
! Subroutine adds x to a particular diagonal
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix
!
  SUBROUTINE ADDX_DIAGONAL2_D(innz, irow_index, irow_compressed, &
&   icol_index, ivalues, ivaluesd, x, diag)
    IMPLICIT NONE
    INTEGER :: i, diag
    DOUBLE PRECISION :: x
    INTEGER :: innz
    INTEGER, DIMENSION(7*n_) :: irow_index
    INTEGER, DIMENSION(7*n_) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivaluesd
    INTEGER, DIMENSION(n_ + 1) :: irow_compressed
    DO i=1,innz
      IF (icol_index(i) - irow_index(i) .EQ. diag) ivalues(i) = ivalues(&
&         i) + x
    END DO
  END SUBROUTINE ADDX_DIAGONAL2_D
!
! Subroutine adds x to a particular diagonal
! This subroutine is a bit flawed because at the time of construction of SPMAT
! , for other than the main diagonal, entries are skipped if they are 0.0 in
! the column matrix
!
  SUBROUTINE ADDX_DIAGONAL2(innz, irow_index, irow_compressed, &
&   icol_index, ivalues, x, diag)
    IMPLICIT NONE
    INTEGER :: i, diag
    DOUBLE PRECISION :: x
    INTEGER :: innz
    INTEGER, DIMENSION(7*n_) :: irow_index
    INTEGER, DIMENSION(7*n_) :: icol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ivalues
    INTEGER, DIMENSION(n_ + 1) :: irow_compressed
    DO i=1,innz
      IF (icol_index(i) - irow_index(i) .EQ. diag) ivalues(i) = ivalues(&
&         i) + x
    END DO
  END SUBROUTINE ADDX_DIAGONAL2
!
! Gets the diagonal on which the row, col lie
!
  SUBROUTINE GETDIAG(row, col, diag)
    IMPLICIT NONE
    INTEGER :: diag, row, col
    diag = col - row
  END SUBROUTINE GETDIAG
!
! Gets the number of elements on the diagonal for a given output
! matrix size.
!
  SUBROUTINE NOELEMS(diag, orows, ocols, n)
    IMPLICIT NONE
    INTEGER :: diag, orows, ocols, row, col, n
    INTRINSIC MIN
! first element along diagonal
    CALL FIRSTELM(diag, row, col)
    IF (diag .LT. 0) THEN
! subdiagonal read from top
! number of elements along diagonal
      n = orows - row + 1
    ELSE IF (diag .EQ. 0) THEN
      IF (orows .GT. ocols) THEN
        n = ocols
      ELSE
        n = orows
      END IF
    ELSE
! super diagonal read from bottom (possible middle)
! number of elements along diagonal
      n = ocols - col + 1
    END IF
  END SUBROUTINE NOELEMS
!
! Gets the indices of the first element on
! diagonal
!
  SUBROUTINE FIRSTELM(diag, row, col)
    IMPLICIT NONE
    INTEGER :: diag, row, col
    IF (diag .LT. 0) THEN
      row = 1 - diag
      col = 1
    ELSE IF (diag .EQ. 0) THEN
      row = 1
      col = 1
    ELSE
      row = 1
      col = 1 + diag
    END IF
  END SUBROUTINE FIRSTELM
!
! Reshape a 2d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_2_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k
    DOUBLE PRECISION, DIMENSION(:, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    k = 0
    DO j=1,SIZE(amatrix, 2)
      DO i=1,SIZE(amatrix, 1)
        k = k + 1
        bmatrix(k) = amatrix(i, j)
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_2_1
!
! Reshape a 1d matrix to a 2D array
!
  SUBROUTINE MYRESHAPE_1_2(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :) :: bmatrix
    INTRINSIC SIZE
    k = 0
    DO j=1,SIZE(bmatrix, 2)
      DO i=1,SIZE(bmatrix, 1)
        k = k + 1
        bmatrix(i, j) = amatrix(k)
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_2
!  Differentiation of myreshape_3_1 in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: bmatrix
!   with respect to varying inputs: bmatrix amatrix
!
! Reshape a 3d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_3_1_D(amatrix, amatrixd, bmatrix, bmatrixd)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrixd
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrixd
    INTRINSIC SIZE
    l = 0
    DO k=1,SIZE(amatrix, 3)
      DO j=1,SIZE(amatrix, 2)
        DO i=1,SIZE(amatrix, 1)
          l = l + 1
          bmatrixd(l) = amatrixd(i, j, k)
          bmatrix(l) = amatrix(i, j, k)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_3_1_D
!
! Reshape a 3d matrix to a 1D array
!
  SUBROUTINE MYRESHAPE_3_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    l = 0
    DO k=1,SIZE(amatrix, 3)
      DO j=1,SIZE(amatrix, 2)
        DO i=1,SIZE(amatrix, 1)
          l = l + 1
          bmatrix(l) = amatrix(i, j, k)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_3_1
!  Differentiation of myreshape_1_3 in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: bmatrix
!   with respect to varying inputs: bmatrix amatrix
!
! Reshape a 1d matrix to a 3D array
!
  SUBROUTINE MYRESHAPE_1_3_D(amatrix, amatrixd, bmatrix, bmatrixd)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: amatrixd
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrixd
    INTRINSIC SIZE
    l = 0
    DO k=1,SIZE(bmatrix, 3)
      DO j=1,SIZE(bmatrix, 2)
        DO i=1,SIZE(bmatrix, 1)
          l = l + 1
          bmatrixd(i, j, k) = amatrixd(l)
          bmatrix(i, j, k) = amatrix(l)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_3_D
!
! Reshape a 1d matrix to a 3D array
!
  SUBROUTINE MYRESHAPE_1_3(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :) :: bmatrix
    INTRINSIC SIZE
    l = 0
    DO k=1,SIZE(bmatrix, 3)
      DO j=1,SIZE(bmatrix, 2)
        DO i=1,SIZE(bmatrix, 1)
          l = l + 1
          bmatrix(i, j, k) = amatrix(l)
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_3
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_4_1(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: bmatrix
    INTRINSIC SIZE
    m = 0
    DO l=1,SIZE(amatrix, 4)
      DO k=1,SIZE(amatrix, 3)
        DO j=1,SIZE(amatrix, 2)
          DO i=1,SIZE(amatrix, 1)
            m = m + 1
            bmatrix(m) = amatrix(i, j, k, l)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_4_1
!  Differentiation of myreshape_1_4 in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: bmatrix
!   with respect to varying inputs: amatrix
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_1_4_D(amatrix, amatrixd, bmatrix, bmatrixd)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:) :: amatrixd
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrix
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrixd
    INTRINSIC SIZE
    m = 0
    bmatrixd = 0.D0
    DO l=1,SIZE(bmatrix, 4)
      DO k=1,SIZE(bmatrix, 3)
        DO j=1,SIZE(bmatrix, 2)
          DO i=1,SIZE(bmatrix, 1)
            m = m + 1
            bmatrixd(i, j, k, l) = amatrixd(m)
            bmatrix(i, j, k, l) = amatrix(m)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_4_D
!
! Reshape a 1d matrix to a 4D array
!
  SUBROUTINE MYRESHAPE_1_4(amatrix, bmatrix)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
    DOUBLE PRECISION, DIMENSION(:) :: amatrix
    DOUBLE PRECISION, DIMENSION(:, :, :, :) :: bmatrix
    INTRINSIC SIZE
    m = 0
    DO l=1,SIZE(bmatrix, 4)
      DO k=1,SIZE(bmatrix, 3)
        DO j=1,SIZE(bmatrix, 2)
          DO i=1,SIZE(bmatrix, 1)
            m = m + 1
            bmatrix(i, j, k, l) = amatrix(m)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MYRESHAPE_1_4
!  Differentiation of spmat_multiply_diagonal2 in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: rvalues
!   with respect to varying inputs: avalues dmatrix rvalues
!
! This routine pre-multiplies a diagonal matrix by a sparse matrix
!
  SUBROUTINE SPMAT_MULTIPLY_DIAGONAL2_D(annz, arow_index, &
&   arow_compressed, acol_index, avalues, avaluesd, dmatrix, dmatrixd, &
&   rnnz, rrow_index, rrow_compressed, rcol_index, rvalues, rvaluesd, &
&   order)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    CHARACTER(len=3) :: order
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesd
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n_) :: rrow_index
    INTEGER, DIMENSION(7*n_) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: rvalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: rvaluesd
    INTEGER, DIMENSION(n_ + 1) :: rrow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: dmatrix
    DOUBLE PRECISION, DIMENSION(n_) :: dmatrixd
    rnnz = annz
    rrow_compressed = arow_compressed
    IF (order .EQ. 'PRE') THEN
      DO i=1,annz
        rrow_index(i) = arow_index(i)
        rcol_index(i) = acol_index(i)
! take combination of columns of amatrix
        rvaluesd(i) = avaluesd(i)*dmatrix(acol_index(i)) + avalues(i)*&
&         dmatrixd(acol_index(i))
        rvalues(i) = avalues(i)*dmatrix(acol_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      DO i=1,annz
        rrow_index(i) = arow_index(i)
        rcol_index(i) = acol_index(i)
! take combination of rows of amatrix
        rvaluesd(i) = avaluesd(i)*dmatrix(arow_index(i)) + avalues(i)*&
&         dmatrixd(arow_index(i))
        rvalues(i) = avalues(i)*dmatrix(arow_index(i))
      END DO
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_DIAGONAL2_D
!
! This routine pre-multiplies a diagonal matrix by a sparse matrix
!
  SUBROUTINE SPMAT_MULTIPLY_DIAGONAL2(annz, arow_index, arow_compressed&
&   , acol_index, avalues, dmatrix, rnnz, rrow_index, rrow_compressed, &
&   rcol_index, rvalues, order)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    CHARACTER(len=3) :: order
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n_) :: rrow_index
    INTEGER, DIMENSION(7*n_) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: rvalues
    INTEGER, DIMENSION(n_ + 1) :: rrow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: dmatrix
    rnnz = annz
    rrow_compressed = arow_compressed
    IF (order .EQ. 'PRE') THEN
      DO i=1,annz
        rrow_index(i) = arow_index(i)
        rcol_index(i) = acol_index(i)
! take combination of columns of amatrix
        rvalues(i) = avalues(i)*dmatrix(acol_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      DO i=1,annz
        rrow_index(i) = arow_index(i)
        rcol_index(i) = acol_index(i)
! take combination of rows of amatrix
        rvalues(i) = avalues(i)*dmatrix(arow_index(i))
      END DO
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_DIAGONAL2
!  Differentiation of spmat_multiply_vector2 in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: cvector
!   with respect to varying inputs: bvector avalues
!
! The routine multiplies a vector by a sparse matrix (PRE/POST)
!
  SUBROUTINE SPMAT_MULTIPLY_VECTOR2_D(annz, arow_index, arow_compressed&
&   , acol_index, avalues, avaluesd, bvector, bvectord, cvector, &
&   cvectord, order)
    IMPLICIT NONE
    INTEGER :: i
    CHARACTER(len=3) :: order
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesd
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: bvector
    DOUBLE PRECISION, DIMENSION(n_) :: bvectord
    DOUBLE PRECISION, DIMENSION(n_) :: cvector
    DOUBLE PRECISION, DIMENSION(n_) :: cvectord
    cvector = 0.0d0
    IF (order .EQ. 'PRE') THEN
      cvectord = 0.D0
      DO i=1,annz
! Combination of the columns of amatrix
        cvectord(arow_index(i)) = cvectord(arow_index(i)) + avaluesd(i)*&
&         bvector(acol_index(i)) + avalues(i)*bvectord(acol_index(i))
        cvector(arow_index(i)) = cvector(arow_index(i)) + avalues(i)*&
&         bvector(acol_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      cvectord = 0.D0
      DO i=1,annz
! Combination of the rows of amatrix
        cvectord(acol_index(i)) = cvectord(acol_index(i)) + avaluesd(i)*&
&         bvector(arow_index(i)) + avalues(i)*bvectord(arow_index(i))
        cvector(acol_index(i)) = cvector(acol_index(i)) + avalues(i)*&
&         bvector(arow_index(i))
      END DO
    ELSE
      cvectord = 0.D0
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_VECTOR2_D
!
! The routine multiplies a vector by a sparse matrix (PRE/POST)
!
  SUBROUTINE SPMAT_MULTIPLY_VECTOR2(annz, arow_index, arow_compressed, &
&   acol_index, avalues, bvector, cvector, order)
    IMPLICIT NONE
    INTEGER :: i
    CHARACTER(len=3) :: order
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: bvector
    DOUBLE PRECISION, DIMENSION(n_) :: cvector
    cvector = 0.0d0
    IF (order .EQ. 'PRE') THEN
      DO i=1,annz
! Combination of the columns of amatrix
        cvector(arow_index(i)) = cvector(arow_index(i)) + avalues(i)*&
&         bvector(acol_index(i))
      END DO
    ELSE IF (order .EQ. 'POS') THEN
      DO i=1,annz
! Combination of the rows of amatrix
        cvector(acol_index(i)) = cvector(acol_index(i)) + avalues(i)*&
&         bvector(arow_index(i))
      END DO
    END IF
  END SUBROUTINE SPMAT_MULTIPLY_VECTOR2
!
! This routine multiplies each element of the SPMAT
! by a scalar.
! Allows amatrix to be the same as rmatrix
!
  SUBROUTINE SCALAR_MULTIPLY_SPMAT2(annz, arow_index, arow_compressed, &
&   acol_index, avalues, scalar, rnnz, rrow_index, rrow_compressed, &
&   rcol_index, rvalues)
    IMPLICIT NONE
    INTEGER :: i, alloc_err
    DOUBLE PRECISION :: scalar
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: rnnz
    INTEGER, DIMENSION(7*n_) :: rrow_index
    INTEGER, DIMENSION(7*n_) :: rcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: rvalues
    INTEGER, DIMENSION(n_ + 1) :: rrow_compressed
    rnnz = annz
    rrow_compressed = arow_compressed
    DO i=1,annz
      rrow_index(i) = arow_index(i)
      rcol_index(i) = acol_index(i)
      rvalues(i) = scalar*avalues(i)
    END DO
  END SUBROUTINE SCALAR_MULTIPLY_SPMAT2
  SUBROUTINE MYMIN_0_0_DOUBLE(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .GE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE MYMIN_0_0_DOUBLE
!  Differentiation of mymin_1_0_double in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: vectorout
!   with respect to varying inputs: vectorin
  SUBROUTINE MYMIN_1_0_DOUBLE_D(vectorin, vectorind, scalarin, vectorout&
&   , vectoroutd)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    DOUBLE PRECISION, DIMENSION(:) :: vectorind, vectoroutd
    INTRINSIC SIZE
    vectoroutd = 0.D0
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .GE. scalarin) THEN
        vectoroutd(i) = 0.D0
        vectorout(i) = scalarin
      ELSE
        vectoroutd(i) = vectorind(i)
        vectorout(i) = vectorin(i)
      END IF
    END DO
  END SUBROUTINE MYMIN_1_0_DOUBLE_D
  SUBROUTINE MYMIN_1_0_DOUBLE(vectorin, scalarin, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .GE. scalarin) THEN
        vectorout(i) = scalarin
      ELSE
        vectorout(i) = vectorin(i)
      END IF
    END DO
  END SUBROUTINE MYMIN_1_0_DOUBLE
  SUBROUTINE MYMIN_1_1_DOUBLE(vectorin1, vectorin2, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(:) :: vectorin1, vectorin2, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin1, 1)
      IF (vectorin1(i) .GE. vectorin2(i)) THEN
        vectorout(i) = vectorin2(i)
      ELSE
        vectorout(i) = vectorin1(i)
      END IF
    END DO
  END SUBROUTINE MYMIN_1_1_DOUBLE
  SUBROUTINE MYMAX_0_0_DOUBLE(scalarin1, scalarin2, scalarout)
    IMPLICIT NONE
    DOUBLE PRECISION :: scalarin1, scalarin2, scalarout
    IF (scalarin2 .LE. scalarin1) THEN
      scalarout = scalarin1
    ELSE
      scalarout = scalarin2
    END IF
  END SUBROUTINE MYMAX_0_0_DOUBLE
!  Differentiation of mymax_1_0_double in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: vectorout
!   with respect to varying inputs: vectorout vectorin
  SUBROUTINE MYMAX_1_0_DOUBLE_D(vectorin, vectorind, scalarin, vectorout&
&   , vectoroutd)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    DOUBLE PRECISION, DIMENSION(:) :: vectorind, vectoroutd
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .LE. scalarin) THEN
        vectoroutd(i) = 0.D0
        vectorout(i) = scalarin
      ELSE
        vectoroutd(i) = vectorind(i)
        vectorout(i) = vectorin(i)
      END IF
    END DO
  END SUBROUTINE MYMAX_1_0_DOUBLE_D
  SUBROUTINE MYMAX_1_0_DOUBLE(vectorin, scalarin, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION :: scalarin
    DOUBLE PRECISION, DIMENSION(:) :: vectorin, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin, 1)
      IF (vectorin(i) .LE. scalarin) THEN
        vectorout(i) = scalarin
      ELSE
        vectorout(i) = vectorin(i)
      END IF
    END DO
  END SUBROUTINE MYMAX_1_0_DOUBLE
  SUBROUTINE MYMAX_1_1_DOUBLE(vectorin1, vectorin2, vectorout)
    IMPLICIT NONE
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(:) :: vectorin1, vectorin2, vectorout
    INTRINSIC SIZE
    DO i=1,SIZE(vectorin1, 1)
      IF (vectorin1(i) .LE. vectorin2(i)) THEN
        vectorout(i) = vectorin2(i)
      ELSE
        vectorout(i) = vectorin1(i)
      END IF
    END DO
  END SUBROUTINE MYMAX_1_1_DOUBLE
END MODULE MATRIX_D

MODULE LINSOLVE_D
  USE GRID_D
  USE MATRIX_D
  USE MATHUTIL_D
  IMPLICIT NONE
! a wrapper for mgmres
!
! subroutine sparse_mgmres_method(annz, arow_index, arow_compressed, &
!                                  acol_index, avalues, b, x)
!   use mgmres
!   implicit none
!   integer :: itr_max, mr
!   double precision :: tol_abs, tol_rel
!   integer :: annz
!   integer, dimension(7 * N_) :: arow_index
!   integer, dimension(7 * N_) :: acol_index
!   double precision, dimension(7 * N_) :: avalues
!   integer, dimension(N_ + 1) :: arow_compressed
!   double precision, dimension(N_) :: b
!   double precision, dimension(N_) :: x
! 
!   tol_abs = 1.0d-8
!   tol_rel = 1.0d-8
!   itr_max = int(sqrt(N_ * 1.0)) + 1
!   mr = min(N_, 100)
! 
!   x = 0.0d0
! 
!   call mgmres_st (N_, annz, arow_index, acol_index, avalues, x, b, &
!                   itr_max, mr, tol_abs, tol_rel )
! end subroutine sparse_mgmres_method
! export solve
  PUBLIC solve
  PUBLIC solve_d
  INTERFACE SOLVE
      MODULE PROCEDURE SPARSE_SOLVE
  END INTERFACE SOLVE

  INTERFACE SOLVE_D
      MODULE PROCEDURE SPARSE_SOLVE_D
  END INTERFACE


CONTAINS
!  Differentiation of sparse_solve in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: x
!   with respect to varying inputs: avalues b
!
! Calls a specific solver - here the jacobi method
!
  SUBROUTINE SPARSE_SOLVE_D(annz, arow_index, arow_compressed, &
&   acol_index, avalues, avaluesd, b, bd, x, xd, solver_inner, &
&   solver_outer, verbose)
    IMPLICIT NONE
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: annz
    INTEGER, PARAMETER :: matdim=n_
    INTEGER, PARAMETER :: maxlen=7*matdim
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesd
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: b
    DOUBLE PRECISION, DIMENSION(n_) :: bd
    DOUBLE PRECISION, DIMENSION(n_) :: x
    DOUBLE PRECISION, DIMENSION(n_) :: xd
    CALL SPARSE_PMGMRES_METHOD_D(matdim, annz, maxlen, arow_index, &
&                        arow_compressed, acol_index, avalues, avaluesd&
&                        , b, bd, x, xd, solver_inner, solver_outer, &
&                        verbose)
  END SUBROUTINE SPARSE_SOLVE_D
!
! Calls a specific solver - here the jacobi method
!
  SUBROUTINE SPARSE_SOLVE(annz, arow_index, arow_compressed, acol_index&
&   , avalues, b, x, solver_inner, solver_outer, verbose)
    IMPLICIT NONE
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: annz
    INTEGER, PARAMETER :: matdim=n_
    INTEGER, PARAMETER :: maxlen=7*matdim
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n_) :: b
    DOUBLE PRECISION, DIMENSION(n_) :: x
    CALL SPARSE_PMGMRES_METHOD(matdim, annz, maxlen, arow_index, &
&                      arow_compressed, acol_index, avalues, b, x, &
&                      solver_inner, solver_outer, verbose)
  END SUBROUTINE SPARSE_SOLVE
!  Differentiation of sparse_dummy_method in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: x
!   with respect to varying inputs: avalues b
!
! A wrapper for pmgmres_ilu_cr
!
SUBROUTINE SPARSE_PMGMRES_METHOD_D(n, annz, alen, arow_index, arow_compressed, &
                                acol_index, avalues, avaluesd, b, bd, x, xd, solver_inner, &
                                solver_outer, verbose)
    USE MGMRES
    USE MATHUTIL_D
    IMPLICIT NONE
    INTEGER :: i, itr_max, mr
    INTEGER :: solver_inner, solver_outer
    LOGICAL :: verbose
    DOUBLE PRECISION :: tol_abs, tol_rel, nrm
    INTEGER :: n, annz, alen
    INTEGER, DIMENSION(alen) :: arow_index
    INTEGER, DIMENSION(alen) :: acol_index
    DOUBLE PRECISION, DIMENSION(alen) :: avalues
    DOUBLE PRECISION, DIMENSION(alen) :: avaluesd
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n) :: b
    DOUBLE PRECISION, DIMENSION(n) :: bd
    DOUBLE PRECISION, DIMENSION(n) :: x
    DOUBLE PRECISION, DIMENSION(n) :: xd
    DOUBLE PRECISION, DIMENSION(n) :: RHSd

    tol_abs = 1.0d-8
    tol_rel = 1.0d-8
    itr_max = solver_outer
    mr = solver_inner
    
    CALL DNRM2(b, n, nrm)
    x = 0.0d0
    IF(nrm /= 0.0d0) THEN  
      CALL PMGMRES_ILU_CR (n, annz, arow_compressed, acol_index, avalues, &
                          x, b, itr_max, mr, tol_abs, tol_rel, verbose)
    ENDIF
    
    RHSd = bd
    
    DO i = 1, annz
      RHSd(arow_index(i)) = RHSd(arow_index(i)) - avaluesd(i) * x(acol_index(i))
    END DO


    CALL DNRM2(RHSd, n, nrm)
    xd = 0.0d0  
    IF(nrm /= 0.0d0) THEN  
      CALL PMGMRES_ILU_CR (n, annz, arow_compressed, acol_index, avalues, &
                          xd, RHSd, itr_max, mr, tol_abs, tol_rel, verbose)
    ENDIF
    RETURN
END SUBROUTINE SPARSE_PMGMRES_METHOD_D
!
! A wrapper for pmgmres_ilu_cr
!
SUBROUTINE SPARSE_PMGMRES_METHOD(n, annz, alen, arow_index, arow_compressed, &
                                  acol_index, avalues, b, x, solver_inner, &
                                  solver_outer, verbose)
    USE MGMRES
    USE MATHUTIL_D
    IMPLICIT NONE
    INTEGER :: itr_max, mr
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    DOUBLE PRECISION :: tol_abs, tol_rel, nrm
    INTEGER :: n,  annz, alen
    INTEGER, DIMENSION(alen) :: arow_index
    INTEGER, DIMENSION(alen) :: acol_index
    DOUBLE PRECISION, DIMENSION(alen) :: avalues
    INTEGER, DIMENSION(n + 1) :: arow_compressed
    DOUBLE PRECISION, DIMENSION(n) :: b
    DOUBLE PRECISION, DIMENSION(n) :: x

    tol_abs = 1.0d-8
    tol_rel = 1.0d-8
    itr_max = solver_outer
    mr = solver_inner
    
    CALL DNRM2(b, n, nrm)
    x = 0.0d0   
    IF(nrm /= 0.0d0) THEN
       CALL PMGMRES_ILU_CR (n, annz, arow_compressed, acol_index, avalues, &
                  x, b, itr_max, mr, tol_abs, tol_rel, verbose)
    ENDIF
    RETURN
END SUBROUTINE SPARSE_PMGMRES_METHOD
END MODULE LINSOLVE_D

MODULE FVM_D
  USE GRID_D
  USE FLUID_D
  USE MATRIX_D
  USE LINSOLVE_D
  USE MATHUTIL_D
  IMPLICIT NONE
  INTEGER :: output
  PARAMETER (output=0)
  INTERFACE RELPERM
      MODULE PROCEDURE RELPERM_SCALAR
      MODULE PROCEDURE RELPERM_VECTOR
  END INTERFACE RELPERM

  INTERFACE RELPERM_D
      MODULE PROCEDURE RELPERM_SCALAR_D
      MODULE PROCEDURE RELPERM_VECTOR_D
  END INTERFACE


CONTAINS
!  Differentiation of newtraph in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: s
!   with respect to varying inputs: q s v
!
! Performs Newton Raphson to solve for saturations
!
  SUBROUTINE NEWTRAPH_D(s, sd, v, vd, q, qd, st, solver_inner, &
&   solver_outer, verbose)
    IMPLICIT NONE
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: i, j, it
! Maximum saturation Time Step
    INTEGER :: st
    LOGICAL :: converged
    DOUBLE PRECISION :: dt, dsn
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sd
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qd
    DOUBLE PRECISION, DIMENSION(n_) :: s_copy
    DOUBLE PRECISION, DIMENSION(n_) :: s_copyd
    DOUBLE PRECISION, DIMENSION(n_) :: s_iter_copy
    DOUBLE PRECISION, DIMENSION(n_) :: s_iter_copyd
    DOUBLE PRECISION, DIMENSION(n_) :: dtx
    DOUBLE PRECISION, DIMENSION(n_) :: dtxd
    DOUBLE PRECISION, DIMENSION(n_) :: fi
    DOUBLE PRECISION, DIMENSION(n_) :: fid
    DOUBLE PRECISION, DIMENSION(n_) :: fw
    DOUBLE PRECISION, DIMENSION(n_) :: fwd
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mwd
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: mod0
    DOUBLE PRECISION, DIMENSION(n_) :: dmw
    DOUBLE PRECISION, DIMENSION(n_) :: dmwd
    DOUBLE PRECISION, DIMENSION(n_) :: dmo
    DOUBLE PRECISION, DIMENSION(n_) :: dmod
    DOUBLE PRECISION, DIMENSION(n_) :: df
    DOUBLE PRECISION, DIMENSION(n_) :: dfd
    DOUBLE PRECISION, DIMENSION(n_) :: g
    DOUBLE PRECISION, DIMENSION(n_) :: gd
    DOUBLE PRECISION, DIMENSION(n_) :: ds
    DOUBLE PRECISION, DIMENSION(n_) :: dsd
    DOUBLE PRECISION, DIMENSION(n_) :: bfw
    DOUBLE PRECISION, DIMENSION(n_) :: bfwd
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vd
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesd
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: bnnz
    INTEGER, DIMENSION(7*n_) :: brow_index
    INTEGER, DIMENSION(7*n_) :: bcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: bvalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: bvaluesd
    INTEGER, DIMENSION(n_ + 1) :: brow_compressed
    INTEGER :: dgnnz
    INTEGER, DIMENSION(7*n_) :: dgrow_index
    INTEGER, DIMENSION(7*n_) :: dgcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: dgvalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: dgvaluesd
    INTEGER, DIMENSION(n_ + 1) :: dgrow_compressed
    INTEGER :: pwr1
! not yet converged
    converged = .false.
! Assemble system matrix
    CALL GENA_D(v, vd, q, qd, annz, arow_index, arow_compressed, &
&         acol_index, avalues, avaluesd)
! copy S over
    s_copyd = sd
    s_copy = s
! set scaling factor
    it = 0
    dgvaluesd = 0.D0
    fid = 0.D0
    bvaluesd = 0.D0
    dmod = 0.D0
    dmwd = 0.D0
    DO WHILE (.NOT.converged)
      pwr1 = 2**it
      dt = 1.0d0*st/pwr1
      dtx = dt/(v_*por)
      CALL MYMAX_1_0_DOUBLE_D(q, qd, 0.0d0, fi, fid)
      fid = dtx*fid
      fi = fi*dtx
! Matrix-diagonal matrix product
      dtxd = 0.D0
      CALL SPMAT_MULTIPLY_DIAGONAL2_D(annz, arow_index, arow_compressed&
&                               , acol_index, avalues, avaluesd, dtx, &
&                               dtxd, bnnz, brow_index, brow_compressed&
&                               , bcol_index, bvalues, bvaluesd, 'POS')
      i = 0
      pwr1 = 2**it
      DO WHILE (i .LT. pwr1)
        j = 0
        i = i + 1
        dsn = 1.0d0
        s_iter_copyd = sd
        s_iter_copy = s
        pwr1 = 2**it
        DO WHILE (dsn .GT. 1.0d-3 .AND. j .LT. 10)
          CALL RELPERM_D(s, sd, mw, mwd, mo, mod0, dmw, dmwd, dmo, dmod)
          dfd = (dmwd*(mw+mo)-dmw*(mwd+mod0))/(mw+mo)**2 - (mwd*(mw+mo)&
&           **2-mw*2*(mw+mo)*(mwd+mod0))*(dmw+dmo)/(mw+mo)**4 - mw*(dmwd&
&           +dmod)/(mw+mo)**2
          df = dmw/(mw+mo) - mw/(mw+mo)**2*(dmw+dmo)
! Matrix-diagonal matrix product
          CALL SPMAT_MULTIPLY_DIAGONAL2_D(bnnz, brow_index, &
&                                   brow_compressed, bcol_index, bvalues&
&                                   , bvaluesd, df, dfd, dgnnz, &
&                                   dgrow_index, dgrow_compressed, &
&                                   dgcol_index, dgvalues, dgvaluesd, &
&                                   'PRE')
          CALL ADDX_DIAGONAL2_D(dgnnz, dgrow_index, dgrow_compressed, &
&                         dgcol_index, dgvalues, dgvaluesd, -1.0d0, 0)
          fwd = (mwd*(mw+mo)-mw*(mwd+mod0))/(mw+mo)**2
          fw = mw/(mw+mo)
! Matrix-vector matrix product
          CALL SPMAT_MULTIPLY_VECTOR2_D(bnnz, brow_index, &
&                                 brow_compressed, bcol_index, bvalues, &
&                                 bvaluesd, fw, fwd, bfw, bfwd, 'PRE')
          gd = sd - s_iter_copyd - bfwd - fid
          g = s - s_iter_copy - bfw - fi
          CALL SOLVE_D(dgnnz, dgrow_index, dgrow_compressed, dgcol_index&
&                , dgvalues, dgvaluesd, g, gd, ds, dsd, solver_inner, &
&                solver_outer, verbose)
          sd = sd + dsd
          s = s + ds
          CALL DNRM2(ds, n_, dsn)
          j = j + 1
        END DO
        IF (dsn .GT. 1.0d-3) THEN
! Breaks out of while loop.
          i = 2**it
          sd = s_copyd
          s = s_copy
        END IF
      END DO
      IF (dsn .LT. 1.0d-3) THEN
        converged = .true.
      ELSE
        it = it + 1
      END IF
    END DO
  END SUBROUTINE NEWTRAPH_D
!
! Performs Newton Raphson to solve for saturations
!
  SUBROUTINE NEWTRAPH(s, v, q, st, solver_inner, solver_outer, verbose)
    IMPLICIT NONE
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: i, j, it
! Maximum saturation Time Step
    INTEGER :: st
    LOGICAL :: converged
    DOUBLE PRECISION :: dt, dsn
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: s_copy
    DOUBLE PRECISION, DIMENSION(n_) :: s_iter_copy
    DOUBLE PRECISION, DIMENSION(n_) :: dtx
    DOUBLE PRECISION, DIMENSION(n_) :: fi
    DOUBLE PRECISION, DIMENSION(n_) :: fw
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: dmw
    DOUBLE PRECISION, DIMENSION(n_) :: dmo
    DOUBLE PRECISION, DIMENSION(n_) :: df
    DOUBLE PRECISION, DIMENSION(n_) :: g
    DOUBLE PRECISION, DIMENSION(n_) :: ds
    DOUBLE PRECISION, DIMENSION(n_) :: bfw
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
    INTEGER :: bnnz
    INTEGER, DIMENSION(7*n_) :: brow_index
    INTEGER, DIMENSION(7*n_) :: bcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: bvalues
    INTEGER, DIMENSION(n_ + 1) :: brow_compressed
    INTEGER :: dgnnz
    INTEGER, DIMENSION(7*n_) :: dgrow_index
    INTEGER, DIMENSION(7*n_) :: dgcol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: dgvalues
    INTEGER, DIMENSION(n_ + 1) :: dgrow_compressed
    INTEGER :: pwr1
! not yet converged
    converged = .false.
! Assemble system matrix
    CALL GENA(v, q, annz, arow_index, arow_compressed, acol_index, &
&       avalues)
! copy S over
    s_copy = s
! set scaling factor
    it = 0
    DO WHILE (.NOT.converged)
      pwr1 = 2**it
      dt = 1.0d0*st/pwr1
      dtx = dt/(v_*por)
      CALL MYMAX_1_0_DOUBLE(q, 0.0d0, fi)
      fi = fi*dtx
! Matrix-diagonal matrix product
      CALL SPMAT_MULTIPLY_DIAGONAL2(annz, arow_index, arow_compressed, &
&                             acol_index, avalues, dtx, bnnz, brow_index&
&                             , brow_compressed, bcol_index, bvalues, &
&                             'POS')
      i = 0
      pwr1 = 2**it
      DO WHILE (i .LT. pwr1)
        j = 0
        i = i + 1
        dsn = 1.0d0
        s_iter_copy = s
        pwr1 = 2**it
        DO WHILE (dsn .GT. 1.0d-3 .AND. j .LT. 10)
          CALL RELPERM(s, mw, mo, dmw, dmo)
          df = dmw/(mw+mo) - mw/(mw+mo)**2*(dmw+dmo)
! Matrix-diagonal matrix product
          CALL SPMAT_MULTIPLY_DIAGONAL2(bnnz, brow_index, &
&                                 brow_compressed, bcol_index, bvalues, &
&                                 df, dgnnz, dgrow_index, &
&                                 dgrow_compressed, dgcol_index, &
&                                 dgvalues, 'PRE')
          CALL ADDX_DIAGONAL2(dgnnz, dgrow_index, dgrow_compressed, &
&                       dgcol_index, dgvalues, -1.0d0, 0)
          fw = mw/(mw+mo)
! Matrix-vector matrix product
          CALL SPMAT_MULTIPLY_VECTOR2(bnnz, brow_index, brow_compressed&
&                               , bcol_index, bvalues, fw, bfw, 'PRE')
          g = s - s_iter_copy - bfw - fi
          CALL SOLVE(dgnnz, dgrow_index, dgrow_compressed, dgcol_index, &
&              dgvalues, g, ds, solver_inner, solver_outer, verbose)
          s = s + ds
          CALL DNRM2(ds, n_, dsn)
          j = j + 1
        END DO
        IF (dsn .GT. 1.0d-3) THEN
! Breaks out of while loop.
          i = 2**it
          s = s_copy
        END IF
      END DO
      IF (dsn .LT. 1.0d-3) THEN
        converged = .true.
      ELSE
        it = it + 1
      END IF
    END DO
  END SUBROUTINE NEWTRAPH
!  Differentiation of pres in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: p v
!   with respect to varying inputs: p q s v
!
! Pressure Solver
!
  SUBROUTINE PRES_D(s, sd, q, qd, p, pd, v, vd, solver_inner, &
&   solver_outer, verbose)
    IMPLICIT NONE
!use print_active
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sd
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qd
    DOUBLE PRECISION, DIMENSION(3*n_) :: m
    DOUBLE PRECISION, DIMENSION(3*n_) :: md
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: pd
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: km
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: kmd
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vd
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mwd
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: mod0
!call RelPerm(S, M(1 : 3 * N_ : 3), M(2 : 3 * N_ : 3))
    CALL RELPERM_D(s, sd, mw, mwd, mo, mod0)
    md = 0.D0
    DO i=1,n_
      md(1+(i-1)*3) = mwd(i) + mod0(i)
      m(1+(i-1)*3) = mw(i) + mo(i)
      md(2+(i-1)*3) = md(1+(i-1)*3)
      m(2+(i-1)*3) = m(1+(i-1)*3)
      md(3+(i-1)*3) = md(1+(i-1)*3)
      m(3+(i-1)*3) = m(1+(i-1)*3)
    END DO
    CALL MYRESHAPE_1_4_D(m, md, km, kmd)
! point-wise multiply
    kmd = perm*kmd
    km = km*perm
    CALL TPFA_D(km, kmd, q, qd, p, pd, v, vd, solver_inner, solver_outer&
&         , verbose)
  END SUBROUTINE PRES_D
!
! Pressure Solver
!
  SUBROUTINE PRES(s, q, p, v, solver_inner, solver_outer, verbose)
    IMPLICIT NONE
!use print_active
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: i
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(3*n_) :: m
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: km
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mo
!call RelPerm(S, M(1 : 3 * N_ : 3), M(2 : 3 * N_ : 3))
    CALL RELPERM(s, mw, mo)
    DO i=1,n_
      m(1+(i-1)*3) = mw(i) + mo(i)
      m(2+(i-1)*3) = m(1+(i-1)*3)
      m(3+(i-1)*3) = m(1+(i-1)*3)
    END DO
    CALL MYRESHAPE_1_4(m, km)
! point-wise multiply
    km = km*perm
    CALL TPFA(km, q, p, v, solver_inner, solver_outer, verbose)
  END SUBROUTINE PRES
!  Differentiation of relperm_vector in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: dmo mo dmw mw
!   with respect to varying inputs: s dmo dmw
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_VECTOR_D(s, sd, mw, mwd, mo, mod0, dmw, dmwd, dmo, &
&   dmod)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sd
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mwd
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: mod0
    DOUBLE PRECISION, DIMENSION(n_) :: s_
    DOUBLE PRECISION, DIMENSION(n_) :: s_d
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmw
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmwd
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmo
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmod
    INTRINSIC PRESENT
! rescale saturation
    s_d = sd/(1.0d0-swc_-sor_)
    s_ = (s-swc_)/(1.0d0-swc_-sor_)
    mwd = 2*s_*s_d/vw_
    mw = s_**2/vw_
    mod0 = (-(2*(1-s_)*s_d))/vo_
    mo = (1-s_)**2/vo_
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      dmwd = 2*s_d/vw_/(1-swc_-sor_)
      dmw = 2*s_/vw_/(1-swc_-sor_)
      dmod = -((-(2*s_d))/vo_/(1-swc_-sor_))
      dmo = -(2*(1-s_)/vo_/(1-swc_-sor_))
    END IF
  END SUBROUTINE RELPERM_VECTOR_D
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_VECTOR(s, mw, mo, dmw, dmo)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: mw
    DOUBLE PRECISION, DIMENSION(n_) :: mo
    DOUBLE PRECISION, DIMENSION(n_) :: s_
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmw
    DOUBLE PRECISION, DIMENSION(n_), OPTIONAL :: dmo
    INTRINSIC PRESENT
! rescale saturation
    s_ = (s-swc_)/(1.0d0-swc_-sor_)
    mw = s_**2/vw_
    mo = (1-s_)**2/vo_
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      dmw = 2*s_/vw_/(1-swc_-sor_)
      dmo = -(2*(1-s_)/vo_/(1-swc_-sor_))
    END IF
  END SUBROUTINE RELPERM_VECTOR
!  Differentiation of relperm_scalar in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: mo mw
!   with respect to varying inputs: s
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_SCALAR_D(s, sd, mw, mwd, mo, mod0, dmw, dmo)
    IMPLICIT NONE
    DOUBLE PRECISION :: s, mw, mo, s_
    DOUBLE PRECISION :: sd, mwd, mod0, s_d
    DOUBLE PRECISION, OPTIONAL :: dmw, dmo
    INTRINSIC PRESENT
! rescale saturation
    s_d = sd/(1.0d0-swc_-sor_)
    s_ = (s-swc_)/(1.0d0-swc_-sor_)
    mwd = 2*s_*s_d/vw_
    mw = s_**2/vw_
    mod0 = (-(2*(1-s_)*s_d))/vo_
    mo = (1-s_)**2/vo_
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      dmw = 2*s_/vw_/(1-swc_-sor_)
      dmo = -(2*(1-s_)/vo_/(1-swc_-sor_))
    END IF
  END SUBROUTINE RELPERM_SCALAR_D
!
! Relative Permeabilities
!
  SUBROUTINE RELPERM_SCALAR(s, mw, mo, dmw, dmo)
    IMPLICIT NONE
    DOUBLE PRECISION :: s, mw, mo, s_
    DOUBLE PRECISION, OPTIONAL :: dmw, dmo
    INTRINSIC PRESENT
! rescale saturation
    s_ = (s-swc_)/(1.0d0-swc_-sor_)
    mw = s_**2/vw_
    mo = (1-s_)**2/vo_
    IF (PRESENT(dmo) .AND. PRESENT(dmw)) THEN
      dmw = 2*s_/vw_/(1-swc_-sor_)
      dmo = -(2*(1-s_)/vo_/(1-swc_-sor_))
    END IF
  END SUBROUTINE RELPERM_SCALAR
!  Differentiation of gena in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: avalues
!   with respect to varying inputs: q v
!
! Generate A matrix
!
  SUBROUTINE GENA_D(v, vd, q, qd, annz, arow_index, arow_compressed, &
&   acol_index, avalues, avaluesd)
    IMPLICIT NONE
    INTEGER, DIMENSION(7) :: idiags
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qd
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diags
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diagsd
    DOUBLE PRECISION, DIMENSION(n_) :: diag_tmp
    DOUBLE PRECISION, DIMENSION(n_) :: diag_tmpd
! V has an extra length
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vd
! across each x, y, z
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: vxyz
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: vxyzd
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesd
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
! initialize diags
    diags = 0.0d0
! reshape arrays first
    vxyzd = vd(3, 1:nx_, 1:ny_, 2:nz_+1)
    vxyz = v(3, 1:nx_, 1:ny_, 2:nz_+1)
    diagsd = 0.D0
    CALL MYRESHAPE_3_1_D(vxyz, vxyzd, diags(:, 1), diagsd(:, 1))
! z2
    vxyzd = vd(2, 1:nx_, 2:ny_+1, 1:nz_)
    vxyz = v(2, 1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1_D(vxyz, vxyzd, diags(:, 2), diagsd(:, 2))
! y2
    vxyzd = vd(1, 2:nx_+1, 1:ny_, 1:nz_)
    vxyz = v(1, 2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_D(vxyz, vxyzd, diags(:, 3), diagsd(:, 3))
! x2
    vxyzd = vd(1, 1:nx_, 1:ny_, 1:nz_)
    vxyz = v(1, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_D(vxyz, vxyzd, diags(:, 5), diagsd(:, 5))
! x1
    vxyzd = vd(2, 1:nx_, 1:ny_, 1:nz_)
    vxyz = v(2, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_D(vxyz, vxyzd, diags(:, 6), diagsd(:, 6))
! y1
    vxyzd = vd(3, 1:nx_, 1:ny_, 1:nz_)
    vxyz = v(3, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_D(vxyz, vxyzd, diags(:, 7), diagsd(:, 7))
! z1
    diag_tmp = 0.0d0
    diag_tmpd = 0.D0
    CALL MYMAX_1_0_DOUBLE_D(diags(:, 1), diagsd(:, 1), 0.0d0, diag_tmp, &
&                     diag_tmpd)
    diagsd(:, 1) = diag_tmpd
    diags(:, 1) = diag_tmp
    diag_tmp = 0.0d0
    diag_tmpd = 0.D0
    CALL MYMAX_1_0_DOUBLE_D(diags(:, 2), diagsd(:, 2), 0.0d0, diag_tmp, &
&                     diag_tmpd)
    diagsd(:, 2) = diag_tmpd
    diags(:, 2) = diag_tmp
    diag_tmp = 0.0d0
    diag_tmpd = 0.D0
    CALL MYMAX_1_0_DOUBLE_D(diags(:, 3), diagsd(:, 3), 0.0d0, diag_tmp, &
&                     diag_tmpd)
    diagsd(:, 3) = diag_tmpd
    diags(:, 3) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE_D(diags(:, 5), diagsd(:, 5), 0.0d0, diag_tmp, &
&                     diag_tmpd)
    diagsd(:, 5) = -diag_tmpd
    diags(:, 5) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE_D(diags(:, 6), diagsd(:, 6), 0.0d0, diag_tmp, &
&                     diag_tmpd)
    diagsd(:, 6) = -diag_tmpd
    diags(:, 6) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE_D(diags(:, 7), diagsd(:, 7), 0.0d0, diag_tmp, &
&                     diag_tmpd)
    diagsd(:, 7) = -diag_tmpd
    diags(:, 7) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE_D(q, qd, 0.0d0, diag_tmp, diag_tmpd)
    diagsd(:, 4) = diag_tmpd - diagsd(:, 5) - diagsd(:, 3) - diagsd(:, 6&
&     ) - diagsd(:, 2) - diagsd(:, 7) - diagsd(:, 1)
    diags(:, 4) = diag_tmp - diags(:, 5) - diags(:, 3) - diags(:, 6) - &
&     diags(:, 2) - diags(:, 7) - diags(:, 1)
! This can be sped up by passing 3 arrays having rows, cols and diagind
! this can be done because diag positions are fixed.
!TODO: Have a variant of spdiags which will instead of writing it in
!the spmat type, it will write it in separate arrays sent to it.
    CALL SPDIAGS_FVM_CSR_D(diags, diagsd, annz, arow_index, &
&                    arow_compressed, acol_index, avalues, avaluesd)
  END SUBROUTINE GENA_D
!
! Generate A matrix
!
  SUBROUTINE GENA(v, q, annz, arow_index, arow_compressed, acol_index, &
&   avalues)
    IMPLICIT NONE
    INTEGER, DIMENSION(7) :: idiags
    DOUBLE PRECISION, DIMENSION(n_) :: q
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diags
    DOUBLE PRECISION, DIMENSION(n_) :: diag_tmp
! V has an extra length
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
! across each x, y, z
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: vxyz
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
! initialize diags
    diags = 0.0d0
! reshape arrays first
    vxyz = v(3, 1:nx_, 1:ny_, 2:nz_+1)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 1))
! z2
    vxyz = v(2, 1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 2))
! y2
    vxyz = v(1, 2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 3))
! x2
    vxyz = v(1, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 5))
! x1
    vxyz = v(2, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 6))
! y1
    vxyz = v(3, 1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(vxyz, diags(:, 7))
! z1
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 1), 0.0d0, diag_tmp)
    diags(:, 1) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 2), 0.0d0, diag_tmp)
    diags(:, 2) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMAX_1_0_DOUBLE(diags(:, 3), 0.0d0, diag_tmp)
    diags(:, 3) = diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 5), 0.0d0, diag_tmp)
    diags(:, 5) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 6), 0.0d0, diag_tmp)
    diags(:, 6) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(diags(:, 7), 0.0d0, diag_tmp)
    diags(:, 7) = -diag_tmp
    diag_tmp = 0.0d0
    CALL MYMIN_1_0_DOUBLE(q, 0.0d0, diag_tmp)
    diags(:, 4) = diag_tmp - diags(:, 5) - diags(:, 3) - diags(:, 6) - &
&     diags(:, 2) - diags(:, 7) - diags(:, 1)
! This can be sped up by passing 3 arrays having rows, cols and diagind
! this can be done because diag positions are fixed.
!TODO: Have a variant of spdiags which will instead of writing it in
!the spmat type, it will write it in separate arrays sent to it.
    CALL SPDIAGS_FVM_CSR(diags, annz, arow_index, arow_compressed, &
&                  acol_index, avalues)
  END SUBROUTINE GENA
!  Differentiation of tpfa in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: p v
!   with respect to varying inputs: k p q v
!
! Two point flux approximation.
!
  SUBROUTINE TPFA_D(k, kd, q, qd, p, pd, v, vd, solver_inner, &
&   solver_outer, verbose)
    IMPLICIT NONE
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: i
    INTEGER, DIMENSION(7) :: idiags
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diags
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diagsd
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qd
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: pd
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: k
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: kd
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vd
! local variables
    DOUBLE PRECISION :: tx_, ty_, tz_
    DOUBLE PRECISION, DIMENSION(nx_ + 1, ny_, nz_) :: tx
    DOUBLE PRECISION, DIMENSION(nx_+1, ny_, nz_) :: txd
    DOUBLE PRECISION, DIMENSION(nx_, ny_ + 1, nz_) :: ty
    DOUBLE PRECISION, DIMENSION(nx_, ny_+1, nz_) :: tyd
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_ + 1) :: tz
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_+1) :: tzd
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: txyz
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: txyzd
! solution to the linear system
    DOUBLE PRECISION, DIMENSION(n_) :: u
    DOUBLE PRECISION, DIMENSION(n_) :: ud
! point-wise inverse of permeability
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: l
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: ld
! sparse matrix
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: avaluesd
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
! get the point-wise inverse of the permeability matrix
    ld = -(kd/k**2)
    l = 1.0d0/k
    tx_ = 2.0d0*hy_*hz_/hx_
    ty_ = 2.0d0*hx_*hz_/hy_
    tz_ = 2.0d0*hy_*hx_/hz_
    tx = 0.0d0
    ty = 0.0d0
    tz = 0.0d0
! Compute transmissibilities by averaging harmonically
    txd = 0.D0
    txd(2:nx_, 1:ny_, 1:nz_) = -(tx_*(ld(1, 1:nx_-1, 1:ny_, 1:nz_)+ld(1&
&     , 2:nx_, 1:ny_, 1:nz_))/(l(1, 1:nx_-1, 1:ny_, 1:nz_)+l(1, 2:nx_, 1&
&     :ny_, 1:nz_))**2)
    tx(2:nx_, 1:ny_, 1:nz_) = tx_/(l(1, 1:nx_-1, 1:ny_, 1:nz_)+l(1, 2:&
&     nx_, 1:ny_, 1:nz_))
    tyd = 0.D0
    tyd(1:nx_, 2:ny_, 1:nz_) = -(ty_*(ld(2, 1:nx_, 1:ny_-1, 1:nz_)+ld(2&
&     , 1:nx_, 2:ny_, 1:nz_))/(l(2, 1:nx_, 1:ny_-1, 1:nz_)+l(2, 1:nx_, 2&
&     :ny_, 1:nz_))**2)
    ty(1:nx_, 2:ny_, 1:nz_) = ty_/(l(2, 1:nx_, 1:ny_-1, 1:nz_)+l(2, 1:&
&     nx_, 2:ny_, 1:nz_))
    tzd = 0.D0
    tzd(1:nx_, 1:ny_, 2:nz_) = -(tz_*(ld(3, 1:nx_, 1:ny_, 1:nz_-1)+ld(3&
&     , 1:nx_, 1:ny_, 2:nz_))/(l(3, 1:nx_, 1:ny_, 1:nz_-1)+l(3, 1:nx_, 1&
&     :ny_, 2:nz_))**2)
    tz(1:nx_, 1:ny_, 2:nz_) = tz_/(l(3, 1:nx_, 1:ny_, 1:nz_-1)+l(3, 1:&
&     nx_, 1:ny_, 2:nz_))
! initialize diags
    diags = 0.0d0
    txyzd = -txd(1:nx_, 1:ny_, 1:nz_)
    txyz = -tx(1:nx_, 1:ny_, 1:nz_)
    diagsd = 0.D0
    CALL MYRESHAPE_3_1_D(txyz, txyzd, diags(:, 5), diagsd(:, 5))
! -x1
    txyzd = -tyd(1:nx_, 1:ny_, 1:nz_)
    txyz = -ty(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_D(txyz, txyzd, diags(:, 6), diagsd(:, 6))
! -y1
    txyzd = -tzd(1:nx_, 1:ny_, 1:nz_)
    txyz = -tz(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_D(txyz, txyzd, diags(:, 7), diagsd(:, 7))
! -z1
    txyzd = -txd(2:nx_+1, 1:ny_, 1:nz_)
    txyz = -tx(2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1_D(txyz, txyzd, diags(:, 3), diagsd(:, 3))
! -x2
    txyzd = -tyd(1:nx_, 2:ny_+1, 1:nz_)
    txyz = -ty(1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1_D(txyz, txyzd, diags(:, 2), diagsd(:, 2))
! -y2
    txyzd = -tzd(1:nx_, 1:ny_, 2:nz_+1)
    txyz = -tz(1:nx_, 1:ny_, 2:nz_+1)
    CALL MYRESHAPE_3_1_D(txyz, txyzd, diags(:, 1), diagsd(:, 1))
! -z2
! Assemble discretization matrix
    diagsd(:, 4) = -(diagsd(:, 1)+diagsd(:, 2)+diagsd(:, 3)+diagsd(:, 5)&
&     +diagsd(:, 6)+diagsd(:, 7))
    diags(:, 4) = -(diags(:, 1)+diags(:, 2)+diags(:, 3)+diags(:, 5)+&
&     diags(:, 6)+diags(:, 7))
!TODO: Have a variant of spdiags which will instead of writing it in
!the spmat type, it will write it in separate arrays sent to it.
    CALL SPDIAGS_FVM_CSR_D(diags, diagsd, annz, arow_index, &
&                    arow_compressed, acol_index, avalues, avaluesd)
! ! Increment the 1,1 element of A
    CALL ADDX_ELEM2_D(annz, arow_index, arow_compressed, acol_index, &
&               avalues, avaluesd, perm(1, 1, 1, 1) + perm(2, 1, 1, 1) +&
&               perm(3, 1, 1, 1), 1, 1)
! Fix the pressure at the inlets
!     do i = 1,annz
!       if(arow_index(i) < Nx_ * Ny_ .and. mod(arow_index(i), Ny_) == 1) then
!           if(arow_index(i) == acol_index(i)) then
!             avalues(i) = 1
!           else
!             avalues(i) = 0
!           endif
!       endif
!     enddo
! solve the linear system
! Pass the rows_index, cols_index, values separately.
    CALL SOLVE_D(annz, arow_index, arow_compressed, acol_index, avalues&
&          , avaluesd, q, qd, u, ud, solver_inner, solver_outer, verbose&
&         )
! reshape the solution
    CALL MYRESHAPE_1_3_D(u, ud, p, pd)
! V.x
    vd(1, 2:nx_, 1:ny_, 1:nz_) = (pd(1:nx_-1, :, :)-pd(2:nx_, :, :))*tx(&
&     2:nx_, :, :) + (p(1:nx_-1, :, :)-p(2:nx_, :, :))*txd(2:nx_, :, :)
    v(1, 2:nx_, 1:ny_, 1:nz_) = (p(1:nx_-1, :, :)-p(2:nx_, :, :))*tx(2:&
&     nx_, :, :)
! V.y
    vd(2, 1:nx_, 2:ny_, 1:nz_) = (pd(:, 1:ny_-1, :)-pd(:, 2:ny_, :))*ty(&
&     :, 2:ny_, :) + (p(:, 1:ny_-1, :)-p(:, 2:ny_, :))*tyd(:, 2:ny_, :)
    v(2, 1:nx_, 2:ny_, 1:nz_) = (p(:, 1:ny_-1, :)-p(:, 2:ny_, :))*ty(:, &
&     2:ny_, :)
! V.z
    vd(3, 1:nx_, 1:ny_, 2:nz_) = (pd(:, :, 1:nz_-1)-pd(:, :, 2:nz_))*tz(&
&     :, :, 2:nz_) + (p(:, :, 1:nz_-1)-p(:, :, 2:nz_))*tzd(:, :, 2:nz_)
    v(3, 1:nx_, 1:ny_, 2:nz_) = (p(:, :, 1:nz_-1)-p(:, :, 2:nz_))*tz(:, &
&     :, 2:nz_)
  END SUBROUTINE TPFA_D
!
! Two point flux approximation.
!
  SUBROUTINE TPFA(k, q, p, v, solver_inner, solver_outer, verbose)
    IMPLICIT NONE
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: i
    INTEGER, DIMENSION(7) :: idiags
! the matrix containing the diagonal entries
    DOUBLE PRECISION, DIMENSION(n_, 7) :: diags
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: k
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
! local variables
    DOUBLE PRECISION :: tx_, ty_, tz_
    DOUBLE PRECISION, DIMENSION(nx_ + 1, ny_, nz_) :: tx
    DOUBLE PRECISION, DIMENSION(nx_, ny_ + 1, nz_) :: ty
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_ + 1) :: tz
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: txyz
! solution to the linear system
    DOUBLE PRECISION, DIMENSION(n_) :: u
! point-wise inverse of permeability
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: l
! sparse matrix
    INTEGER :: annz
    INTEGER, DIMENSION(7*n_) :: arow_index
    INTEGER, DIMENSION(7*n_) :: acol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: avalues
    INTEGER, DIMENSION(n_ + 1) :: arow_compressed
! get the point-wise inverse of the permeability matrix
    l = 1.0d0/k
    tx_ = 2.0d0*hy_*hz_/hx_
    ty_ = 2.0d0*hx_*hz_/hy_
    tz_ = 2.0d0*hy_*hx_/hz_
    tx = 0.0d0
    ty = 0.0d0
    tz = 0.0d0
! Compute transmissibilities by averaging harmonically
    tx(2:nx_, 1:ny_, 1:nz_) = tx_/(l(1, 1:nx_-1, 1:ny_, 1:nz_)+l(1, 2:&
&     nx_, 1:ny_, 1:nz_))
    ty(1:nx_, 2:ny_, 1:nz_) = ty_/(l(2, 1:nx_, 1:ny_-1, 1:nz_)+l(2, 1:&
&     nx_, 2:ny_, 1:nz_))
    tz(1:nx_, 1:ny_, 2:nz_) = tz_/(l(3, 1:nx_, 1:ny_, 1:nz_-1)+l(3, 1:&
&     nx_, 1:ny_, 2:nz_))
! initialize diags
    diags = 0.0d0
    txyz = -tx(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 5))
! -x1
    txyz = -ty(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 6))
! -y1
    txyz = -tz(1:nx_, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 7))
! -z1
    txyz = -tx(2:nx_+1, 1:ny_, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 3))
! -x2
    txyz = -ty(1:nx_, 2:ny_+1, 1:nz_)
    CALL MYRESHAPE_3_1(txyz, diags(:, 2))
! -y2
    txyz = -tz(1:nx_, 1:ny_, 2:nz_+1)
    CALL MYRESHAPE_3_1(txyz, diags(:, 1))
! -z2
! Assemble discretization matrix
    diags(:, 4) = -(diags(:, 1)+diags(:, 2)+diags(:, 3)+diags(:, 5)+&
&     diags(:, 6)+diags(:, 7))
!TODO: Have a variant of spdiags which will instead of writing it in
!the spmat type, it will write it in separate arrays sent to it.
    CALL SPDIAGS_FVM_CSR(diags, annz, arow_index, arow_compressed, &
&                  acol_index, avalues)
! ! Increment the 1,1 element of A
    CALL ADDX_ELEM2(annz, arow_index, arow_compressed, acol_index, &
&             avalues, perm(1, 1, 1, 1) + perm(2, 1, 1, 1) + perm(3, 1, &
&             1, 1), 1, 1)
! Fix the pressure at the inlets
!     do i = 1,annz
!       if(arow_index(i) < Nx_ * Ny_ .and. mod(arow_index(i), Ny_) == 1) then
!           if(arow_index(i) == acol_index(i)) then
!             avalues(i) = 1
!           else
!             avalues(i) = 0
!           endif
!       endif
!     enddo
! solve the linear system
! Pass the rows_index, cols_index, values separately.
    CALL SOLVE(annz, arow_index, arow_compressed, acol_index, avalues, q&
&        , u, solver_inner, solver_outer, verbose)
! reshape the solution
    CALL MYRESHAPE_1_3(u, p)
! V.x
    v(1, 2:nx_, 1:ny_, 1:nz_) = (p(1:nx_-1, :, :)-p(2:nx_, :, :))*tx(2:&
&     nx_, :, :)
! V.y
    v(2, 1:nx_, 2:ny_, 1:nz_) = (p(:, 1:ny_-1, :)-p(:, 2:ny_, :))*ty(:, &
&     2:ny_, :)
! V.z
    v(3, 1:nx_, 1:ny_, 2:nz_) = (p(:, :, 1:nz_-1)-p(:, :, 2:nz_))*tz(:, &
&     :, 2:nz_)
  END SUBROUTINE TPFA
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
! orow_compressed is not populated.
  SUBROUTINE SPDIAGS_FVM(imatrix, onnz, orow_index, orow_compressed, &
&   ocol_index, ovalues)
    IMPLICIT NONE
    LOGICAL :: done
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, start_row_imatrix, end_row_imatrix, row, col
    DOUBLE PRECISION, DIMENSION(n_, 7) :: imatrix
    INTEGER, DIMENSION(7), PARAMETER :: idiags=(/-(nx_*ny_), -nx_, -1, 0&
&     , 1, nx_, nx_*ny_/)
    INTEGER :: onnz
    INTEGER, DIMENSION(7*n_) :: orow_index
    INTEGER, DIMENSION(7*n_) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ovalues
    INTEGER, DIMENSION(n_ + 1) :: orow_compressed
    onnz = 0
    orow_compressed = 0
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix = idiags(i) + 1
        end_row_imatrix = n_
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix = 1
        end_row_imatrix = n_ + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row, col)
      DO j=start_row_imatrix,end_row_imatrix
        IF (row .EQ. col .OR. imatrix(j, i) .NE. 0) THEN
          onnz = onnz + 1
          orow_index(onnz) = row
          ocol_index(onnz) = col
          ovalues(onnz) = imatrix(j, i)
        END IF
        row = row + 1
        col = col + 1
      END DO
    END DO
  END SUBROUTINE SPDIAGS_FVM
!  Differentiation of spdiags_fvm_csr in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: ovalues
!   with respect to varying inputs: imatrix
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
!
  SUBROUTINE SPDIAGS_FVM_CSR_D(imatrix, imatrixd, onnz, orow_index, &
&   orow_compressed, ocol_index, ovalues, ovaluesd)
    IMPLICIT NONE
    LOGICAL :: done
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, rownnz
    DOUBLE PRECISION, DIMENSION(n_, 7) :: imatrix
    DOUBLE PRECISION, DIMENSION(n_, 7) :: imatrixd
    INTEGER, DIMENSION(7), PARAMETER :: idiags=(/-(nx_*ny_), -nx_, -1, 0&
&     , 1, nx_, nx_*ny_/)
    INTEGER, DIMENSION(7) :: start_row_imatrix, end_row_imatrix
! row, column along diagonal
    INTEGER, DIMENSION(7) :: row_diag, col_diag
    INTEGER :: onnz
    INTEGER, DIMENSION(7*n_) :: orow_index
    INTEGER, DIMENSION(7*n_) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ovalues
    DOUBLE PRECISION, DIMENSION(7*n_) :: ovaluesd
    INTEGER, DIMENSION(n_ + 1) :: orow_compressed
    onnz = 0
! compressed row storage
    orow_compressed(1) = 1
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix(i) = idiags(i) + 1
        end_row_imatrix(i) = n_
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix(i) = 1
        end_row_imatrix(i) = n_ + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row_diag(i), col_diag(i))
    END DO
    ovaluesd = 0.D0
! Do for each row in imatrix
    DO i=1,n_
! count the number of nonzeros in row
      rownnz = 0
! Do for each column in imatrix
      DO j=1,7
! Need to check if that column has any entry in this row
! checks that you are past the beginning of diagonal, remains fixed
        IF (row_diag(j) .LE. i .AND. start_row_imatrix(j) .LE. &
&           end_row_imatrix(j)) THEN
! checks that you have not exhausted the diagonal
          IF (imatrix(start_row_imatrix(j), j) .NE. 0.0d0) THEN
! checks that the diagonal entry is non zero
            onnz = onnz + 1
            rownnz = rownnz + 1
            orow_index(onnz) = i
            ocol_index(onnz) = col_diag(j)
            ovaluesd(onnz) = imatrixd(start_row_imatrix(j), j)
            ovalues(onnz) = imatrix(start_row_imatrix(j), j)
          END IF
          start_row_imatrix(j) = start_row_imatrix(j) + 1
          col_diag(j) = col_diag(j) + 1
        END IF
      END DO
      orow_compressed(i+1) = orow_compressed(i) + rownnz
    END DO
  END SUBROUTINE SPDIAGS_FVM_CSR_D
!
! Creates sparse diags matrix from rectangular matrix having the diagonals
!
  SUBROUTINE SPDIAGS_FVM_CSR(imatrix, onnz, orow_index, orow_compressed&
&   , ocol_index, ovalues)
    IMPLICIT NONE
    LOGICAL :: done
    DOUBLE PRECISION :: elm
    INTEGER :: i, j, rownnz
    DOUBLE PRECISION, DIMENSION(n_, 7) :: imatrix
    INTEGER, DIMENSION(7), PARAMETER :: idiags=(/-(nx_*ny_), -nx_, -1, 0&
&     , 1, nx_, nx_*ny_/)
    INTEGER, DIMENSION(7) :: start_row_imatrix, end_row_imatrix
! row, column along diagonal
    INTEGER, DIMENSION(7) :: row_diag, col_diag
    INTEGER :: onnz
    INTEGER, DIMENSION(7*n_) :: orow_index
    INTEGER, DIMENSION(7*n_) :: ocol_index
    DOUBLE PRECISION, DIMENSION(7*n_) :: ovalues
    INTEGER, DIMENSION(n_ + 1) :: orow_compressed
    onnz = 0
! compressed row storage
    orow_compressed(1) = 1
    DO i=1,7
      IF (idiags(i) .GT. 0) THEN
        start_row_imatrix(i) = idiags(i) + 1
        end_row_imatrix(i) = n_
      ELSE IF (idiags(i) .LE. 0) THEN
        start_row_imatrix(i) = 1
        end_row_imatrix(i) = n_ + idiags(i)
      END IF
      CALL FIRSTELM(idiags(i), row_diag(i), col_diag(i))
    END DO
! Do for each row in imatrix
    DO i=1,n_
! count the number of nonzeros in row
      rownnz = 0
! Do for each column in imatrix
      DO j=1,7
! Need to check if that column has any entry in this row
! checks that you are past the beginning of diagonal, remains fixed
        IF (row_diag(j) .LE. i .AND. start_row_imatrix(j) .LE. &
&           end_row_imatrix(j)) THEN
! checks that you have not exhausted the diagonal
          IF (imatrix(start_row_imatrix(j), j) .NE. 0.0d0) THEN
! checks that the diagonal entry is non zero
            onnz = onnz + 1
            rownnz = rownnz + 1
            orow_index(onnz) = i
            ocol_index(onnz) = col_diag(j)
            ovalues(onnz) = imatrix(start_row_imatrix(j), j)
          END IF
          start_row_imatrix(j) = start_row_imatrix(j) + 1
          col_diag(j) = col_diag(j) + 1
        END IF
      END DO
      orow_compressed(i+1) = orow_compressed(i) + rownnz
    END DO
  END SUBROUTINE SPDIAGS_FVM_CSR
END MODULE FVM_D

MODULE HEAD_D
  USE GRID_D
  USE MATRIX_D
  USE FVM_D
  IMPLICIT NONE
  INTEGER :: st, pt, nd
  PARAMETER (st=5, pt=100, nd=2000)
! Max saturation time step
! Pressure time step

CONTAINS
! Number of days in simulation
!
! This routine opens the permeability and porosity used by
! the MATLAB program and uses it for the simulation.
!
  SUBROUTINE READ_PERMEABILITY_AND_POROSITY(perm, por)
    IMPLICIT NONE
    INTEGER :: i, j, k, l, m
! Porosities
    DOUBLE PRECISION, DIMENSION(n_) :: por
! Permeabilities
    DOUBLE PRECISION, DIMENSION(3, nx_, ny_, nz_) :: perm
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(maxnx*maxny*maxnz) :: pur
    DOUBLE PRECISION, DIMENSION(3*maxnx, maxny*maxnz) :: kur
    DOUBLE PRECISION, DIMENSION(3*maxnx*maxny*maxnz) :: kurl
    INTEGER, DIMENSION(nx_*ny_*nz_) :: pindices
    INTEGER, DIMENSION(3*nx_*ny_*nz_) :: kindices
! initialize porosity and permeability to zero
    perm = 0.0d0
    por = 0.0d0
! read KUr
    OPEN(1, file='KUr.txt', status='old') 
    READ(1, *) ((kur(i, j), j=1,maxny*maxnz), i=1,3*maxnx)
    CLOSE(1) 
! reshape 2 dimension to 1 dimension
    CALL MYRESHAPE_2_1(kur, kurl)
! select according to specified dimension
    m = 0
    DO l=1,nz_
      DO k=1,ny_
        DO j=1,nx_
          DO i=1,3
            m = m + 1
            kindices(m) = (l-1)*(maxnx*maxny*3) + (k-1)*(maxnx*3) + 3*(j&
&             -1) + i
          END DO
        END DO
      END DO
    END DO
! then reshape 1 dimension to 4 dimension (hack for time being)
    CALL MYRESHAPE_1_4(kurl(kindices), perm)
! read KUr
    OPEN(1, file='pUr.txt', status='old') 
    READ(1, *) (pur(i), i=1,maxnx*maxny*maxnz)
    CLOSE(1) 
    m = 0
    DO k=1,nz_
      DO j=1,ny_
        DO i=1,nx_
          m = m + 1
          pindices(m) = (k-1)*(maxnx*maxny) + (j-1)*maxnx + i
        END DO
      END DO
    END DO
!POR = max(pUr(Pindices), 1.0d-3)
    CALL MYMAX_1_0_DOUBLE(pur(pindices), 1.0d-3, por)
  END SUBROUTINE READ_PERMEABILITY_AND_POROSITY
!  Differentiation of wrapper in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: oil
!   with respect to varying inputs: sigma mu
!   RW status of diff variables: sigma:in oil:out pc:(loc) mu:in
  SUBROUTINE WRAPPER_D(ir, mu, mud, sigma, sigmad, q, s, p, v, st, pt, &
&   tt, nd, mw, mo, mt, pc, pcd, oil, oild, solver_inner, solver_outer, &
&   verbose)
    USE GRID_D
    USE FLUID_D
    IMPLICIT NONE
!$openad dependent(oil)
    INTEGER :: nd, st, pt
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    DOUBLE PRECISION :: mu, sigma, ir
    DOUBLE PRECISION :: mud, sigmad
    DOUBLE PRECISION :: mw, mo, mt
    DOUBLE PRECISION :: oil
    DOUBLE PRECISION :: oild
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qd
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(2, nd/st+1) :: pcd
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
!$openad independent(mu)
!$openad independent(sigma)
!$openad independent(ir)
    CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT_D(ir, mu, mud, sigma, sigmad, q, &
&                                  qd)
    CALL SIMULATE_RESERVOIR_D(q, qd, s, p, v, st, pt, tt, nd, mw, mo, mt&
&                       , pc, pcd, oil, oild, solver_inner, solver_outer&
&                       , verbose)
  END SUBROUTINE WRAPPER_D
!  Differentiation of init_flw_trnc_norm_xin_pt_out in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: q
!   with respect to varying inputs: sigma mu
!
! Initialize inflow and outflow.
!
  SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT_D(ir, mu, mud, sigma, sigmad&
&   , q, qd)
    IMPLICIT NONE
!---------------------------------------------------------------------------
! Call GNUPLOT through the interface module.
! Uncomment these plot calls after verifying you have GNUPlot installed.
!---------------------------------------------------------------------------
! Plot the Q and check if it is correct.
!call plot(idx, Q_x, terminal='png', filename='inflow.png')
!!use gnufor2
    INTEGER :: i, j
    DOUBLE PRECISION, DIMENSION(nx_) :: idx
    DOUBLE PRECISION :: x, pi, pdf, mass
    DOUBLE PRECISION :: pdfd, massd
    DOUBLE PRECISION :: mu, sigma, ir
    DOUBLE PRECISION :: mud, sigmad
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qd
    DOUBLE PRECISION, DIMENSION(nx_) :: q_x
    DOUBLE PRECISION, DIMENSION(nx_) :: q_xd
    INTRINSIC SQRT
    INTRINSIC EXP
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: arg1
    DOUBLE PRECISION :: arg1d
! value of pi
    pi = 3.14159265358979323d0
!initialize the total mass to 0
    mass = 0.0d0
    q_x = 0.0d0
    massd = 0.D0
    q_xd = 0.D0
! Note that the portion of the  Standard Normal distribution between
! -3sigma/2 to 3sigma/2 is assumed to fit the 1..Nx where sigma is 1
    DO i=1,nx_
! get the real x coordinate
! Mapping x = [-1.5, 1.5] to Nx_ dimension
      x = -1.5d0 + (i-1)*3.0d0/(nx_-1)
! Now use mu and sigma to find the pdf value at x
      result1 = SQRT(2.0d0*pi)
      arg1d = -(2.0d0*(x-mu)*(-(mud*sigma)-(x-mu)*sigmad)/sigma**3/2.0d0&
&       )
      arg1 = -(((x-mu)/sigma)**2.0d0/2.0d0)
      pdfd = arg1d*EXP(arg1)/(sigma*result1) - sigmad*EXP(arg1)/(result1&
&       *sigma**2)
      pdf = 1.0d0/(sigma*result1)*EXP(arg1)
! set the value at the index equal to the pdf value at that point
      q_xd(i) = pdfd
      q_x(i) = pdf
! increment the mass by the value of the pdf
      massd = massd + pdfd
      mass = mass + pdf
! index to test initialization by plot
      idx(i) = i*1.0
    END DO
! now rescale all the entities
    q_xd = ir*(q_xd*mass-q_x*massd)/mass**2
    q_x = q_x/mass*ir
! Assign Q_x to Q
    j = 1
    qd = 0.D0
    DO i=1,nx_*ny_,ny_
      qd(i) = q_xd(j)
      q(i) = q_x(j)
      j = j + 1
    END DO
! now set the output
    qd(n_) = 0.D0
    q(n_) = -ir
  END SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT_D
!  Differentiation of simulate_reservoir in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: oil
!   with respect to varying inputs: q
!
! This subroutine simulates the reservoir
! model.
!
  SUBROUTINE SIMULATE_RESERVOIR_D(q, qd, s, p, v, st, pt, tt, nd, mw, mo&
&   , mt, pc, pcd, oil, oild, solver_inner, solver_outer, verbose)
    USE GRID_D
    USE FLUID_D
    IMPLICIT NONE
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: i, j, k, nd, st, pt
    DOUBLE PRECISION :: mw, mo, mt, tempoil1, tempoil2
    DOUBLE PRECISION :: mwd, mod0, mtd, tempoil1d, tempoil2d
    DOUBLE PRECISION :: oil
    DOUBLE PRECISION :: oild
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: sd
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(n_) :: qd
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(2, nd/st+1) :: pcd
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: pd
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
    DOUBLE PRECISION, DIMENSION(3, nx_+1, ny_+1, nz_+1) :: vd
! initial saturation
    s = swc_
! initial production
    pcd(1, 1) = 0.D0
    pc(1, 1) = 0.0d0
    pcd(2, 1) = 0.D0
    pc(2, 1) = 1.0d0
! initial time.
    tt(1) = 0.0d0
    tempoil1 = 0.0d0
    tempoil2 = 0.0d0
    k = 1
    pd = 0.D0
    sd = 0.D0
    vd = 0.D0
    pcd = 0.D0
    tempoil1d = 0.D0
    tempoil2d = 0.D0
    DO i=1,nd/pt
      CALL PRES_D(s, sd, q, qd, p, pd, v, vd, solver_inner, solver_outer&
&           , verbose)
! Pressure solver
!        write (*,*) 'PRESSURE========================================================'
      DO j=1,pt/st
!            write(*,*) "Outer:", i, "Inner:", j
        k = k + 1
        CALL NEWTRAPH_D(s, sd, v, vd, q, qd, st, solver_inner, &
&                 solver_outer, verbose)
! Solve for saturation
        CALL RELPERM_D(s(n_), sd(n_), mw, mwd, mo, mod0)
! Mobilities in well-block
        mtd = mwd + mod0
        mt = mw + mo
        tt(k) = 1.0d0*k*st
        pcd(1, k) = (mwd*mt-mw*mtd)/mt**2
        pc(1, k) = mw/mt
        pcd(2, k) = (mod0*mt-mo*mtd)/mt**2
        pc(2, k) = mo/mt
        CALL UPDATE_OIL_D(pc, pcd, k, st, tempoil1, tempoil1d, tempoil2&
&                   , tempoil2d)
        tempoil1d = tempoil2d
        tempoil1 = tempoil2
      END DO
    END DO
    oild = tempoil2d
    oil = tempoil2
  END SUBROUTINE SIMULATE_RESERVOIR_D
!  Differentiation of update_oil in forward (tangent) mode (with options noISIZE):
!   variations   of useful results: oilout
!   with respect to varying inputs: oilin pc
  SUBROUTINE UPDATE_OIL_D(pc, pcd, k, st, oilin, oilind, oilout, oiloutd&
& )
    IMPLICIT NONE
    INTEGER :: st, k
    DOUBLE PRECISION :: oilin
    DOUBLE PRECISION :: oilind
    DOUBLE PRECISION :: oilout
    DOUBLE PRECISION :: oiloutd
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(2, nd/st+1) :: pcd
! Reimann sum
    oiloutd = oilind + st*pcd(2, k)
    oilout = oilin + pc(2, k)*st
  END SUBROUTINE UPDATE_OIL_D
  SUBROUTINE WRAPPER(ir, mu, sigma, q, s, p, v, st, pt, tt, nd, mw, mo, &
&   mt, pc, oil, solver_inner, solver_outer, verbose)
    USE GRID_D
    USE FLUID_D
    IMPLICIT NONE
!$openad dependent(oil)
    INTEGER :: nd, st, pt
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    DOUBLE PRECISION :: mu, sigma, ir
    DOUBLE PRECISION :: mw, mo, mt
    DOUBLE PRECISION :: oil
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
!$openad independent(mu)
!$openad independent(sigma)
!$openad independent(ir)
    CALL INIT_FLW_TRNC_NORM_XIN_PT_OUT(ir, mu, sigma, q)
    CALL SIMULATE_RESERVOIR(q, s, p, v, st, pt, tt, nd, mw, mo, mt, pc, &
&                     oil, solver_inner, solver_outer, verbose)
  END SUBROUTINE WRAPPER
!
! Initialize inflow and outflow.
!
  SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT(ir, mu, sigma, q)
    IMPLICIT NONE
!---------------------------------------------------------------------------
! Call GNUPLOT through the interface module.
! Uncomment these plot calls after verifying you have GNUPlot installed.
!---------------------------------------------------------------------------
! Plot the Q and check if it is correct.
!call plot(idx, Q_x, terminal='png', filename='inflow.png')
!!use gnufor2
    INTEGER :: i, j
    DOUBLE PRECISION, DIMENSION(nx_) :: idx
    DOUBLE PRECISION :: x, pi, pdf, mass
    DOUBLE PRECISION :: mu, sigma, ir
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(nx_) :: q_x
    INTRINSIC SQRT
    INTRINSIC EXP
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: arg1
! value of pi
    pi = 3.14159265358979323d0
!initialize the total mass to 0
    mass = 0.0d0
    q_x = 0.0d0
! Note that the portion of the  Standard Normal distribution between
! -3sigma/2 to 3sigma/2 is assumed to fit the 1..Nx where sigma is 1
    DO i=1,nx_
! get the real x coordinate
! Mapping x = [-1.5, 1.5] to Nx_ dimension
      x = -1.5d0 + (i-1)*3.0d0/(nx_-1)
! Now use mu and sigma to find the pdf value at x
      result1 = SQRT(2.0d0*pi)
      arg1 = -(((x-mu)/sigma)**2.0d0/2.0d0)
      pdf = 1.0d0/(sigma*result1)*EXP(arg1)
! set the value at the index equal to the pdf value at that point
      q_x(i) = pdf
! increment the mass by the value of the pdf
      mass = mass + pdf
! index to test initialization by plot
      idx(i) = i*1.0
    END DO
! now rescale all the entities
    q_x = q_x/mass*ir
! Assign Q_x to Q
    j = 1
    DO i=1,nx_*ny_,ny_
      q(i) = q_x(j)
      j = j + 1
    END DO
! now set the output
    q(n_) = -ir
  END SUBROUTINE INIT_FLW_TRNC_NORM_XIN_PT_OUT
!
! This subroutine simulates the reservoir
! model.
!
  SUBROUTINE SIMULATE_RESERVOIR(q, s, p, v, st, pt, tt, nd, mw, mo, mt, &
&   pc, oil, solver_inner, solver_outer, verbose)
    USE GRID_D
    USE FLUID_D
    IMPLICIT NONE
    LOGICAL :: verbose
    INTEGER :: solver_inner, solver_outer
    INTEGER :: i, j, k, nd, st, pt
    DOUBLE PRECISION :: mw, mo, mt, tempoil1, tempoil2
    DOUBLE PRECISION :: oil
    DOUBLE PRECISION, DIMENSION(nd/st + 1) :: tt
    DOUBLE PRECISION, DIMENSION(n_) :: s
    DOUBLE PRECISION, DIMENSION(n_) :: q
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
    DOUBLE PRECISION, DIMENSION(nx_, ny_, nz_) :: p
    DOUBLE PRECISION, DIMENSION(3, nx_ + 1, ny_ + 1, nz_ + 1) :: v
! initial saturation
    s = swc_
! initial production
    pc(1, 1) = 0.0d0
    pc(2, 1) = 1.0d0
! initial time.
    tt(1) = 0.0d0
    tempoil1 = 0.0d0
    tempoil2 = 0.0d0
    k = 1
    DO i=1,nd/pt
      CALL PRES(s, q, p, v, solver_inner, solver_outer, verbose)
! Pressure solver
!        write (*,*) 'PRESSURE========================================================'
      DO j=1,pt/st
!            write(*,*) "Outer:", i, "Inner:", j
        k = k + 1
        CALL NEWTRAPH(s, v, q, st, solver_inner, solver_outer, verbose)
! Solve for saturation
        CALL RELPERM(s(n_), mw, mo)
! Mobilities in well-block
        mt = mw + mo
        tt(k) = 1.0d0*k*st
        pc(1, k) = mw/mt
        pc(2, k) = mo/mt
        CALL UPDATE_OIL(pc, k, st, tempoil1, tempoil2)
        tempoil1 = tempoil2
      END DO
    END DO
    oil = tempoil2
  END SUBROUTINE SIMULATE_RESERVOIR
  SUBROUTINE UPDATE_OIL(pc, k, st, oilin, oilout)
    IMPLICIT NONE
    INTEGER :: st, k
    DOUBLE PRECISION :: oilin
    DOUBLE PRECISION :: oilout
    DOUBLE PRECISION, DIMENSION(2, nd/st + 1) :: pc
! Reimann sum
    oilout = oilin + pc(2, k)*st
  END SUBROUTINE UPDATE_OIL
END MODULE HEAD_D

